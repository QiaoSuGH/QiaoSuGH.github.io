<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Go-03-多线程下载器</title>
    <link href="/2021/03/16/Go-03-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8B%E8%BD%BD%E5%99%A8/"/>
    <url>/2021/03/16/Go-03-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8B%E8%BD%BD%E5%99%A8/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Go-02-实现B+树</title>
    <link href="/2021/03/16/Go-02-%E5%AE%9E%E7%8E%B0B-%E6%A0%91/"/>
    <url>/2021/03/16/Go-02-%E5%AE%9E%E7%8E%B0B-%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<hr><h5 id="B-树的基本原理"><a href="#B-树的基本原理" class="headerlink" title="B+树的基本原理"></a>B+树的基本原理</h5><ul><li><p>二叉查找树，可能变成链表，导致效率非常低。</p></li><li><p>平衡二叉树AVL，通过限制节点左右子树的层级差不大于1从而确保二叉树的搜索效率</p></li><li>B树：在平衡二叉树的基础上增加每个节点的key的数目<ul><li>对于m阶B树(m &gt;= 2)，非叶子节点的子节点数目[2, m]，枝节点的key数量在[ceil(m/2)-1, m-1]，叶子节点均位于同一层</li><li>查找：原理就是不断二分</li><li>插入：直接插入叶子节点；可能会导致叶子节点key数量超出限制，需要拆分。循环：将节点的中心key插入到父节点，原本节点的左右两段分别属于key的左右；直到没有节点超出限制。</li><li>删除：如果待删除key位于非叶子节点，通过后续节点替换的方式确保最终需要删除的节点位于叶子节点；删除之后可能数量不够<ul><li>如果兄弟节点数量大于ceil(m/2)-1，那么借用</li><li>否则将父节点的key与当前节点、兄弟节点进行合并</li></ul></li></ul></li><li>B+树<ul><li>定义：MySql当中非叶子节点的key数量等同于子节点数量。另外一种定义就是子节点数量要多1。注意根节点也可以是叶子节点。</li><li>与B树相比，重要的区别在于只有叶子节点才存储了data，而非叶子节点则只存储了索引。因此带来了插入删除的变化。</li></ul></li></ul><h5 id="B-树在工程中的应用"><a href="#B-树在工程中的应用" class="headerlink" title="B+树在工程中的应用"></a>B+树在工程中的应用</h5><p>Mysql的InnoDB存储引擎使用了B+树。</p><ul><li>对于聚集索引——将主键作为B+树的key，叶子节点存储真正的数据。每个节点大小刚好对应磁盘的一页，每次根据指向子节点的指针从磁盘中读取下一页。注意根节点所在的页常驻内存。同时节点之间双向连接，叶子节点中的数据单向连接。使得范围查询也很简单：在查找范围的左边界之后，沿着链表走即可。</li><li>对于非聚集索引，B+树的key是非主键的列值，数据则是主键。这样我们根据非主键的列进行查找时，首先找到对应的主键，再在聚集索引中寻找到真正的数据。</li></ul><p>为什么使用B+树而非B树？</p><ul><li>磁盘访问速度很慢，因此需要尽量减少磁盘的访问次数。同时磁盘的访问以块为单位。<ul><li>数据库中页的概念</li><li>为什么一个节点对应一个扇区？</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go-01-GMP模型</title>
    <link href="/2021/03/16/Go-01-GMP%E6%A8%A1%E5%9E%8B/"/>
    <url>/2021/03/16/Go-01-GMP%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h5 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h5><ul><li><p><a href="https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-goroutine/#651-%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86" target="_blank" rel="noopener">https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-goroutine/#651-%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86</a></p><p>《Go语言设计与实现》</p></li><li><p><a href="https://juejin.cn/post/6886321367604527112" target="_blank" rel="noopener">https://juejin.cn/post/6886321367604527112</a> </p></li></ul><h5 id="调度的整体流程"><a href="#调度的整体流程" class="headerlink" title="调度的整体流程"></a>调度的整体流程</h5><ul><li>P中存在着一个本地队列以及<code>runnext guintptr</code>，用于M获取runable的G。M首先要与P绑定，然后不断地获取G去执行。</li><li>获取过程：<ul><li>如果M绑定的P为空，那么前往全局队列尝试获取G<ul><li>如果全局队列仍然为空，那么work-stealing</li><li>如果一直没有G，那么进入idle状态</li></ul></li></ul></li><li>执行过程：<ul><li>如果G因为systemcall而阻塞，那么M被阻塞，P与M解绑，尝试重新绑定到一个idle的M或者新建一个M</li><li>如果G因为channel阻塞，那么G会被放到某个等待队列，M会尝试获取下一个G—G2。当原本的G被唤醒时，会被加入到P的<code>runnext</code>。如果M没有获取到G，那么解绑并sleep。</li><li>如果没有阻塞，那么M执行完毕之后不会被销毁，而是继续获取G再执行，这样就避免了线程创建销毁带来的开销。</li></ul></li></ul><h5 id="设计原理"><a href="#设计原理" class="headerlink" title="设计原理"></a>设计原理</h5><p>很早版本的单线程调度器已经有了G和M，下面是切换G时保存状态的代码：</p><div class="hljs"><pre><code class="hljs assembly">TEXT gosave(SB), 7, $0MOVQ8(SP), AX&#x2F;&#x2F; gobufMOVQSP, 0(AX)&#x2F;&#x2F; save SPMOVQ0(SP), BXMOVQBX, 8(AX)&#x2F;&#x2F; save PCMOVL$0, AX&#x2F;&#x2F; return 0RET</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Nachos-01-线程管理</title>
    <link href="/2021/03/15/Nachos-01-%E7%BA%BF%E7%A8%8B%E7%AE%A1%E7%90%86/"/>
    <url>/2021/03/15/Nachos-01-%E7%BA%BF%E7%A8%8B%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<hr><p>在学操作系统的时候就有很多疑惑：</p><ul><li>上下文切换细节是什么，硬件软件层面分别做了哪些具体的工作？</li><li>线程的映射模型到底是什么意思？什么是映射？为何需要映射？不同的映射模型到底是如何实现的？</li><li>共享内存是如何实现的？怎么映射到同一块内存——物理的？Linux里面<code>task_struct</code>结构体中拥有指向<code>mm_struct</code>的指针，对<code>mm_struct</code>的理解</li><li>第一个进程是如何创建的？</li></ul><p>……</p><p>产生疑惑的重要原因就在于没有看内核设计、没有看源码，导致都是在一些抽象概念上面游走。所以现在结合Nachos以及Linux内核设计与实现来真正理解OS。当然，并不会逐句分析源码，仅仅分析关键部分。</p><hr><h4 id="线程创建"><a href="#线程创建" class="headerlink" title="线程创建"></a>线程创建</h4><h5 id="main线程的创建"><a href="#main线程的创建" class="headerlink" title="main线程的创建"></a>main线程的创建</h5><p><code>main.cc--&gt;system.cc.Initialize--&gt;currentthread = new Thread(&quot;main&quot;)</code></p><p><code>thread.h</code>定义了线程类，我们创建线程的时候只需要提供一个<code>char * debugName</code>，感觉是用来debug的、并没有实际用处。真正执行时我们会用到<code>fork</code>函数：<code>void Fork(VoidFunctionPtr func, _int arg); // Make thread run (*func)(arg)</code>。</p><div class="hljs"><pre><code class="hljs c++"><span class="hljs-comment">// We didn't explicitly allocate the current thread we are running in.</span><span class="hljs-comment">// But if it ever tries to give up the CPU, we better have a Thread</span><span class="hljs-comment">// object to save its state. </span>currentThread = <span class="hljs-keyword">new</span> Thread(<span class="hljs-string">"main"</span>);currentThread-&gt;setStatus(RUNNING);</code></pre></div><p>线程内部定义了<code>status stack stack_top machineState</code>等变量。可以看到我们并没有分配栈等资源。</p><p>在分配栈资源的函数里面：</p><div class="hljs"><pre><code class="hljs c++"><span class="hljs-keyword">void</span>Thread::StackAllocate (VoidFunctionPtr func, _int arg)&#123;    <span class="hljs-built_in">stack</span> = (<span class="hljs-keyword">int</span> *) AllocBoundedArray(StackSize * <span class="hljs-keyword">sizeof</span>(_int));<span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> HOST_SNAKE</span>    <span class="hljs-comment">// HP stack works from low addresses to high addresses</span>    stackTop = <span class="hljs-built_in">stack</span> + <span class="hljs-number">16</span>;<span class="hljs-comment">// HP requires 64-byte frame marker</span>    <span class="hljs-built_in">stack</span>[StackSize - <span class="hljs-number">1</span>] = STACK_FENCEPOST;<span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span>    <span class="hljs-comment">// i386 &amp; MIPS &amp; SPARC &amp; ALPHA stack works from high addresses to low addresses</span><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> HOST_SPARC</span>    <span class="hljs-comment">// SPARC stack must contains at least 1 activation record to start with.</span>    stackTop = <span class="hljs-built_in">stack</span> + StackSize - <span class="hljs-number">96</span>;<span class="hljs-meta">#<span class="hljs-meta-keyword">else</span>  <span class="hljs-comment">// HOST_MIPS  || HOST_i386 || HOST_ALPHA</span></span>    stackTop = <span class="hljs-built_in">stack</span> + StackSize - <span class="hljs-number">4</span>;<span class="hljs-comment">// -4 to be on the safe side!</span><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> HOST_i386</span>......</code></pre></div><p>这里首先需要分配内存并返回指向栈底的指针给<code>stack</code>。</p><div class="hljs"><pre><code class="hljs c++"><span class="hljs-keyword">char</span> * AllocBoundedArray(<span class="hljs-keyword">int</span> <span class="hljs-built_in">size</span>)&#123;    <span class="hljs-keyword">int</span> pgSize = getpagesize();    <span class="hljs-keyword">char</span> *ptr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[pgSize * <span class="hljs-number">2</span> + <span class="hljs-built_in">size</span>];    mprotect(ptr, pgSize, <span class="hljs-number">0</span>);    mprotect(ptr + pgSize + <span class="hljs-built_in">size</span>, pgSize, <span class="hljs-number">0</span>);    <span class="hljs-keyword">return</span> ptr + pgSize;&#125;</code></pre></div><ul><li><p>这个<code>mprotect</code>很容易让人想到内存保护中，设置两个寄存器用于访存时比较目标地址判断是否越界。找到定义：</p><div class="hljs"><pre><code class="hljs c++"><span class="hljs-comment">//mman.h</span><span class="hljs-comment">/* Change the memory protection of the region starting at ADDR and</span><span class="hljs-comment">   extending LEN bytes to PROT.  Returns 0 if successful, -1 for errors</span><span class="hljs-comment">   (and sets errno).  */</span><span class="hljs-function"><span class="hljs-keyword">extern</span> <span class="hljs-keyword">int</span> <span class="hljs-title">mprotect</span> <span class="hljs-params">(<span class="hljs-keyword">void</span> *__addr, <span class="hljs-keyword">size_t</span> __len, <span class="hljs-keyword">int</span> __prot)</span> __THROW</span>;</code></pre></div></li><li><div class="hljs"><pre><code class="lang-c++"># if defined __USE_MISC || !defined __USE_XOPEN2K/* Return the number of bytes in a page.  This is the system&#39;s page size,   which is not necessarily the same as the hardware page size.  */extern int getpagesize (void)  __THROW __attribute__ ((__const__));</code></pre></div><p>Nachos页大小为128KB，<code>StackSize</code>定义为<code>sizeof(int) * 1024</code>。这里又乘了<code>sizeof(int)</code>。<strong>有点奇怪。</strong>    </p></li></ul><p>注意在线程类里面还有关键的定义：</p><p><img src="https://i.loli.net/2021/03/15/slownGLyqAaH7R8.png" srcset="/img/loading.gif" alt="image-20210315172229189" style="zoom:67%;" /></p><p>这里的<code>AddrSpace *space</code>指向进程的地址空间。暂时不是很明确。</p><h5 id="线程创建、调度、执行入口、终止"><a href="#线程创建、调度、执行入口、终止" class="headerlink" title="线程创建、调度、执行入口、终止"></a>线程创建、调度、执行入口、终止</h5><ul><li><p>首先线程在创建时的状态是<code>JUST_CREATED</code>。之后在调用<code>fork</code>之后分配栈资源，并且将其加入调度器的就绪队列。</p></li><li><p>在分配栈空间时，会设置一些<code>machineState</code>。</p><p><img src="https://i.loli.net/2021/03/15/Yzmw3CdqV4kIZNQ.png" srcset="/img/loading.gif" alt="image-20210315174215941"></p><p>这个<code>ThreadRoot</code>位于<code>switch.s</code>。</p></li><li></li></ul>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
      <category>Nachos</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
      <tag>Nachos</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CS144-05-Lab4</title>
    <link href="/2021/03/11/CS144-05-Lab4/"/>
    <url>/2021/03/11/CS144-05-Lab4/</url>
    
    <content type="html"><![CDATA[<blockquote><p>We’d discourage you from trying to read the test source code, unless it is as a last resort</p></blockquote><p>看来还是不要测试驱动开发了。</p><hr><p>总结一下之前的实验二和三，我们已经实现了receiver/sender，里面的逻辑已经基本清晰：</p><ul><li>receiver<ul><li>接收segment，根据SYN/FIN/seqno等信息决定舍弃与否，如果接收那么放入reassembler的一个实例</li><li>返回期望接收的第一个byte的seqno</li></ul></li><li>sender<ul><li>根据接收到的window_size以及ackno来发送bytes</li><li>记录了连续重传的相关信息，可以用来判断是否应该断开连接</li><li>重要的逻辑是计时器相关，什么时候开/关/之后的行为</li></ul></li></ul><p>而在实验四，我们需要完成<code>tcp_connection</code>，即包括receiver and sender。因为TCP是全双工的，连接的一方既会接收也会发送。我们首先考虑一下两者之间的联系：</p><ul><li>receiver接收到的seg里面可能包括ackno/window_size，需要反馈给sender</li><li>receiver接收到SYN/FIN/reset信息</li></ul><hr><h5 id="remaining-outbound-capacity"><a href="#remaining-outbound-capacity" class="headerlink" title="remaining_outbound_capacity()"></a>remaining_outbound_capacity()</h5><p>注意，我们的connection供上层调用，sender用来发送bytes，调用者希望知道还能发送多少bytes——sender中<code>ByteSream _stream</code>的剩余容量。</p><hr><h5 id="FAQs"><a href="#FAQs" class="headerlink" title="FAQs"></a>FAQs</h5><p>完成了几个normal functions，接下来仔细阅读FAQs。</p><ul><li><p>为什么connection也有一个<code>_segments_out</code>。但是sender不是有一个<code>_segments_out</code>吗</p><ul><li>注意在sender中我们并没有真正的发送——只是将segments放入到了<code>_segment_out</code> 当中。那么connection的实现需要我们将  sender的<code>_segments_out</code>传到connection的<code>_segments_out</code>。</li><li>这里需要结合那张图：CS144TCPSocket来理解。connection封装了sender/receiver。对于接受来说，首先是connection接受了，然后再传送给receiver。</li></ul></li><li><p>关于RST</p><ul><li>收到了怎么办</li><li><p>什么情况应该发送</p></li><li><p>如何在不侵入sender的情况下完成发送？</p></li></ul></li><li><p>ACK</p><ul><li>发送时的设置</li><li>接收segment时判断</li></ul></li><li><p>结束connection</p><ul><li>unclean</li><li>clean</li></ul></li></ul><h5 id="clean-unclean-shutdown"><a href="#clean-unclean-shutdown" class="headerlink" title="clean/unclean shutdown"></a>clean/unclean shutdown</h5><blockquote><p> If the inbound stream ends before theTCPConnectionhas reached EOF on its outbound stream, this variable needs to be set to false</p></blockquote><p>怎么理解？初步的想法是结合<code>TIME_WAIT</code>状态，我们已经发送了FIN并且被ACK了，并且对方发送了FIN我们也进行了ACK，但是这时候我们需要等待一段时间，因为我们的ACK未必被对方接受、对方可能会重传FIN，因此我们需要保持inbound stream open来接收。如果inbound stream已经结束了，那么自然没有等待的必要了。但是是怎么实现重传ACK的？收到FIN之后receiver端就关闭了输入，由connection直接发送？</p><p><code>clean_shutdown</code>任务是在正常的情况下设置<code>_active = false</code>。条件是什么？</p><h5 id="write"><a href="#write" class="headerlink" title="write"></a>write</h5><ul><li>将data写入sender的ByteStream中</li><li>将sender的_segments_out pop掉</li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
      <category>CS144</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
      <tag>CS144</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>High Performance Mysql [Notes]</title>
    <link href="/2021/03/07/High%20Performance%20Mysql%20%5BNotes%5D/"/>
    <url>/2021/03/07/High%20Performance%20Mysql%20%5BNotes%5D/</url>
    
    <content type="html"><![CDATA[<h3 id="ch1-Mysql-Architecture-and-History"><a href="#ch1-Mysql-Architecture-and-History" class="headerlink" title="ch1 Mysql Architecture and History"></a>ch1 Mysql Architecture and History</h3><h4 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h4><h5 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h5><ul><li><p>ACID属性</p></li><li><p>隔离性的四个级别</p><ul><li><p>关于nonrepeatedable read</p><blockquote><p>…a transaction T2 could change the value of an object A that has been read by a transaction T1, while T1 is still in progress. If T1 tries to read the value of A again, it will get a different result, even though it has not modified A in the meantime… —<em>Database Management Systems</em></p></blockquote></li></ul></li></ul><h5 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h5>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>Mysql</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
      <tag>Mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CS144-04-Lab3</title>
    <link href="/2021/03/07/CS144-04-Lab3/"/>
    <url>/2021/03/07/CS144-04-Lab3/</url>
    
    <content type="html"><![CDATA[<h5 id="为什么需要随机的ISN"><a href="#为什么需要随机的ISN" class="headerlink" title="为什么需要随机的ISN"></a>为什么需要随机的ISN</h5><p><a href="https://www.quora.com/Why-in-a-TCP-sequence-is-a-number-taken-as-a-random-number-and-what-is-the-actual-number-at-the-start" target="_blank" rel="noopener">https://www.quora.com/Why-in-a-TCP-sequence-is-a-number-taken-as-a-random-number-and-what-is-the-actual-number-at-the-start</a></p><p><a href="https://www.techrepublic.com/article/tcp-hijacking/" target="_blank" rel="noopener">https://www.techrepublic.com/article/tcp-hijacking/</a></p><p><a href="https://pdos.csail.mit.edu/~rtm/papers/117.pdf" target="_blank" rel="noopener">https://pdos.csail.mit.edu/~rtm/papers/117.pdf</a></p><p>主要是与一些攻击方式有关系。具体的原理尚未明白。</p><h4 id="Implementing-the-TCP-Sender"><a href="#Implementing-the-TCP-Sender" class="headerlink" title="Implementing the TCP Sender"></a>Implementing the TCP Sender</h4><h5 id="前置的思考探索"><a href="#前置的思考探索" class="headerlink" title="前置的思考探索"></a>前置的思考探索</h5><p>TCP  sender会接收byte-stream，然后将其拆分、填充成segments。对于来自receiver的segment，主要关心ackno和window size。</p><ul><li>类似于receiver，应该同样需要涉及到stream index和absolute seqno/seqno之间的转换。</li></ul><p>如何实现ARQ？</p><ul><li><p>注意segment可能有部分byte被确认了——返回的ackno之前的。</p></li><li><p>我们怎么知道哪些segment需要重传？有两个方面需要考虑，一是所有未被确认的segment，二是与计时器相关。我们采用的是累计确认，每次从receiver获得ackno之后，ackno之前的segment都被确认了。确认了那么也就没有必要继续保存了。我们在<code>queue&lt;TCPSegment&gt; _segments_out</code>中保存了发送出去的segments。那么可以考虑未被确认的继续留在<code>_segment_out</code>中。</p><p>对于<code>tick(const size_t ms_since_last_tick)</code>我们知道参数是自从上次<code>tick()</code>被调用经历的毫秒数，但是它负责什么？startercode里面并没有<code>retransmissions timer</code>。</p><blockquote><p>看了一下网上的实现，发现<code>tick()</code>的调用是在Lab4……决定去看看测试</p></blockquote></li></ul><h5 id="关于计时器"><a href="#关于计时器" class="headerlink" title="关于计时器"></a>关于计时器</h5><p>通过指导书我们知道两件事：</p><ul><li>计时器需要有一个状态变量记录当前状态：on/off</li><li>需要记录从开启时经过的时间<ul><li>注意指导书提到了不需要任何的系统的时间，而是通过<code>tick()</code>的调用完成的。每次调用时调用者传递的参数让我们知道时间的累积</li></ul></li><li>为了简便起见我们并不增加新的<code>timer</code>类，直接增加两个成员即可。</li></ul><h5 id="关于window"><a href="#关于window" class="headerlink" title="关于window"></a>关于window</h5><p>receiver每次会返回它的接收字符的absolute seqno的范围，但是对于sender来说，在发送seg之后应该更新sender的window——sender自己应该也需要有变量记录这样的更新。</p><h5 id="fill-window"><a href="#fill-window" class="headerlink" title="fill_window"></a><code>fill_window</code></h5><p>首先我们需要明确发送SYN和FIN的逻辑。</p><p><del>如果已经发送了SYN但是没有被ACK，那么是不应该发送其他数据的——毕竟连接尚未建立。什么时候更新状态？在<code>ack_received</code>里面进行判断。</del></p><p>这里没有关系的，因为装配好的seg已经放入了_outstanding_segs，确保会被重传。</p><h5 id="debug记录"><a href="#debug记录" class="headerlink" title="debug记录"></a>debug记录</h5><p><code>send_tmtx</code>失败。提示：</p><blockquote><p>Test Failure on expectation:<br>        Expectation: segment sent with (A=0,R=0,S=1,F=0,seqno=496550203,payload_size=0,…)</p><p>Failure message:<br>        The Sender should have produced a segment that existed, but it did not</p></blockquote><p>测试源码如下：</p><p><img src="https://i.loli.net/2021/03/10/hWICFAmzGwptkq1.png" srcset="/img/loading.gif" alt="image-20210310152456694" style="zoom:67%;" /></p><p>即其调用了两次<code>tick</code>，第一次刚好比<code>rt_timeout</code>小1，第二次又增加了1，因此第二次调用之后应该重传。但是本来的实现逻辑中，重传必须：<code>_ms_accumulated &gt; _current_retransmission</code>。改成大于等于即可。</p><p><strong>sender的窗口如何调整？</strong></p><p><code>send_extra</code>失败。在test<code>Don&#39;t add FIN if this would make the segment exceed the receiver&#39;s window</code>处发生错误。经过检查确认了sender窗口的调整是有问题的。本来我们直接使用每次接收到的<code>window_size</code>去更新<code>_sender_window_size</code>。显然这是不正确的。</p><p>我们必须明确<code>_sender_window_size</code>的含义是：从<code>_next_seqno</code>开始，在abs seqno表示的stream中，接收端会接收的bytes的abs seqno的范围。那么在receiver处，其希望接收的范围是[ackno, ackno + window_size)。对比一下，显然是[_next_seqno, ackno + window_size)。所以<code>_sender_window_size = ackno + window_size - _next_seqno</code>。（ackno如果比 _next_seqno大那么直接舍弃）</p><p><strong>为什么receiver 返回window_size = 0时应该将window_size视为1？</strong></p><p><img src="https://i.loli.net/2021/03/11/erLhKXyD6cFIosA.png" srcset="/img/loading.gif" alt="image-20210311132440348"></p><p>考虑这样一种情况：unassembled_bytes = 0，ByteStream.size() == _capacity。那么此时返回的窗口大小为0。但是一旦ByteStream被读走了字节，那么窗口大小会调整。如果sender发送了一个字节，那么receiver会返回新的window_size。</p>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
      <category>CS144</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
      <tag>CS144</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CS144-03-Lab2</title>
    <link href="/2021/03/03/CS144-03-Lab2/"/>
    <url>/2021/03/03/CS144-03-Lab2/</url>
    
    <content type="html"><![CDATA[<hr><p>读完《TCP/IP详解 卷一：协议》CH12之后对于指导书中的图有了大致的理解，包括TCP头部各个字段的含义。</p><p>TCP接收方需要告诉发送方两方面的信息：</p><ul><li><p>接收方期待的下一个字节在stream中的序号。回想Lab1，我们有first_unread/first_unassembled/first_unacceptable。其中<code>[first_unread, first_unassembled)</code>即为已经组装好的segments，接收方希望下一个字节是first_unassembled对应的字节，接收方已经接收了此前的字节。这里的first_unassembled即为<strong>ackno——acknowledgment number</strong>。</p></li><li><p><code>[first_unassembled, first_unacceptable)</code>即为<strong>滑动窗口</strong>——此时接收方希望接收的字节的序列号的范围。</p></li></ul><h4 id="Translating-between-64-bit-indexes-and-32-bit-seqnos"><a href="#Translating-between-64-bit-indexes-and-32-bit-seqnos" class="headerlink" title="Translating between 64-bit indexes and 32-bit seqnos"></a>Translating between 64-bit indexes and 32-bit seqnos</h4><p>我们有三种序列：</p><ul><li>在TCP传输中标志每个字节的序列号，从ISN开始，32位</li><li>absolute seqno 将上者变为从0开始</li><li>stream中每个字节的序列号，即真正传输的数据的序列号</li></ul><p><img src="https://i.loli.net/2021/03/04/d3xwi5Pqo87GaAE.png" srcset="/img/loading.gif" alt="image-20210304175138487" style="zoom: 67%;" /></p><p>我们首先需要完成<code>WrappingInt32</code>类——对uint32_t进行封装，从而使其与uint64_t转换更加方便。</p><h5 id="wrap"><a href="#wrap" class="headerlink" title="wrap"></a><code>wrap</code></h5><p>很显然，我们取出<code>uint64_t n</code>的低32位，然后与<code>ISN</code>相加即可。</p><div class="hljs"><pre><code class="hljs c++"><span class="hljs-function">WrappingInt32 <span class="hljs-title">wrap</span><span class="hljs-params">(<span class="hljs-keyword">uint64_t</span> n, WrappingInt32 isn)</span> </span>&#123;   <span class="hljs-keyword">return</span> WrappingInt32(<span class="hljs-keyword">uint32_t</span>(n &amp; <span class="hljs-number">0x00000000FFFFFFFF</span>) + isn.raw_value());&#125;</code></pre></div><h5 id="unwrap"><a href="#unwrap" class="headerlink" title="unwrap"></a><code>unwrap</code></h5><p>从seqence number 向absolute sequence number转换：</p><ul><li><p>很显然这种转换不是唯一的——seqno每次增加$2^{32}$值都不变，但是absolute seqno变化。为了确定唯一的结果，我们需要<code>checkpoint</code>，即将可能的结果中距离<code>checkpoint</code>最近的作为最终结果。</p></li><li><p><del>我们知道这里<code>checkpoint</code>实际上是last reassembled bytes，那么新来的segment对应的seqno转换成absolute seqno之后应当大于<code>checkpoint</code>。</del>我们知道这里<code>checkpoint</code>实际上是last reassembled bytes，那么新来的segment对应的seqno转换成absolute seqno之后应当大于<code>checkpoint</code>。所以如果我们知道<code>checkpoint</code>最少增加多少就变成答案即可。答案记作<code>ans</code>，那么如果我们将<code>checkpoint</code>转换成32位的seqno，记作<code>cp_seqno</code>，那么实际上从<code>cp_seqno</code>走到<code>n</code>与<code>checkpoint</code>走到<code>ans</code>距离应该是一样的。</p><p><del>如何得到这个距离？如果<code>n - cp_seqno &gt;= 0</code>，那么是正常的；如果<code>n - cp_seqno &lt; 0</code>，那么说明其实是从<code>cp_seqno</code>继续增长、溢出$2^{32}-1$从0开始，所以我们需要将<code>n</code>加上$2^{32}$。</del></p><p>写完发现报错了。马上想到，新来的segment的seqno在整个stream中未必是在<code>checkpoint</code>之后，也有可能在之前——会导致被抛弃，这是合理的。所以有可能比<code>checkpoint</code>小。</p><div class="hljs"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">uint64_t</span> <span class="hljs-title">unwrap</span><span class="hljs-params">(WrappingInt32 n, WrappingInt32 isn, <span class="hljs-keyword">uint64_t</span> checkpoint)</span> </span>&#123;  <span class="hljs-keyword">int32_t</span> tmp = n - wrap(checkpoint, isn);  <span class="hljs-keyword">int64_t</span> ans = checkpoint + tmp;  <span class="hljs-keyword">return</span> ans &gt;= <span class="hljs-number">0</span> ? ans : ans + (<span class="hljs-number">1u</span>l &lt;&lt; <span class="hljs-number">32</span>);&#125;</code></pre></div></li></ul><h4 id="Implementing-the-TCP-receiver"><a href="#Implementing-the-TCP-receiver" class="headerlink" title="Implementing the TCP receiver"></a>Implementing the TCP receiver</h4><h5 id="关于TCP"><a href="#关于TCP" class="headerlink" title="关于TCP"></a>关于TCP</h5><p>首先有一个问题，为什么SYN 也需要一个序列号？序列号存在的意义有两方面：</p><ul><li>为了重组segment。只有标示了segment的data在整个stream中的index，我们才能将乱序的data再重组成完成的stream，才能实现一种可靠的流模式</li><li>为了可靠性——连接中任意一方发送的数据能够被对方通过ack确认，否则需要重传。那么显然发送SYN的一方也需要知道自己的SYN是否被接收了，怎么办？给SYN一个sequence number，如果有ack = sequence number + 1，那么便OK了。自然这里的sequence number就是ISN。</li></ul><p>TCP连接建立的根本目的是交换双方的ISN，这是可靠性的基础。</p><h5 id="Enable-C-17-support-in-VSCode-C-C-extension"><a href="#Enable-C-17-support-in-VSCode-C-C-extension" class="headerlink" title="Enable C++17 support in VSCode C/C++ extension"></a>Enable C++17 support in VSCode C/C++ extension</h5><p>起因是<code>tcp_receiver.hh/cc</code>中，关于<code>std::optional&lt;WrappingInt32&gt; ackno() const</code>报错：</p><blockquote><p>不允许使用限定名</p></blockquote><p>有点奇怪，之前没遇到过。查了一下<code>optional</code>发现这是C++17才有的，而且代码本身应该是没问题的，那应该是vscode c++扩展没有支持C++17。找到设置里面，搜索<code>cppstandard</code>，然后改成<code>c++ 17</code>即可。</p><h5 id="整体结构"><a href="#整体结构" class="headerlink" title="整体结构"></a>整体结构</h5><p>我们需要完成三个函数，主要的是<code>segment_received</code>。回忆我们的<code>stream_reassembler</code>，其中<code>push_substring</code>需要<code>string data/ size_t index/ bool eof</code>三个参数。而<code>segment</code>包括：<code>TCP header / data</code>。因此在接收到<code>segment</code>之后我们需要得到这些信息、然后调用<code>push_substring</code>函数。</p><p>那么现在逐渐变得清晰：</p><ul><li><p>得到<code>segment</code>的<code>SYN</code>字段，从而判断是否需要设置</p><ul><li>所以我们需要知道sponge 库里面TCP segment 提供的方法</li><li>另外，考虑到后续还需要用到<code>ISN</code>，所以有必要设置一个私有成员存储<code>ISN</code></li></ul></li><li><p>得到<code>FIN</code>字段，从而去结束<code>stream_reassembler</code></p></li><li><p>注意<code>push_substring</code>中<code>index</code>为<code>size_t</code>，我们需要将<code>int32_t</code>的sequence number转化成<code>int64_t</code>。这就需要调用<code>WrappingInt32</code>，并且我们需要知道<code>checkpoint</code>。提示：</p><blockquote><p>In your TCP implementation, you’ll use the index of the last reassembled byte as the checkpoint.</p></blockquote><p>这样也就是窗口左边的index——<code>_first_unreassembled</code>左边。</p></li><li><p>如何得到<code>data</code>？<code>tcp_segment</code>提供了接口：</p><div class="hljs"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">const</span> Buffer &amp;<span class="hljs-title">payload</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123; <span class="hljs-keyword">return</span> _payload; &#125;<span class="hljs-function">Buffer &amp;<span class="hljs-title">payload</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> _payload; &#125;</code></pre></div></li></ul><p>另外关于<code>optional</code>的使用，参考：</p><blockquote><p><a href="https://en.cppreference.com/w/cpp/utility/optional" target="_blank" rel="noopener">https://en.cppreference.com/w/cpp/utility/optional</a></p></blockquote><h5 id="segment-received的思路与细节"><a href="#segment-received的思路与细节" class="headerlink" title="segment_received的思路与细节"></a><code>segment_received</code>的思路与细节</h5><p>原本的思路过于简陋，存在很多bug。后续通过test修补了很多。</p><p><strong>debug：</strong></p><p>在<code>FIN = true</code>时，我们以为直接<code>push_substring</code>，由于<code>EOF = true</code>会使得重组器的<code>ByteTream _output</code>结束输入。但是事实上并没有——<code>_output</code>的输入结束必须是不存在unreassembled_segs。</p><p>回顾实验一中<code>push_substring</code>的定义：</p><blockquote><p><code>eof</code>: the last byte of this substring will be the last byte in the entire stream</p></blockquote><p>也就是说，<code>eof = true</code>仅仅说明当前的substring是最后的字符串。这是很符合实际的，由于网络延迟的存在，后续到来的substring可能是在该substring之前，我们当然应该将其reassembled而不是拒绝输入。</p><p>在<code>reassembled_bytes</code>中，我们的逻辑是这样的：</p><div class="hljs"><pre><code class="hljs c++"><span class="hljs-keyword">if</span>(eof)_eof = <span class="hljs-literal">true</span>;<span class="hljs-keyword">if</span>(_eof &amp;&amp; empty())_output.end_input();</code></pre></div><p>现在，我们在<code>FIN</code>之后到来的segment<strong>应该能够</strong>让<code>_output</code>结束输入。上面的逻辑是可以处理的。</p><p>排查发现<code>segment_received</code>里面多了第一行：</p><div class="hljs"><pre><code class="hljs c++"><span class="hljs-keyword">if</span>(_has_fin)<span class="hljs-keyword">return</span>;</code></pre></div><p>显然，并不能这样处理。删除之后即可。</p><h5 id="ackno-实现"><a href="#ackno-实现" class="headerlink" title="ackno()实现"></a><code>ackno()</code>实现</h5><blockquote><p>Returns anoptional<WrappingInt32>containing the sequence number of the first byte that the receiver doesn’t already know.  This is the windows’s left edge:  the first byte the receiveris interested in receiving.  If the ISN hasn’t been set yet, return an empty optional.</p></blockquote><p>初始版本：</p><div class="hljs"><pre><code class="hljs c++"><span class="hljs-function">optional&lt;WrappingInt32&gt; <span class="hljs-title">TCPReceiver::ackno</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;    <span class="hljs-keyword">if</span>(_has_syn)&#123;        <span class="hljs-keyword">size_t</span> tmp = <span class="hljs-number">1</span>;        <span class="hljs-comment">//firstly get the absolute sequence number </span>            <span class="hljs-comment">//normally just add 1 but if fin add 2 </span>        <span class="hljs-comment">//then using wrap -- translating the asn to sq</span>        <span class="hljs-keyword">if</span>(_has_fin &amp;&amp; _reassembler.unassembled_bytes() == <span class="hljs-number">0</span>)tmp = <span class="hljs-number">2</span>;        <span class="hljs-keyword">return</span> wrap(_reassembler.stream_out().bytes_written() + tmp, _ISN_peer);    &#125;    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-built_in">std</span>::nullopt;&#125;</code></pre></div><p>注释：</p><p>因为我们需要返回的是absolute seqno，因此是在stream index基础上增加一。而且需要考虑，如果<code>FIN</code>已经到达并且没有unassembled bytes，那么我们需要对<code>FIN</code>进行确认。当然，如果还存在unassembled bytes，那么ackno并不需要特别处理。</p><p><strong>报错：</strong></p><blockquote><p>Failure message:<br>        The TCPReceiver reported ackno <code>6</code>, but it was expected to be <code>7</code></p><p>List of steps that executed successfully:<br>        Initialized with (capacity=4000)<br>        Action:      segment arrives Header(flags=SF,seqno=5,ack=0,win=0)<br>        Expectation: in state <code>input to stream has ended</code></p></blockquote><p>test case如下：</p><p><img src="https://i.loli.net/2021/03/09/Cy3UPoYOX1i5eSu.png" srcset="/img/loading.gif" alt="image-20210309105109752"></p><p>结合<code>segment_received</code>代码可以确定，由于没有设置<code>_has_fin = true</code>导致<code>ackno</code>错误。</p><p><strong>报错：</strong></p><blockquote><p>Failure message:<br>        The TCPReceiver reported ackno <code>3836842352</code>, but it was expected to be <code>3836842365</code></p><p>List of steps that executed successfully:<br>        Initialized with (capacity=4000)<br>        Expectation: in state <code>waiting for SYN: ackno is empty</code><br>        Action:      segment arrives Header(flags=S,seqno=3836842351,ack=0,win=0) with data “Hello, CS144!”<br>        Expectation: in state <code>SYN received (ackno exists), and input to stream hasn&#39;t ended</code></p></blockquote><p>返回的<code>ackno</code>错误。可能的原因包括：</p><ul><li><code>bytes_written</code>错误，导致返回了错误的结果</li><li><code>segment_received</code>错误，即插入时设置的index错误，或者其他逻辑错误，导致<code>bytes_written</code>错误</li><li><code>wrap</code>用法错误</li></ul><p>通过在<code>ackno</code>函数中打印<code>bytes_written</code>得知其错误，输出值一直是0。</p><p>通过对比special case：SYN with data 和<code>segment_receive</code>，可以确认逻辑错误：此时得到的<code>abs_seqno</code>错误。增加对包含数据时SYN的特判即可。</p>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
      <category>CS144</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
      <tag>CS144</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CS144-02-Lab1</title>
    <link href="/2021/02/06/CS144-02-Lab1/"/>
    <url>/2021/02/06/CS144-02-Lab1/</url>
    
    <content type="html"><![CDATA[<hr><p>这次实验我们需要完成一个子串重组的类。因为我们的数据包被TCP Sender分割成很多的segments。我们需要在receiver处将其重组成完整的byte-stream。</p><p>首先，我们需要考虑大体上数据结构以及算法：</p><ul><li>substring到来随机，我们需要将其插入合适的位置。因此需要插入性能较好的结构。考虑到可能与前后的子串重合，因此需要方便地得到前后子串。</li><li>考虑到插入，那么树形结构比较合适。我们知道每个substring的index，因此可以据此进行排序。</li><li>考虑使用set。我们需要构建一个structure并且自定义如何比较以及排序方式。set支持双向迭代器，因此插入之后可以得到前后的元素进行操作。</li></ul><p>其次，如何去重？这里我们不需要考虑什么字符串匹配算法，因为我们知道index信息，根据前面元素的index以及长度结合当前元素的index就可以知道是否重合及其相应的处理方式。</p><p>另外，对于capacity的理解：</p><ul><li><p>我们有一个byte-stream——<code>_output</code>用于存储接收到并且组装好的segments。另外还有部分容量用于存储不与<code>_output</code>连续的子串。一旦连续自然也需要写入<code>_output</code></p></li><li><p>指导书上面的示意图：</p><p><img src="https://i.loli.net/2021/03/02/YLDScgfaBIdWiAw.png" srcset="/img/loading.gif" alt="image-20210302194203433"></p></li></ul><p>我们考虑一下index各种可能的情况：</p><ul><li>处于first unacceptable之后 那么直接丢弃</li><li>处于first unread之前 有可能其延申一直到first unassembled之后 仍然需要处理</li><li>处于first unread和first unassembled之间 同上 需要处理</li><li>处于first unassembled和first unacceptable之间 自然需要处理</li></ul><p>其中2/3两种情况本质是一样的，因为绿色部分已经完成，所以我们只需要截取first unassembled及其之后的部分即可。 继续这样的思路，我们应该先进行预处理、得到红色部分需要插入的substring再进行插入。当然，超出first unacceptable之后的就直接截断。</p><p>如何实现？</p><ul><li>我们必须记录<code>first_unread--_first_unread</code>。根据<code>_output.buffer_size()</code>便可以得到<code>first_unassembled</code>。</li></ul><p>现在，我们已经得到的需要插入的结构体了。</p><p>我们首先需要找到插入的位置——<code>lower_bound</code>返回第一个大于等于index的元素，之后不断尝试合并即可——这里我们考虑构建一个函数用于合并两个结构体。而且并不仅仅考虑后面的元素，<code>lower_bound</code>返回结果之前的可能也会产生重叠，需要判断。</p><p>更具体来说，如何设计这个函数？有很多种可能的方式：</p><ul><li>传入<code>set&lt;node&gt;::iterator</code>，根据迭代器得到元素进而进行比较，如果重叠那么修改待插入的结构体，删除<code>iterator</code>指向的结构体；<ul><li>我们是在函数内部删除还是在调用处删除？</li><li><a href="https://stackoverflow.com/questions/9726375/stdset-iterator-automatically-const" target="_blank" rel="noopener">https://stackoverflow.com/questions/9726375/stdset-iterator-automatically-const</a></li></ul></li><li>我们首先插入，然后直接修改<code>set&lt;node&gt;</code>。这样有一个弊端就是，我们并不能直接插入，因为可能存在相同的<code>index</code>——我们需要额外处理，但是如果只是处理这个相同<code>index</code>的元素那么在插入之后仍然需要与后续元素进行比较、处理，代码比较冗余；</li><li>注意如果能够合并，那么显然会影响<code>_unassembled_bytes</code>，如何实现？直接在内部修改还是传回返回值然后修改？</li></ul><p>其实除了上述的<code>set</code>方法之外，可能直接使用一个<code>string</code>也是可以的。我们可能需要一个<code>vector&lt;bool&gt;</code>进行标记<code>string</code>每一位是否是由<code>substring</code>占据。这样的好处是我们不需要比较繁琐的判断重叠、合并的操作，我们直接去填充<code>string</code>然后将标记为置为<code>true</code>即可。当然一开始为了保险起见用了<code>set</code>，写的过程当中就觉得<code>string</code>应该方便很多。</p><p>现在我们已经完成了讲个基本的数据结构——<code>byte_stream</code>和<code>stream_assembler</code>。</p><blockquote><p>目前尚未真正涉及TCP协议本身的内容，感觉像是完成了两道CSP模拟题。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
      <category>CS144</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
      <tag>CS144</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CS144-01-Lab0</title>
    <link href="/2021/01/30/CS144-01-Lab0/"/>
    <url>/2021/01/30/CS144-01-Lab0/</url>
    
    <content type="html"><![CDATA[<h4 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h4><h5 id="VSCode-Remote-Development"><a href="#VSCode-Remote-Development" class="headerlink" title="VSCode Remote Development"></a>VSCode Remote Development</h5><ul><li><p>随便搜了一些教程，按步骤操作即可。</p><p><img src="C:\Users\28425\AppData\Roaming\Typora\typora-user-images\image-20210131143446968.png" srcset="/img/loading.gif" alt="image-20210131143446968" style="zoom: 50%;" /></p></li><li><p>中间自动推荐了C++相关插件，安装即可。</p></li></ul><h5 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h5><ul><li><p>安装</p><div class="hljs"><pre><code class="hljs html">git config --global user.name "xxx" // user.email "xxx"</code></pre></div></li><li><p>关联远程仓库并推送</p><div class="hljs"><pre><code class="hljs xml">git remote -v可以看到已经存在的仓库 因为是从CS144的官方clone下来的git remote add qscs144 URL git add .git commit -mgit push qscs144 master</code></pre></div></li><li><p>配置SSH相关。注意ubuntu启动ssh agent: <code>exec ssh-agent bash</code></p></li></ul><h4 id="正式实验"><a href="#正式实验" class="headerlink" title="正式实验"></a>正式实验</h4><h5 id="webget-cc"><a href="#webget-cc" class="headerlink" title="webget.cc"></a>webget.cc</h5><p>我们的目标是实现<code>void get_URL(const string &amp;host, const string &amp;path)</code>函数。</p><p>具体来说：</p><ul><li><p>理解基本的socket编程</p></li><li><p>阅读sponge库 知道对应的接口</p></li></ul><div class="hljs"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">get_URL</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span> &amp;host, <span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span> &amp;path)</span> </span>&#123;    TCPSocket soct;    soct.<span class="hljs-built_in">connect</span>(Address(host, <span class="hljs-string">"http"</span>));    <span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span> httpDatagram = <span class="hljs-string">"GET "</span> + path + <span class="hljs-string">" HTTP/1.1\r\n"</span> +                                 <span class="hljs-string">"Host: "</span> + host + <span class="hljs-string">"\r\n\r\n"</span>;    soct.<span class="hljs-built_in">write</span>(httpDatagram);    soct.<span class="hljs-built_in">shutdown</span>(SHUT_WR);    <span class="hljs-keyword">while</span>(!soct.eof())        <span class="hljs-built_in">cout</span>&lt;&lt;soct.<span class="hljs-built_in">read</span>();    soct.<span class="hljs-built_in">close</span>();    <span class="hljs-keyword">return</span>;&#125;</code></pre></div><p><img src="https://i.loli.net/2021/02/01/jRvxaIM3UEVYmbc.png" srcset="/img/loading.gif" alt="image-20210201182035652" style="zoom:67%;" /></p><p><img src="https://i.loli.net/2021/02/01/ihq8ZB2t4op5dcu.png" srcset="/img/loading.gif" alt="image-20210201182059748" style="zoom:67%;" /></p><h5 id="an-in-memory-reliable-byte-stream"><a href="#an-in-memory-reliable-byte-stream" class="headerlink" title="an in-memory reliable byte stream"></a>an in-memory reliable byte stream</h5><p>在上面的实验中我们可以看到socket提供给用户的感觉就是能够将字节可靠地通过网络在主机之间进行交互。这里我们需要实现一个单线程的、位于内存的byte stream。</p><p>要求：</p><ul><li>有序 FIFO</li><li>初始化时固定容量</li><li>控制输入操作</li></ul><p>如何实现？思路：</p><ul><li>最初根据FIFO第一反应是直接使用<code>queue</code>。但是我们<code>read/write</code>的对象都是<code>string</code>，而且有时需要根据字节长度去读取，因此使用<code>queue</code>比较麻烦——需要不断地去遍历得到指定长度的<code>string</code></li><li>直接使用一个<code>string</code>对象？所有的操作直接在这个对象上进行。感觉比较方便。</li></ul><blockquote><p><code>string</code>与字符、字节之间的关系</p></blockquote><p>具体代码比较简单。</p><h4 id="关于构建"><a href="#关于构建" class="headerlink" title="关于构建"></a>关于构建</h4><ul><li><p>注意，这里我们必须列表初始化成员：</p><blockquote><p>‘ByteStream::_BStream’ should be initialized in the member initialization list [-Werror=effc++]</p></blockquote></li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
      <category>CS144</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
      <tag>CS144</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MIT6.828-02-Lab1</title>
    <link href="/2021/01/27/MIT6-828-02-Lab1/"/>
    <url>/2021/01/27/MIT6-828-02-Lab1/</url>
    
    <content type="html"><![CDATA[<h4 id="Part1-PC-Bootstrap"><a href="#Part1-PC-Bootstrap" class="headerlink" title="Part1: PC Bootstrap"></a>Part1: PC Bootstrap</h4><h5 id="熟悉x86汇编"><a href="#熟悉x86汇编" class="headerlink" title="熟悉x86汇编"></a>熟悉x86汇编</h5><ul><li><p><a href="https://www.ibm.com/developerworks/cn/linux/l-assembly/" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/linux/l-assembly/</a> 介绍了Linux环境下基本的AT&amp;T风格的汇编</p><p>在编写<code>hello.s</code>之后<code>as -o hello.o hello.s</code>提示：</p><blockquote><p>hello.s: Assembler messages:<br>hello.s: Warning: end of file not at end of a line; newline inserted</p></blockquote><p>在<code>hello.s</code>末尾添加新行即可。<strong>WHY</strong></p><p>另外介绍了inline assembly的基本用法，有点好玩，GCC的支持使得我们可以直接在C语言中直接写汇编。</p></li><li><p><a href="https://pdos.csail.mit.edu/6.828/2018/readings/i386/toc.htm" target="_blank" rel="noopener">80386 Programmer’s Reference Manual</a> 包括从基本的计算机组成到x86 assembly，1.2介绍了历史发展，可以与操作系统的知识结合在一起：从段式分配到页式分配。另外appendix里面包括了80x86 instructions，比较方便。</p></li></ul><h5 id="启动过程"><a href="#启动过程" class="headerlink" title="启动过程"></a>启动过程</h5><ul><li><p><strong>Exercise 2</strong>： Use GDB’s si (Step Instruction) command to trace into the ROM BIOS for a few more instructions, and try to guess what it might be doing.</p><p>首先我们想知道电脑启动的整体过程。<a href="https://medium.com/an-idea/the-not-so-magic-of-how-your-computer-boots-up-2f5e8289451d" target="_blank" rel="noopener">这篇文章介绍了大致过程</a> </p><p>其次使用<code>si</code>去看具体执行了那些命令。</p></li></ul><h4 id="Part2-The-Boot-Loader"><a href="#Part2-The-Boot-Loader" class="headerlink" title="Part2: The Boot Loader"></a>Part2: The Boot Loader</h4><ul><li><p><img src="https://i.loli.net/2021/01/30/vEmgqHpltSQM5CA.png" srcset="/img/loading.gif" alt="image-20210130160415527"></p><p>上图中，左边是使用GDB单步执行的过程，右边是boot.S。</p></li></ul><h5 id="理解boot-loader-source-code"><a href="#理解boot-loader-source-code" class="headerlink" title="理解boot loader source code"></a>理解boot loader source code</h5>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
      <category>MIT6.828</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
      <tag>MIT6.828</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MIT6.828-01-环境配置与工具使用</title>
    <link href="/2021/01/27/MIT6.828-01-%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    <url>/2021/01/27/MIT6.828-01-%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h4 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h4><blockquote><p>Ubuntu 18.04</p></blockquote><p>这门课实验的最终目标是实现一个微内核操作系统JOS，它是在xv6的基础上改写的。xv6是运行在x86架构上的用于教学的类UNIX操作系统。因此，一方面我们需要利用QEMU来运行xv6，另一方面需要编译工具链来对内核进行编译。官方给的指导：<a href="https://pdos.csail.mit.edu/6.828/2018/tools.html" target="_blank" rel="noopener">https://pdos.csail.mit.edu/6.828/2018/tools.html</a></p><p>事实上这中间可能会遇到一些问题，例如：</p><p><code>make &amp;&amp; make install</code>之后报错：</p><div class="hljs"><pre><code class="hljs html">qga/commands-posix.c: In function ‘dev_major_minor’:qga/commands-posix.c:633:13: error: In the GNU C Library, "major" is defined by <span class="hljs-tag">&lt;<span class="hljs-name">sys</span>/<span class="hljs-attr">sysmacros.h</span>&gt;</span>. For historical compatibility, it is currently defined by <span class="hljs-tag">&lt;<span class="hljs-name">sys</span>/<span class="hljs-attr">types.h</span>&gt;</span> as well, but we plan to remove this soon. To use "major", include <span class="hljs-tag">&lt;<span class="hljs-name">sys</span>/<span class="hljs-attr">sysmacros.h</span>&gt;</span> directly. If you did not intend to use a system-defined macro "major", you should undefine it after including <span class="hljs-tag">&lt;<span class="hljs-name">sys</span>/<span class="hljs-attr">types.h</span>&gt;</span>. [-Werror]         *devmajor = major(st.st_rdev);             ^~~~~~~~~~~~~~~~~~~~~~~~~~  qga/commands-posix.c:634:13: error: In the GNU C Library, "minor" is defined by <span class="hljs-tag">&lt;<span class="hljs-name">sys</span>/<span class="hljs-attr">sysmacros.h</span>&gt;</span>. For historical compatibility, it is currently defined by <span class="hljs-tag">&lt;<span class="hljs-name">sys</span>/<span class="hljs-attr">types.h</span>&gt;</span> as well, but we plan to remove this soon. To use "minor", include <span class="hljs-tag">&lt;<span class="hljs-name">sys</span>/<span class="hljs-attr">sysmacros.h</span>&gt;</span> directly. If you did not intend to use a system-defined macro "minor", you should undefine it after including <span class="hljs-tag">&lt;<span class="hljs-name">sys</span>/<span class="hljs-attr">types.h</span>&gt;</span>. [-Werror]         *devminor = minor(st.st_rdev);             ^~~~~~~~~~~~~~~~~~~~~~~~~~</code></pre></div><p>好在一般前人都踩过坑，Google一下直接照葫芦画瓢即可。</p><p>注：官方QEMU安装教程里面给出的提示，看到网上一些教程貌似没有注意到这里踩了挺多坑。</p><blockquote><p>On Linux, you may need to install several libraries. We have successfully built 6.828 QEMU on Debian/Ubuntu 16.04 after installing the following packages: libsdl1.2-dev, libtool-bin, libglib2.0-dev, libz-dev, and libpixman-1-dev</p></blockquote><h4 id="工具使用"><a href="#工具使用" class="headerlink" title="工具使用"></a>工具使用</h4><h5 id="QEMU"><a href="#QEMU" class="headerlink" title="QEMU"></a>QEMU</h5><ul><li>之前做CS:APP MIPS版本的bomb lab时使用过。主要是模拟硬件，这门课程中模拟了一个32位x86平台。</li></ul><h5 id="GDB"><a href="#GDB" class="headerlink" title="GDB"></a>GDB</h5><ul><li>用得不多，没有系统学过。</li></ul>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
      <category>MIT6.828</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
      <tag>6.828</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
