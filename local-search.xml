<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>静态链接</title>
    <link href="/2020/09/26/%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5/"/>
    <url>/2020/09/26/%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5/</url>
    
    <content type="html"><![CDATA[<h4 id="编译和链接"><a href="#编译和链接" class="headerlink" title="编译和链接"></a>编译和链接</h4><h5 id="可执行文件"><a href="#可执行文件" class="headerlink" title="可执行文件"></a>可执行文件</h5><p>在计算机组成原理当中我们知道，机器指令是如何执行的：根据PC寄存器当中内存地址的值取出机器指令，然后对其进行分析，得到操作码，继而知道这是一条什么样的指令。比如如果是将两个操作数相加，那么根据给定的寻址方式找到两个操作数送入ALU进行加法。（这里只是粗略地描述大致的过程，具体物理内存和虚拟内存的映射并不需要考虑——抽象）如果是一条跳转指令，那么需要在指令中写明目标地址，从而可以把这个地址给PC转而去执行。</p><p>那么与我们写程序时调用一些库对应起来：我们可能使用了一个库的函数。这里需要注意的是预编译过程我们会对头文件进行处理：主要是处理那些<code>#</code>开头的预编译指令，包括条件编译指令、<code>#include</code>等等。因为头文件中并没有具体函数的实现，所以一直持续到目标文件，具体函数的地址我们是未知的，所以我们才需要进行链接：将需要用到的函数对应的目标文件和我们编译-汇编得到的目标文件进行链接，从而可以确定函数的地址，从而最终变成可执行文件。在执行时跳转到指定的函数地址去执行。</p><h5 id="可执行文件是如何执行的"><a href="#可执行文件是如何执行的" class="headerlink" title="可执行文件是如何执行的"></a>可执行文件是如何执行的</h5>]]></content>
    
    
    <categories>
      
      <category>读书笔记</category>
      
      <category>程序员的修养——链接、装载与库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>读书 笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SDU2020图形学笔记</title>
    <link href="/2020/09/25/SDU2020%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%AC%94%E8%AE%B0/"/>
    <url>/2020/09/25/SDU2020%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h3 id="光栅图形学"><a href="#光栅图形学" class="headerlink" title="光栅图形学"></a>光栅图形学</h3><blockquote><p>整体思路是连续到离散</p></blockquote><h4 id="多边形的扫描转换与区域填充"><a href="#多边形的扫描转换与区域填充" class="headerlink" title="多边形的扫描转换与区域填充"></a>多边形的扫描转换与区域填充</h4><h5 id="扫描线算法AET-NET的设计思路"><a href="#扫描线算法AET-NET的设计思路" class="headerlink" title="扫描线算法AET/NET的设计思路"></a>扫描线算法AET/NET的设计思路</h5><p>首先明确我们的<strong>目标</strong>：</p><ul><li>确定扫描线与多边形各边是否有交点</li><li>如果有交点，那么求出交点坐标</li></ul><p>注意扫描的纵坐标我们是知道的—扫描线从$Y<em>{\min}$迭代到$Y</em>{\max}$，并且步长为1。因此自然的想法便是对于一条边，我们得到其纵坐标的极值，如果有：</p><script type="math/tex; mode=display">Y_{\min}^{i}\leq S^{i}\leq Y_{\max}^{i}</script><p>那么自然两者有交点。如果扫描线小于某边的$Y<em>{\min}^i$或者大于那$Y</em>{\max}^i$么自然不会有交点。所以一个自然的想法在于根据每条边的进$Y<em>{\min}^i$行“分类”——更具体点说，**对于每条边，将其归属于$Y</em>{\min}^i$对应的扫描线，从而这些边必定与其归属的扫描线相交。**</p><p>那么如何处理$Y_{\max}^i$？</p><p>考虑每条扫描线，我们用链表记录与其相交的边。那么当扫描线i 往上扫描时，我们至少需要增加Y<sub>min</sub> = i + 1的那些边。除此之外，对于与扫描线i 相交的那些边，如果其$Y_{\max}^i\geq S^i$ ，那么显然两者应该相交。</p><p>所以我们边链表的结点至少应该记录每条边的$Y<em>{\max}^i$，并且初始时所具有的边为$Y</em>{\max}^i= S^i$ （注意这里的边链表“属于”某条扫描线）</p><p>那么我们已经达到了第一个目标：</p><div class="hljs"><pre><code class="hljs pf">首先初始化接着进行迭代更新：   如果Y<span class="hljs-keyword">max</span>值大于等于Si，那么保留</code></pre></div><p>所以我们如何计算交点坐标？</p><p>注意这部分其实也包含了图形学一个重要思想：增量。即：我们希望从原本的计算结果进行修改从而得到新的结果，而非重新计算。（尽管“计算”是不可避免的）</p><p>那么考虑第一个交点：显然根据上述，$Y<em>{\min}^i$对应的扫描线与其交点应当记录其横坐标值。重要的是，如果我们知道了某边 $Y</em>{\min}^i$对应的横坐标的值，并且知道$Y$增加1对应的横坐标的增量，那么只要扫描线继续相交，我们便可以得到接下来的交点坐标。（更详细地说，类似于我们知道一条直线，如果横坐标增量为1，那么纵坐标增量为$K$—斜率。这里恰好相反，横坐标增量为$\frac{1}{K}$。当然，如果$K$为0，那么不会继续相交。）</p><p>所以对于每条边，我们除了记录$Y<em>{\max}^i$，还需要$Y</em>{\min}^i$对应的横坐标的值以及$Y$加一时其增量。这便是<strong>边链表的结点的结构-</strong>-$Y_{\min}^i$对应的横坐标延申为交点横坐标，从而满足不断迭代的变化。</p><p>这时我们第二个目标也达到了：</p><div class="hljs"><pre><code class="hljs 1c">首先初始化，得到每条扫描线所具有的边--包括交点横坐标、横坐标增量以及Ymax <span class="hljs-comment">//建立NET</span>接着进行迭代更新：   如果Ymax值大于等于Si，那么保留，并且根据横坐标增量更新交点横坐标 <span class="hljs-comment">//更新AET</span></code></pre></div>]]></content>
    
    
    <categories>
      
      <category>Computer Graphics</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图形学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SDU2020ML Lab2 Logistic Regression</title>
    <link href="/2020/09/24/SDU2020ML-Lab2-Logistic-Regression/"/>
    <url>/2020/09/24/SDU2020ML-Lab2-Logistic-Regression/</url>
    
    <content type="html"><![CDATA[<h4 id="Matlab-Octave-记录"><a href="#Matlab-Octave-记录" class="headerlink" title="Matlab/Octave 记录"></a>Matlab/Octave 记录</h4><h5 id="find函数"><a href="#find函数" class="headerlink" title="find函数"></a>find函数</h5><blockquote><p><a href="https://www.cnblogs.com/anzhiwu815/p/5907033.html" target="_blank" rel="noopener">https://www.cnblogs.com/anzhiwu815/p/5907033.html</a></p><p><a href="https://blog.csdn.net/xd15010130025/article/details/100084176" target="_blank" rel="noopener">https://blog.csdn.net/xd15010130025/article/details/100084176</a></p><p><a href="https://ww2.mathworks.cn/help/matlab/ref/find.html?s_tid=srchtitle#budqulo-2" target="_blank" rel="noopener">https://ww2.mathworks.cn/help/matlab/ref/find.html?s_tid=srchtitle#budqulo-2</a></p></blockquote><ul><li>注意<code>find(矩阵/条件，num)</code>这里的num是符合条件的目标数目。例如：<code>find(X,3)</code>即为找到前三个不为0的元素的索引；而<code>find(X==9,3)</code>即为找到X中等于9的前三个元素的索引。</li></ul><h5 id="sum函数"><a href="#sum函数" class="headerlink" title="sum函数"></a>sum函数</h5><blockquote><p><code>S = sum(A)</code> 返回 A 沿大小不等于 1 的第一个数组维度的元素之和。</p><ul><li>如果 <code>A</code> 是向量，则 <code>sum(A)</code> 返回元素之和。</li><li>如果 <code>A</code> 是矩阵，则 <code>sum(A)</code> 将返回包含每列总和的行向量。</li><li>如果 <code>A</code> 是多维数组，则 <code>sum(A)</code> 沿大小不等于 1 的第一个数组维度计算，并将这些元素视为向量。此维度会变为 <code>1</code>，而所有其他维度的大小保持不变。</li></ul></blockquote><ul><li>对于需要求和的计算，使用矩阵<code>.*</code>与<code>sum</code>配合实现比较方便。例如损失函数$L\left(\theta \right) $：<script type="math/tex; mode=display">L\left(\theta \right) = \frac{1}{m}\sum_{i=1}^m[y^{(i)}\log(h_\theta(x^{(i)})) + (1-y^{(i)})log(1 - h_\theta(x^{(i)}))]</script></li></ul>  <div class="hljs"><pre><code class="hljs matlab">z = x * theta;<span class="hljs-comment">%g为sigmoid函数</span>h = g(z);L_theta(<span class="hljs-built_in">i</span>,<span class="hljs-number">1</span>) = -(<span class="hljs-number">1</span>/m)*sum(y.*<span class="hljs-built_in">log</span>(h) + (<span class="hljs-number">1</span>-y).*<span class="hljs-built_in">log</span>(<span class="hljs-number">1</span>-h));<span class="hljs-comment">%注意y.*log(h)得到列向量，后者同理，因此相加得到列向量，sum函数得到该列的和</span><span class="hljs-comment">%使用矩阵存储L_theta目的是为了方便后续计算连续的L_theta之间的差的绝对值</span></code></pre></div><h5 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h5><h4 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h4><h5 id="BGD"><a href="#BGD" class="headerlink" title="BGD"></a>BGD</h5><p>相比Lab1当中通过嵌套循环的方式实现的BGD，这次的实现更加高效。考虑：</p><script type="math/tex; mode=display">\nabla_{\theta} L=\frac{1}{m} \sum_{i=1}^{m}\left(h_{\theta}\left(x^{(i)}\right)-y^{(i)}\right) x^{(i)}</script><p>不妨有</p><script type="math/tex; mode=display">h_{\theta}\left(x^{(i)}\right)-y^{(i)}=H_{\theta}^{(i)}</script><p>从而</p><script type="math/tex; mode=display">\nabla_{\theta}L=\frac{1}{m} \sum_{i=1}^{m}\left(h_{\theta}\left(x^{(i)}\right)-y^{(i)}\right)x^{(i)}=\frac{1}{m} \sum_{i=1}^{m}H_{\theta}^{(i)}x^{(i)}=\frac{1}{m}H_{\theta}^{T}x</script><p>具体实现：</p><div class="hljs"><pre><code class="hljs matlab">z = x * theta;H = g(z);theta = theta - alpha * (x' * (H-y)) / m;<span class="hljs-comment">%注意这里theta为列向量</span><span class="hljs-comment">% x' * (H-y) 等价于 ((H-y)' * x)'，但是显然前者代价应该小点</span></code></pre></div><h5 id="Newton’s-Method"><a href="#Newton’s-Method" class="headerlink" title="Newton’s Method"></a>Newton’s Method</h5><p>Hession Matrix的理解</p><h4 id="回答问题"><a href="#回答问题" class="headerlink" title="回答问题"></a>回答问题</h4><h5 id="BGD-1"><a href="#BGD-1" class="headerlink" title="BGD"></a>BGD</h5><ul><li><p>大约迭代了680次</p></li><li><p>$\theta_0= -0.050212 \quad \theta_1 =   1.427623 \quad \theta = 1.523630$  </p></li><li><p><img src="https://i.loli.net/2020/09/27/f9UEcDhtyzCWIli.png" srcset="/img/loading.gif" alt="image-20200927210651310" style="zoom: 67%;" /></p><div class="hljs"><pre><code class="hljs matlab"><span class="hljs-built_in">figure</span>;<span class="hljs-built_in">plot</span>(<span class="hljs-number">1</span>:num_iter<span class="hljs-number">-1</span>,ill_L_theta,<span class="hljs-string">'-'</span>);<span class="hljs-built_in">legend</span>(<span class="hljs-string">'\theta_0'</span>,<span class="hljs-string">'\theta_1'</span>,<span class="hljs-string">'\theta_2'</span>,<span class="hljs-string">'L&#123;(\theta)&#125;'</span>);xlabel(<span class="hljs-string">'iter'</span>);ylabel(<span class="hljs-string">'L&#123;(\theta)&#125;'</span>);</code></pre></div></li><li><p>作出决策边界：</p><p>注意我们在visualize原始数据的时候，根据Y值的不同使用了不同的符号去绘制，而且在二维平面上，X轴和Y轴分别对应这原始数据的第二维、第三维。因此我们目前绘制决策边界，X轴应当仍然是第二维的，与之相对应的Y轴的值则应该是使用训练出来的$\theta$得到的，并且$\theta^Tx = 0$，即：</p><script type="math/tex; mode=display">\theta_0 \times x_0 + \theta_1 \times x_1 + \theta_2 \times x_2 = 0\\</script><p>从而：</p><div class="hljs"><pre><code class="hljs matlab">x_axis = x(:,<span class="hljs-number">2</span>)*sigma(<span class="hljs-number">1</span>) + mu(<span class="hljs-number">1</span>);y_axis = (-theta(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>).*x(:,<span class="hljs-number">1</span>) - theta(<span class="hljs-number">2</span>,<span class="hljs-number">1</span>).*x(:,<span class="hljs-number">2</span>))/theta(<span class="hljs-number">3</span>,<span class="hljs-number">1</span>);y_axis = y_axis*sigma(<span class="hljs-number">2</span>) + mu(<span class="hljs-number">2</span>);<span class="hljs-built_in">plot</span>(x_axis, y_axis,<span class="hljs-string">'-'</span>);</code></pre></div><p>结果：</p><p><img src="https://i.loli.net/2020/09/27/FfSd8cnj1mAVo6x.png" srcset="/img/loading.gif" alt="image-20200927212136250" style="zoom:67%;" /></p></li><li><div class="hljs"><pre><code class="lang-matlab">pr_x = [1,20,80];pr_x(1,2) = (pr_x(1,2) - mu(1)) / sigma(1);pr_x(1,3) = (pr_x(1,3) - mu(2)) / sigma(2);pro = g(-(pr_x * theta));disp(pro)</code></pre></div><p>结果：<code>pro =0.66216</code></p></li></ul><h5 id="Netwon’s-Method"><a href="#Netwon’s-Method" class="headerlink" title="Netwon’s Method"></a>Netwon’s Method</h5><ul><li><script type="math/tex; mode=display">\theta_0 =  -0.056595 \quad \theta_1 =  1.472022 \quad \theta_3 = 1.570584</script></li><li><p>同上</p></li><li><p>同上</p></li><li><p>结果：<code>pro = 0.66802</code></p></li><li><p>梯度下降和牛顿法的比较</p><ul><li>收敛速度更快</li><li>迭代比较少的次数便可以到达最优值</li><li>但是因为需要计算Hessian矩阵，所以每次迭代代价比较大</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>Machine Learning</category>
      
      <category>SDU2020 ML记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Logistic Regression</title>
    <link href="/2020/09/15/Logistic%20Regression/"/>
    <url>/2020/09/15/Logistic%20Regression/</url>
    
    <content type="html"><![CDATA[<h5 id="如果使用Linear-Regression的方法去处理分类问题会怎样？"><a href="#如果使用Linear-Regression的方法去处理分类问题会怎样？" class="headerlink" title="如果使用Linear Regression的方法去处理分类问题会怎样？"></a>如果使用Linear Regression的方法去处理分类问题会怎样？</h5><p>考虑binary classification，那么我们获得拟合曲线之后，针对某个test data中的数据点计算y hat，那么结果如果大于0，则为class 1，否则为class 2。</p><p>注意我们这里的结果是获得了一条拟合曲线，因此其目标是尽可能的“接近”所有的数据点，但是显然这可能会是的拟合出来的曲线无法分开两个类。</p><p><img src="C:\Users\28425\AppData\Roaming\Typora\typora-user-images\image-20200915202002715.png" srcset="/img/loading.gif" alt="image-20200915202002715" style="zoom:50%;" /></p><p><img src="https://i.loli.net/2020/09/15/UGY23HfkJrwhB7O.png" srcset="/img/loading.gif" alt="image-20200915202655850" style="zoom:50%;" /></p><p>非常符合直觉：因为x要么属于C1，要么属于C2。因此我们首先获得从概率1：随便拿，拿到C1中的x的概率。之后我们需要计算总共两种可能得到x的概率：概率2。那么显然属于C1的概率是概率1除以概率2。</p><p><img src="https://i.loli.net/2020/09/15/EQ4Pqvs2LrDlSw5.png" srcset="/img/loading.gif" alt="image-20200915205752774" style="zoom:50%;" /></p><hr>]]></content>
    
    
    <categories>
      
      <category>Machine Learning</category>
      
      <category>李宏毅机器学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SDU2020图形学Lab1_Lab2</title>
    <link href="/2020/09/15/SDU2020%E5%9B%BE%E5%BD%A2%E5%AD%A6Lab1_Lab2/"/>
    <url>/2020/09/15/SDU2020%E5%9B%BE%E5%BD%A2%E5%AD%A6Lab1_Lab2/</url>
    
    <content type="html"><![CDATA[<h3 id="Lab1"><a href="#Lab1" class="headerlink" title="Lab1"></a>Lab1</h3><p>略。</p><h3 id="Lab2"><a href="#Lab2" class="headerlink" title="Lab2"></a>Lab2</h3><blockquote><p>要求：</p><ul><li><p>实现至少两种画线算法（须包括Bresenham算法）</p></li><li><p>实现画圆算法</p></li><li><p>不允许使用图形库</p></li><li><p>通过屏幕鼠标交互进行绘制（对直线和圆的控制）</p></li></ul></blockquote><h4 id="关键"><a href="#关键" class="headerlink" title="关键"></a>关键</h4><ul><li>算法实现：需要考虑到书上给出的示例一般是在斜率K在0、1之间的情况，因此这里我们需要推广到R上。具体思路其实也很多。</li><li>glut库中鼠标交互的学习</li></ul><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><h5 id="三种直线算法"><a href="#三种直线算法" class="headerlink" title="三种直线算法"></a>三种直线算法</h5><div class="hljs"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;gl/glut.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cmath&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstdlib&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;GLint m0, n0, m1, n1;<span class="hljs-keyword">bool</span> flag = <span class="hljs-number">1</span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">drawPiexl</span><span class="hljs-params">(GLint x, GLint y)</span></span><span class="hljs-function"></span>&#123;glBegin(GL_POINTS);glVertex2i(x, y);glEnd();&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Midpoint_Line</span><span class="hljs-params">(GLint x0, GLint y0, GLint x1, GLint y1)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-comment">//确保x0 较小</span>glClear(GL_COLOR_BUFFER_BIT);GLint t;<span class="hljs-keyword">if</span> (x1 &lt; x0)&#123;t = x1;x1 = x0, x0 = t;t = y1;y1 = y0, y0 = t;&#125;GLint a, b, d1, d2, d, x, y;x = x0, y = y0;a = y0 - y1, b = x1 - x0;<span class="hljs-keyword">if</span> (a == <span class="hljs-number">0</span>)&#123;<span class="hljs-comment">//平行于x轴</span><span class="hljs-keyword">while</span> (x &lt;= x1)&#123;drawPiexl(x, y);x++;&#125;<span class="hljs-keyword">return</span>;&#125;<span class="hljs-keyword">if</span> (b == <span class="hljs-number">0</span>)&#123;<span class="hljs-comment">//平行于y轴</span><span class="hljs-keyword">if</span> (y0 &gt; y1) &#123; t = y1; y1 = y0; y0 = t; &#125;y = y0;<span class="hljs-keyword">while</span> (y &lt;= y1)&#123;drawPiexl(x, y);y++;&#125;<span class="hljs-keyword">return</span>;&#125;<span class="hljs-keyword">int</span> dx = x1 - x0;<span class="hljs-keyword">int</span> dy = y1 - y0;<span class="hljs-keyword">double</span> k = <span class="hljs-keyword">double</span>(dy) / <span class="hljs-keyword">double</span>(dx);<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%f\n"</span>, k);<span class="hljs-keyword">if</span> (<span class="hljs-built_in">abs</span>(k) &lt;= <span class="hljs-number">1</span>)&#123;<span class="hljs-keyword">if</span> (k &gt; <span class="hljs-number">0</span>)&#123;<span class="hljs-comment">//一般情况</span>d1 = <span class="hljs-number">2</span> * a, d2 = <span class="hljs-number">2</span> * (a + b);d = <span class="hljs-number">2</span> * a + b;drawPiexl(x, y);<span class="hljs-keyword">while</span> (x &lt; x1)&#123;<span class="hljs-keyword">if</span> (d &lt; <span class="hljs-number">0</span>) &#123; x++, y++, d += d2; &#125;<span class="hljs-keyword">else</span> &#123; x++, d += d1; &#125;drawPiexl(x, y);&#125;&#125;<span class="hljs-keyword">else</span>&#123;d = <span class="hljs-number">2</span> * a - b;d1 = a - b, d2 = a;drawPiexl(x, y);<span class="hljs-keyword">while</span> (x &lt; x1)&#123;<span class="hljs-keyword">if</span> (d &gt; <span class="hljs-number">0</span>) &#123; x++, y--, d += d1; &#125;<span class="hljs-keyword">else</span> &#123; x++, d += d2; &#125;drawPiexl(x, y);&#125;&#125;&#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-keyword">if</span> (k &gt; <span class="hljs-number">0</span>)&#123;d = a + <span class="hljs-number">2</span> * b;d1 = b;<span class="hljs-comment">//d &lt; 0</span>d2 = a + b;<span class="hljs-comment">//d &gt; 0</span><span class="hljs-keyword">while</span> (y &lt; y1)&#123;<span class="hljs-keyword">if</span> (d &gt; <span class="hljs-number">0</span>) &#123; y++, x++, d += d2; &#125;<span class="hljs-keyword">else</span> &#123; y++, d += d1; &#125;drawPiexl(x, y);&#125;&#125;<span class="hljs-keyword">else</span>&#123;d = a - <span class="hljs-number">2</span> * b;d1 = a - b, d2 = -b;<span class="hljs-keyword">while</span> (y &gt; y1)&#123;<span class="hljs-keyword">if</span> (d &lt; <span class="hljs-number">0</span>) &#123; y--, x++, d += d1; &#125;<span class="hljs-keyword">else</span> &#123; y--, d += d2; &#125;drawPiexl(x, y);&#125;&#125;&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Bresenham_Line</span><span class="hljs-params">(GLint x0, GLint y0, GLint x1, GLint y1)</span></span><span class="hljs-function"></span>&#123;glClear(GL_COLOR_BUFFER_BIT);GLint t;<span class="hljs-keyword">if</span> (x1 &lt; x0)&#123;t = x1;x1 = x0, x0 = t;t = y1;y1 = y0, y0 = t;&#125;GLint x = x0, y = y0;<span class="hljs-keyword">if</span> (x0 == x1)&#123;<span class="hljs-comment">//平行于y轴</span><span class="hljs-keyword">if</span> (y0 &gt; y1) &#123; t = y1; y1 = y0; y0 = t; &#125;<span class="hljs-keyword">while</span> (y &lt;= y1)&#123;drawPiexl(x, y);y++;&#125;<span class="hljs-keyword">return</span>;&#125;<span class="hljs-keyword">if</span> (y0 == y1)&#123;<span class="hljs-comment">//平行于x轴</span><span class="hljs-keyword">while</span> (x &lt;= x1)&#123;drawPiexl(x, y);x++;&#125;<span class="hljs-keyword">return</span>;&#125;<span class="hljs-keyword">int</span> dx = x1-x0, dy =y1-y0;<span class="hljs-keyword">double</span> k = <span class="hljs-keyword">double</span>(dy) / <span class="hljs-keyword">double</span>(dx);GLdouble e = <span class="hljs-number">-0.5</span>;GLint i = <span class="hljs-number">0</span>;<span class="hljs-keyword">if</span> (<span class="hljs-built_in">abs</span>(k) &lt;= <span class="hljs-number">1</span>)&#123;<span class="hljs-comment">//处理k&gt;0</span><span class="hljs-keyword">if</span> (k &gt; <span class="hljs-number">0</span>)&#123;<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt;= dx; ++i)&#123;drawPiexl(x, y);x += <span class="hljs-number">1</span>, e += k;<span class="hljs-keyword">if</span> (e &gt;= <span class="hljs-number">0</span>) &#123; y++; e = e - <span class="hljs-number">1</span>; &#125;&#125;&#125;<span class="hljs-keyword">else</span>&#123;k = <span class="hljs-built_in">abs</span>(k);<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt;= dx; ++i)&#123;drawPiexl(x, y);x += <span class="hljs-number">1</span>, e += k;<span class="hljs-keyword">if</span> (e &gt;= <span class="hljs-number">0</span>) &#123; y--; e = e - <span class="hljs-number">1</span>; &#125;&#125;&#125;&#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-keyword">if</span> (k &gt; <span class="hljs-number">0</span>)&#123;k = <span class="hljs-number">1.0</span> / k;<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt;= dy; ++i)&#123;drawPiexl(x, y);y += <span class="hljs-number">1</span>, e += k;<span class="hljs-keyword">if</span> (e &gt;= <span class="hljs-number">0</span>) &#123; x++; e = e - <span class="hljs-number">1</span>; &#125;&#125;&#125;<span class="hljs-keyword">else</span>&#123;k = <span class="hljs-number">1.0</span> / <span class="hljs-built_in">abs</span>(k);<span class="hljs-keyword">for</span> (i = dy; i &lt;= <span class="hljs-number">0</span>; ++i)&#123;drawPiexl(x, y);y -= <span class="hljs-number">1</span>, e += k;<span class="hljs-keyword">if</span> (e &gt;= <span class="hljs-number">0</span>) &#123; x++; e = e - <span class="hljs-number">1</span>; &#125;&#125;&#125;&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DDA_Line</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x0, <span class="hljs-keyword">int</span> y0, <span class="hljs-keyword">int</span> x1, <span class="hljs-keyword">int</span> y1)</span></span><span class="hljs-function"></span>&#123;glClear(GL_COLOR_BUFFER_BIT);<span class="hljs-keyword">int</span> t;<span class="hljs-keyword">if</span> (x1 &lt; x0)&#123;t = x1; x1 = x0; x0 = t;t = y1; y1 = y0; y0 = t;&#125;<span class="hljs-keyword">int</span> x;<span class="hljs-keyword">float</span> dx, dy, y, k;dx = x1 - x0, dy = y1 - y0;k = dy / dx;y = y0;<span class="hljs-keyword">for</span> (x = x0; x &lt;= x1; x++)&#123;drawPiexl(x, <span class="hljs-keyword">int</span>(y + <span class="hljs-number">0.5</span>));y += k;&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DrawLine</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;Bresenham_Line(m0, n0, m1, n1);<span class="hljs-comment">//Midpoint_Line(m0, n0, m1, n1);</span><span class="hljs-comment">//DDA_Line(m0, n0, m1, n1);</span>&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">mymouse</span><span class="hljs-params">(GLint button, GLint state, GLint x,GLint y)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">if</span> (button == GLUT_LEFT_BUTTON &amp;&amp; state == GLUT_DOWN &amp;&amp; flag == <span class="hljs-number">1</span>)&#123;m0 = x;n0 = y;flag = <span class="hljs-number">0</span>;&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (button == GLUT_LEFT_BUTTON &amp;&amp; state == GLUT_UP &amp;&amp; flag == <span class="hljs-number">0</span>)&#123;m1 = x;n1 = y;DrawLine();glFlush();flag = <span class="hljs-number">1</span>;&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">movemouse</span><span class="hljs-params">(GLint x, GLint y)</span></span><span class="hljs-function"></span>&#123;m1 = x, n1 = y;DrawLine();glFlush();&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span><span class="hljs-function"></span>&#123;glClearColor(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>);<span class="hljs-comment">//设置绘制窗口颜色为白色</span>glClear(GL_COLOR_BUFFER_BIT);<span class="hljs-comment">//清除窗口内容</span>glPointSize(<span class="hljs-number">4.0f</span>);<span class="hljs-comment">//设置点的大小</span><span class="hljs-comment">/*设置为投影类型模式和其他观察参数*/</span>glMatrixMode(GL_PROJECTION);glLoadIdentity();gluOrtho2D(<span class="hljs-number">0</span>, <span class="hljs-number">1024</span>, <span class="hljs-number">720</span>, <span class="hljs-number">0</span>);glColor3f(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<span class="hljs-comment">//设置画点的颜色</span>&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> ** argv)</span></span><span class="hljs-function"></span>&#123;glutInit(&amp;argc, argv);glutInitDisplayMode(GLUT_SINGLE | GLUT_RGB);glutInitWindowPosition(<span class="hljs-number">400</span>, <span class="hljs-number">200</span>);glutInitWindowSize(<span class="hljs-number">1024</span>,<span class="hljs-number">720</span>);<span class="hljs-comment">//设置窗口大小</span>glutCreateWindow(<span class="hljs-string">"Lab2_Line"</span>);init();glutDisplayFunc(DrawLine);glutMouseFunc(mymouse);glutMotionFunc(movemouse);glutMainLoop();<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h5 id="中点画圆"><a href="#中点画圆" class="headerlink" title="中点画圆"></a>中点画圆</h5><div class="hljs"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;gl/glut.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cmath&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstdlib&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;GLint m0, n0, m1, n1;GLdouble r;<span class="hljs-keyword">bool</span> flag = <span class="hljs-number">1</span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">drawPiexl</span><span class="hljs-params">(GLint x, GLint y)</span></span><span class="hljs-function"></span>&#123;glBegin(GL_POINTS);glVertex2i(x, y);glEnd();&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">drawCirPoint</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y,<span class="hljs-keyword">int</span> x0,<span class="hljs-keyword">int</span> y0)</span></span><span class="hljs-function"></span>&#123;glBegin(GL_POINTS);glVertex2f(x + x0, y + y0);glVertex2f(y + x0, x + y0);glVertex2f(-x + x0, y + y0);glVertex2f(y + x0, -x + y0);glVertex2f(x + x0, -y + y0);glVertex2f(-y + x0, x + y0);glVertex2f(-x + x0, -y + y0);glVertex2f(-y + x0, -x + y0);glEnd();&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DrawCircle</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;glClear(GL_COLOR_BUFFER_BIT);<span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>, y = r, x0 = m0, y0 = n0;<span class="hljs-keyword">double</span> d = <span class="hljs-number">1.25</span> - r;drawPiexl(x0, y0);<span class="hljs-keyword">while</span> (x &lt;= y)&#123;<span class="hljs-keyword">if</span> (d &lt; <span class="hljs-number">0</span>)d += <span class="hljs-number">2</span> * x + <span class="hljs-number">3</span>;<span class="hljs-keyword">else</span>&#123;d += <span class="hljs-number">2</span> * (x - y) + <span class="hljs-number">5</span>;y--;&#125;x++;drawCirPoint(x, y, x0, y0);&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">mycicle</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;DrawCircle();glFlush();&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">mymouse</span><span class="hljs-params">(GLint button, GLint state, GLint x, GLint y)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">if</span> (button == GLUT_LEFT_BUTTON &amp;&amp; state == GLUT_DOWN &amp;&amp; flag == <span class="hljs-number">1</span>)&#123;m0 = x;n0 = y;flag = <span class="hljs-number">0</span>;&#125;<span class="hljs-keyword">if</span> (button == GLUT_LEFT_BUTTON &amp;&amp; state == GLUT_UP &amp;&amp; flag == <span class="hljs-number">0</span>)&#123;m1 = x;n1 = y;r = <span class="hljs-built_in">sqrt</span>((m1-m0) * (m1-m0) + (n1-n0) * (n1-n0));DrawCircle();glFlush();flag = <span class="hljs-number">1</span>;&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">movemouse</span><span class="hljs-params">(GLint x, GLint y)</span></span><span class="hljs-function"></span>&#123;m1 = x, n1 = y;r = <span class="hljs-built_in">sqrt</span>((m1 - m0) * (m1 - m0) + (n1 - n0) * (n1 - n0));DrawCircle();glFlush();&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;glClearColor(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>);<span class="hljs-comment">//设置绘制窗口颜色为白色</span>glClear(GL_COLOR_BUFFER_BIT);<span class="hljs-comment">//清除窗口内容</span>glPointSize(<span class="hljs-number">3.0f</span>);<span class="hljs-comment">//设置点的大小</span><span class="hljs-comment">/*设置为投影类型模式和其他观察参数*/</span>glMatrixMode(GL_PROJECTION);glLoadIdentity();gluOrtho2D(<span class="hljs-number">0</span>, <span class="hljs-number">1024</span>, <span class="hljs-number">720</span>, <span class="hljs-number">0</span>);glColor3f(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<span class="hljs-comment">//设置画点的颜色</span>&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span>** argv)</span></span><span class="hljs-function"></span>&#123;glutInit(&amp;argc, argv);glutInitDisplayMode(GLUT_SINGLE | GLUT_RGB);glutInitWindowPosition(<span class="hljs-number">400</span>, <span class="hljs-number">200</span>);glutInitWindowSize(<span class="hljs-number">1024</span>, <span class="hljs-number">720</span>);<span class="hljs-comment">//设置窗口大小</span>glutCreateWindow(<span class="hljs-string">"Lab2_Line"</span>);init();glutDisplayFunc(mycicle);glutMouseFunc(mymouse);glutMotionFunc(movemouse);glutMainLoop();<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h4 id="问题总结"><a href="#问题总结" class="headerlink" title="问题总结"></a>问题总结</h4>]]></content>
    
    
    <categories>
      
      <category>Computer Graphics</category>
      
      <category>SDU2020图形学实验记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图形学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SDU2020ML Lab1 Linear Regression</title>
    <link href="/2020/09/12/SDU2020ML_Lab1_Linear%20Regression/"/>
    <url>/2020/09/12/SDU2020ML_Lab1_Linear%20Regression/</url>
    
    <content type="html"><![CDATA[<blockquote><p>指导书以及数据集：<a href="https://funglee.github.io/ml/ml.html" target="_blank" rel="noopener">https://funglee.github.io/ml/ml.html</a></p></blockquote><h4 id="2D-Linear-Regression-and-Understanding-J-θ"><a href="#2D-Linear-Regression-and-Understanding-J-θ" class="headerlink" title="2D Linear Regression and Understanding J(θ)"></a>2D Linear Regression and Understanding J(θ)</h4><blockquote><p>要求：</p><ul><li>记录经过一次迭代之后theta的值</li><li>进行BGD，得到最终theta的值</li><li>根据上一步theta的值进行预测</li><li>作出J(θ)的图像</li></ul></blockquote><h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><div class="hljs"><pre><code class="hljs matlab"><span class="hljs-comment">%一元线性回归 使用BGD</span>x = load(<span class="hljs-string">'ex1_1x.dat'</span>);y = load(<span class="hljs-string">'ex1_1y.dat'</span>);<span class="hljs-built_in">figure</span>;<span class="hljs-built_in">plot</span>(x,y,<span class="hljs-string">'o'</span>);ylabel(<span class="hljs-string">'Height in meters'</span>);xlabel(<span class="hljs-string">'Age in years'</span>);m = <span class="hljs-built_in">length</span>(y);x = [<span class="hljs-built_in">ones</span>(m,<span class="hljs-number">1</span>),x];theta = <span class="hljs-built_in">zeros</span>(<span class="hljs-number">2</span>,<span class="hljs-number">1</span>);<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">theta</span> = <span class="hljs-title">bgd</span><span class="hljs-params">(x,y,num_iter,theta,alpha)</span></span>m = <span class="hljs-built_in">length</span>(y);n = <span class="hljs-built_in">length</span>(x(<span class="hljs-number">1</span>,:));  <span class="hljs-comment">%disp(n);</span>iter = <span class="hljs-number">0</span>;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">true</span>)sum = <span class="hljs-built_in">zeros</span>(n,<span class="hljs-number">1</span>);    H = x * theta;<span class="hljs-keyword">for</span> <span class="hljs-built_in">i</span>=<span class="hljs-number">1</span>:n<span class="hljs-keyword">for</span> <span class="hljs-built_in">j</span>=<span class="hljs-number">1</span>:m <span class="hljs-comment">%计算第i个偏导数--遍历样本点，求和</span>sum(<span class="hljs-built_in">i</span>,<span class="hljs-number">1</span>) = sum(<span class="hljs-built_in">i</span>,<span class="hljs-number">1</span>) + (H(<span class="hljs-built_in">j</span>)-y(<span class="hljs-built_in">j</span>))*x(<span class="hljs-built_in">j</span>,<span class="hljs-built_in">i</span>);<span class="hljs-keyword">end</span><span class="hljs-keyword">end</span>theta = theta - (alpha * sum) / m;iter = iter+<span class="hljs-number">1</span>;<span class="hljs-keyword">if</span> iter &gt; num_iter || <span class="hljs-built_in">abs</span>(theta)&lt;<span class="hljs-number">1e-4</span>      <span class="hljs-built_in">disp</span>(iter);<span class="hljs-keyword">break</span>;<span class="hljs-keyword">end</span><span class="hljs-keyword">end</span><span class="hljs-keyword">end</span>theta = bgd(x,y,<span class="hljs-number">1500</span>,theta,<span class="hljs-number">0.07</span>);<span class="hljs-built_in">hold</span> on; <span class="hljs-built_in">plot</span>(x(:,<span class="hljs-number">2</span>), x*theta, <span class="hljs-string">'-'</span>)<span class="hljs-built_in">legend</span>(<span class="hljs-string">'Training data'</span>, <span class="hljs-string">'Linear regression'</span>)boy1 = [<span class="hljs-number">1</span> , <span class="hljs-number">3.5</span>];boy2 = [<span class="hljs-number">1</span> , <span class="hljs-number">7</span>];<span class="hljs-built_in">plot</span>(boy1(:,<span class="hljs-number">2</span>),boy1 * theta, <span class="hljs-string">'sr'</span>);<span class="hljs-built_in">plot</span>(boy2(:,<span class="hljs-number">2</span>),boy2 * theta, <span class="hljs-string">'sr'</span>);<span class="hljs-comment">%作出J(theta)的图像</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">jij</span> = <span class="hljs-title">cal_j_vals</span><span class="hljs-params">(x,y,t)</span> </span>  m = <span class="hljs-built_in">length</span>(y);  jij = (x*t - y)' * (x*t - y) / (<span class="hljs-number">2</span> * m); <span class="hljs-keyword">end</span>;j_vals = <span class="hljs-built_in">zeros</span>(<span class="hljs-number">100</span>,<span class="hljs-number">100</span>);theta0_vals = <span class="hljs-built_in">linspace</span>(<span class="hljs-number">-3</span>,<span class="hljs-number">3</span>,<span class="hljs-number">100</span>);theta1_vals = <span class="hljs-built_in">linspace</span>(<span class="hljs-number">-1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">100</span>);<span class="hljs-keyword">for</span> <span class="hljs-built_in">i</span> = <span class="hljs-number">1</span>:<span class="hljs-built_in">length</span>(theta0_vals)  <span class="hljs-keyword">for</span> <span class="hljs-built_in">j</span> = <span class="hljs-number">1</span>:<span class="hljs-built_in">length</span>(theta1_vals)    t = [theta0_vals(<span class="hljs-built_in">i</span>); theta1_vals(<span class="hljs-built_in">j</span>)];    j_vals(<span class="hljs-built_in">i</span>,<span class="hljs-built_in">j</span>) = cal_j_vals(x,y,t);  <span class="hljs-keyword">end</span>;<span class="hljs-keyword">end</span>;j_vals = j_vals';<span class="hljs-built_in">figure</span>;surf(theta0_vals, theta1_vals,j_vals);xlabel(<span class="hljs-string">'\theta_0'</span>); ylabel(<span class="hljs-string">'\theta_1'</span>);[X,Y] = <span class="hljs-built_in">meshgrid</span>(theta0_vals,theta1_vals);</code></pre></div><h5 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h5><ul><li>注意到我们在<code>theta = theta - (alpha * sum) / m</code>中除以了<code>m</code>，经过测试如果不除以<code>m</code>，那么结果的图像是没有线的。（？？？）但是这不是cost function的两种形式吗，为什么不除以<code>m</code>就不行？进一步延申：为什么代价函数的形式是这样的？（前面是否可以是任意实数—网上答案是“是”，如何证明？）</li></ul><h5 id="BGD算法实现"><a href="#BGD算法实现" class="headerlink" title="BGD算法实现"></a>BGD算法实现</h5><div class="hljs"><pre><code class="hljs matlab"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">theta</span> = <span class="hljs-title">bgd</span><span class="hljs-params">(x,y,num_iter,theta,alpha)</span></span>m = <span class="hljs-built_in">length</span>(y);n = <span class="hljs-built_in">length</span>(x(<span class="hljs-number">1</span>,:));iter = <span class="hljs-number">0</span>;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">true</span>)sum = <span class="hljs-built_in">zeros</span>(n,<span class="hljs-number">1</span>);    H = x * theta;<span class="hljs-keyword">for</span> <span class="hljs-built_in">i</span>=<span class="hljs-number">1</span>:n<span class="hljs-keyword">for</span> <span class="hljs-built_in">j</span>=<span class="hljs-number">1</span>:m <span class="hljs-comment">%计算第i个偏导数--遍历样本点，求和</span>sum(<span class="hljs-built_in">i</span>,<span class="hljs-number">1</span>) = sum(<span class="hljs-built_in">i</span>,<span class="hljs-number">1</span>) + (H(<span class="hljs-built_in">j</span>)-y(<span class="hljs-built_in">j</span>))*x(<span class="hljs-built_in">j</span>,<span class="hljs-built_in">i</span>);<span class="hljs-keyword">end</span><span class="hljs-keyword">end</span>theta = theta - (alpha * sum) / m;iter = iter+<span class="hljs-number">1</span>;<span class="hljs-keyword">if</span> iter &gt; num_iter || <span class="hljs-built_in">abs</span>(theta)&lt;<span class="hljs-number">1e-4</span>      <span class="hljs-built_in">disp</span>(iter);<span class="hljs-keyword">break</span>;<span class="hljs-keyword">end</span><span class="hljs-keyword">end</span><span class="hljs-keyword">end</span><span class="hljs-comment">%计算J(θ):</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">jij</span> = <span class="hljs-title">cal_j_vals</span><span class="hljs-params">(x,y,t)</span> </span>  m = <span class="hljs-built_in">length</span>(y);  jij = (x*t - y)' * (x*t - y) / (<span class="hljs-number">2</span> * m); <span class="hljs-keyword">end</span>;</code></pre></div><hr><h4 id="Multivariate-Linear-Regression"><a href="#Multivariate-Linear-Regression" class="headerlink" title="Multivariate Linear Regression"></a>Multivariate Linear Regression</h4><blockquote><p>要求：</p><ul><li>调整不同的学习率，使得损失函数的曲线形状接近于给出的曲线</li><li>比较不同的学习率得到的不同的损失函数曲线</li></ul></blockquote><h5 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h5><div class="hljs"><pre><code class="hljs matlab">x = load(<span class="hljs-string">'ex1_2x.dat'</span>);y = load(<span class="hljs-string">'ex1_2y.dat'</span>);<span class="hljs-comment">% x: living area and the number of bedrooms</span><span class="hljs-comment">% y: house price</span>m = <span class="hljs-built_in">length</span>(y);x = [<span class="hljs-built_in">ones</span>(m,<span class="hljs-number">1</span>),x];sigma = std(x);mu = <span class="hljs-built_in">mean</span>(x);<span class="hljs-comment">% preprocessing</span>x(:,<span class="hljs-number">2</span>) = (x(:,<span class="hljs-number">2</span>) - mu(<span class="hljs-number">2</span>)) ./ sigma(<span class="hljs-number">2</span>);x(:,<span class="hljs-number">3</span>) = (x(:,<span class="hljs-number">3</span>) - mu(<span class="hljs-number">3</span>)) ./ sigma(<span class="hljs-number">3</span>);n = <span class="hljs-number">3</span>;<span class="hljs-comment">%disp(n);</span>theta = <span class="hljs-built_in">zeros</span>(n,<span class="hljs-number">1</span>)<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">theta</span> = <span class="hljs-title">bgd</span><span class="hljs-params">(x,y,alpha,iter,theta)</span></span>  <span class="hljs-keyword">for</span> <span class="hljs-built_in">i</span>=<span class="hljs-number">1</span>:iter    m = <span class="hljs-built_in">length</span>(y);    n = <span class="hljs-number">3</span>;    sum = <span class="hljs-built_in">zeros</span>(n,<span class="hljs-number">1</span>); <span class="hljs-comment">%记录偏导</span>    H = x * theta;<span class="hljs-comment">%变成一列</span>    <span class="hljs-keyword">for</span> <span class="hljs-built_in">j</span>=<span class="hljs-number">1</span>:n      <span class="hljs-keyword">for</span> <span class="hljs-built_in">i</span>=<span class="hljs-number">1</span>:m        sum(<span class="hljs-built_in">j</span>,<span class="hljs-number">1</span>) = sum(<span class="hljs-built_in">j</span>,<span class="hljs-number">1</span>) + (H(<span class="hljs-built_in">i</span>)-y(<span class="hljs-built_in">i</span>))*x(<span class="hljs-built_in">i</span>,<span class="hljs-built_in">j</span>);      <span class="hljs-keyword">end</span>    <span class="hljs-keyword">end</span>    theta = theta - (alpha*sum)/m;  <span class="hljs-keyword">end</span><span class="hljs-keyword">end</span>theta = <span class="hljs-built_in">zeros</span>(n,<span class="hljs-number">1</span>);<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">val_of_j</span> = <span class="hljs-title">cal_j_vals</span><span class="hljs-params">(x,y,theta)</span> </span>  m = <span class="hljs-built_in">length</span>(y);  val_of_j = (x*theta - y)' * (x*theta - y) / (<span class="hljs-number">2</span> * m); <span class="hljs-keyword">end</span>;alpha = <span class="hljs-number">0.06</span>;J = <span class="hljs-built_in">zeros</span>(<span class="hljs-number">50</span>,<span class="hljs-number">1</span>);<span class="hljs-keyword">for</span> num_iterations = <span class="hljs-number">1</span>:<span class="hljs-number">50</span>  J(num_iterations) = cal_j_vals(x,y,theta);  theta = bgd(x,y,alpha,num_iterations,theta);<span class="hljs-keyword">end</span>;<span class="hljs-built_in">figure</span>;p0 = <span class="hljs-built_in">plot</span>(<span class="hljs-number">0</span>:<span class="hljs-number">49</span>,J(<span class="hljs-number">1</span>:<span class="hljs-number">50</span>),<span class="hljs-string">'-'</span>);<span class="hljs-built_in">hold</span> on;xlabel(<span class="hljs-string">'Numbber of iterations'</span>)ylabel(<span class="hljs-string">'Cost J'</span>)<span class="hljs-comment">%批量改变alpha</span><span class="hljs-built_in">figure</span>;alpha = <span class="hljs-number">0.01</span>;<span class="hljs-keyword">while</span> alpha &lt; <span class="hljs-number">0.1</span>  J = <span class="hljs-built_in">zeros</span>(<span class="hljs-number">50</span>,<span class="hljs-number">1</span>);  theta = <span class="hljs-built_in">zeros</span>(n,<span class="hljs-number">1</span>);  <span class="hljs-keyword">for</span> num_iterations = <span class="hljs-number">1</span>:<span class="hljs-number">50</span>  J(num_iterations) = cal_j_vals(x,y,theta);  theta = bgd(x,y,alpha,num_iterations,theta);  <span class="hljs-keyword">end</span>;  <span class="hljs-built_in">plot</span>(<span class="hljs-number">0</span>:<span class="hljs-number">49</span>,J(<span class="hljs-number">1</span>:<span class="hljs-number">50</span>),<span class="hljs-string">'-'</span>);  <span class="hljs-built_in">hold</span> on;  alpha = alpha * <span class="hljs-number">3</span>;<span class="hljs-keyword">end</span>;</code></pre></div><h5 id="特征缩放"><a href="#特征缩放" class="headerlink" title="特征缩放"></a>特征缩放</h5><h5 id="回答问题"><a href="#回答问题" class="headerlink" title="回答问题"></a>回答问题</h5><ul><li><p>如果学习率太小，例如0.001，那么损失函数下降得非常缓慢；</p><p><img src="https://i.loli.net/2020/09/20/ntKmgTByLr5b8WS.png" srcset="/img/loading.gif" alt="image-20200920212924281" style="zoom: 67%;" /></p><p>如果学习率太大，例如1，那么下降很快并且停止</p></li></ul><p><img src="https://i.loli.net/2020/09/20/EAt2OSreUXoIGkZ.png" srcset="/img/loading.gif" alt="image-20200920213034741" style="zoom:67%;" /></p><ul><li><p>进行预测</p><div class="hljs"><pre><code class="hljs matlab">x = load(<span class="hljs-string">'ex1_2x.dat'</span>);y = load(<span class="hljs-string">'ex1_2y.dat'</span>);<span class="hljs-comment">% x: living area and the number of bedrooms</span><span class="hljs-comment">% y: house price</span>m = <span class="hljs-built_in">length</span>(y);x = [<span class="hljs-built_in">ones</span>(m,<span class="hljs-number">1</span>),x];n = <span class="hljs-built_in">length</span>(x(<span class="hljs-number">1</span>,:));sigma = std(x);mu = <span class="hljs-built_in">mean</span>(x);x(:,<span class="hljs-number">2</span>) = (x(:,<span class="hljs-number">2</span>) - mu(<span class="hljs-number">2</span>)) ./ sigma(<span class="hljs-number">2</span>);x(:,<span class="hljs-number">3</span>) = (x(:,<span class="hljs-number">3</span>) - mu(<span class="hljs-number">3</span>)) ./ sigma(<span class="hljs-number">3</span>);theta = <span class="hljs-built_in">zeros</span>(n,<span class="hljs-number">1</span>);<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">theta</span> = <span class="hljs-title">bgd</span><span class="hljs-params">(x,y,num_iter,theta,alpha)</span></span>m = <span class="hljs-built_in">length</span>(y);n = <span class="hljs-built_in">length</span>(x(<span class="hljs-number">1</span>,:));iter = <span class="hljs-number">0</span>;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">true</span>)sum = <span class="hljs-built_in">zeros</span>(n,<span class="hljs-number">1</span>);    H = x * theta;<span class="hljs-keyword">for</span> <span class="hljs-built_in">i</span>=<span class="hljs-number">1</span>:n<span class="hljs-keyword">for</span> <span class="hljs-built_in">j</span>=<span class="hljs-number">1</span>:m <span class="hljs-comment">%计算第i个偏导数--遍历样本点，求和</span>sum(<span class="hljs-built_in">i</span>,<span class="hljs-number">1</span>) = sum(<span class="hljs-built_in">i</span>,<span class="hljs-number">1</span>) + (H(<span class="hljs-built_in">j</span>)-y(<span class="hljs-built_in">j</span>))*x(<span class="hljs-built_in">j</span>,<span class="hljs-built_in">i</span>);<span class="hljs-keyword">end</span><span class="hljs-keyword">end</span>theta = theta - (alpha * sum) / m;iter = iter+<span class="hljs-number">1</span>;<span class="hljs-keyword">if</span> iter &gt; num_iter || <span class="hljs-built_in">abs</span>(theta)&lt;<span class="hljs-number">1e-4</span>      <span class="hljs-built_in">disp</span>(iter);<span class="hljs-keyword">break</span>;<span class="hljs-keyword">end</span><span class="hljs-keyword">end</span><span class="hljs-keyword">end</span>theta = bgd(x,y,<span class="hljs-number">1500</span>,theta,<span class="hljs-number">0.07</span>);<span class="hljs-built_in">disp</span>(theta);pre_x = [<span class="hljs-number">1</span>,<span class="hljs-number">1650</span>,<span class="hljs-number">3</span>];pre_x(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>) = (pre_x(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>) - mu(<span class="hljs-number">2</span>)) / sigma(<span class="hljs-number">2</span>);pre_x(<span class="hljs-number">1</span>,<span class="hljs-number">3</span>) = (pre_x(<span class="hljs-number">1</span>,<span class="hljs-number">3</span>) - mu(<span class="hljs-number">3</span>)) / sigma(<span class="hljs-number">3</span>);<span class="hljs-built_in">disp</span>(pre_x * theta);</code></pre></div><p><img src="https://i.loli.net/2020/09/20/74zCd832WrA1etQ.png" srcset="/img/loading.gif" alt="image-20200920215250588"></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Machine Learning</category>
      
      <category>SDU2020 ML记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Regression</title>
    <link href="/2020/09/07/Linear%20Regression/"/>
    <url>/2020/09/07/Linear%20Regression/</url>
    
    <content type="html"><![CDATA[<h3 id="Case-Study"><a href="#Case-Study" class="headerlink" title="Case Study"></a>Case Study</h3><h4 id="基本步骤"><a href="#基本步骤" class="headerlink" title="基本步骤"></a>基本步骤</h4><p>预测宝可梦的CP值是一个典型的回归问题。考虑三个基本步骤：选定model；定义loss function；training data：根据loss function/找到一个最好的model。</p><blockquote><p>我们在选定model时会定义各个参数，而loss function就是这些参数的函数—用以评估这些参数的好坏</p></blockquote><p>在这个例子中我们使用<strong>？？？Model</strong>，接着我们得到了loss function。那么如何求解loss function的最小值从而得到最好的model？—<strong>梯度下降法 Gradient Descent</strong></p><h4 id="Gradient-Descent"><a href="#Gradient-Descent" class="headerlink" title="Gradient Descent"></a>Gradient Descent</h4><h5 id="基本操作步骤："><a href="#基本操作步骤：" class="headerlink" title="基本操作步骤："></a>基本操作步骤：</h5><p>这节课里只是简单地介绍了一下Gradient Descent是如何操作的：首先从一元函数求极值开始，我们从某点<code>W0</code>开始，根据导数（这里注意使用梯度下降的前提是loss function是可微的）判断<code>W0</code>应该增大或者减小，然后循环进行这样的变化，直到导数为0。这里便有了<strong>learning rate</strong>这个参数—<code>W0</code>的变化每次都是增加或者减少<code>learning rate * 导数值</code>。推广到二元函数的情形也是一致的：分别求两个变量的偏导数。</p><h5 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h5><p>但是以上只是简单的操作/演示Gradient Descent如何进行，还有一些问题：</p><ul><li>显然对于任意一个二元函数来说，可能local optimal 并非global optimal—由于是从某<code>W0</code>点开始的，因此可能在此附近陷入local minima，而得到不全局的minima。为了让Gradient Descent有效我们必须保证loss function没有局部最优解。</li><li>这里延申出一个问题：我们上面定义的loss function是<strong>凸函数</strong>，只有global optimal。所以：<strong>凸函数的性质？</strong></li></ul><h4 id="对于结果的该进"><a href="#对于结果的该进" class="headerlink" title="对于结果的该进"></a>对于结果的该进</h4><h5 id="其他model"><a href="#其他model" class="headerlink" title="其他model"></a>其他model</h5><p>事实上我们可以尝试增加<code>Xi</code>的次数—使用更高阶数去进行拟合。这样结果就是在训练集上我们的error越来越小，（低次的式子是高次的式子的特殊情况。<strong>考虑可视化的表现：使用更高次数的式子去拟合，其对应的function set包含了低次式对应的function set，所以training data上表现更好是自然的</strong>），但是在testing data上的表现却未必。</p><h5 id="overfitting-过拟合-以及-regularization-正则化"><a href="#overfitting-过拟合-以及-regularization-正则化" class="headerlink" title="overfitting 过拟合 以及 regularization 正则化"></a>overfitting 过拟合 以及 regularization 正则化</h5><p>上面的现象便是过拟合。</p><p>我们可以通过regularization来解决这个问题：在原本loss function的基础上增加一项。<strong>这样的结果是函数变得更加平滑，从而结果更好（平滑意味着输出对输入敏感性降低，从而输入的一些noise对于结果的影响更小）</strong></p><p><img src="https://gitee.com/Sakura-gh/ML-notes/raw/master/img/regularization.png" srcset="/img/loading.gif" alt="regularization" style="zoom: 33%;" /></p><p><strong>（这里的参数需要手动调整，从而使其在平滑与不平滑之间达到一个较好的状态）</strong></p><h4 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h4><ul><li>凸函数 可微 偏导数</li><li>正则化处理过程中增加一项的数学上的理解</li><li>model有哪些？</li></ul><hr><h3 id="对于Gradient-Descent的理解"><a href="#对于Gradient-Descent的理解" class="headerlink" title="对于Gradient Descent的理解"></a>对于Gradient Descent的理解</h3><h4 id="方向导数"><a href="#方向导数" class="headerlink" title="方向导数"></a>方向导数</h4><hr>]]></content>
    
    
    <categories>
      
      <category>Machine Learning</category>
      
      <category>李宏毅机器学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>李宏毅2020机器学习课程记录</title>
    <link href="/2020/09/07/%E6%9D%8E%E5%AE%8F%E6%AF%852020%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8B%E8%AE%B0%E5%BD%95/"/>
    <url>/2020/09/07/%E6%9D%8E%E5%AE%8F%E6%AF%852020%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8B%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>Machine Learning</category>
      
      <category>李宏毅机器学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GAMES101记录</title>
    <link href="/2020/07/17/GAMES101%E8%AE%B0%E5%BD%95/"/>
    <url>/2020/07/17/GAMES101%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>Computer Graphics</category>
      
      <category>GAMES101</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图形学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>博客搭建过程记录</title>
    <link href="/2020/04/24/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95/"/>
    <url>/2020/04/24/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>程序设计思维与实践</category>
      
      <category>代码模板</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
