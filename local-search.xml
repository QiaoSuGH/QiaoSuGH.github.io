<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>High Performance Mysql [Notes]</title>
    <link href="/2021/03/07/High%20Performance%20Mysql%20%5BNotes%5D/"/>
    <url>/2021/03/07/High%20Performance%20Mysql%20%5BNotes%5D/</url>
    
    <content type="html"><![CDATA[<h3 id="ch1-Mysql-Architecture-and-History"><a href="#ch1-Mysql-Architecture-and-History" class="headerlink" title="ch1 Mysql Architecture and History"></a>ch1 Mysql Architecture and History</h3><h4 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h4><h5 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h5><ul><li><p>ACID属性</p></li><li><p>隔离性的四个级别</p><ul><li><p>关于nonrepeatedable read</p><blockquote><p>…a transaction T2 could change the value of an object A that has been read by a transaction T1, while T1 is still in progress. If T1 tries to read the value of A again, it will get a different result, even though it has not modified A in the meantime… —<em>Database Management Systems</em></p></blockquote></li></ul></li></ul><h5 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h5>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>Mysql</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
      <tag>Mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CS144-04-Lab3.md</title>
    <link href="/2021/03/07/CS144-04-Lab3/"/>
    <url>/2021/03/07/CS144-04-Lab3/</url>
    
    <content type="html"><![CDATA[<h5 id="为什么需要随机的ISN"><a href="#为什么需要随机的ISN" class="headerlink" title="为什么需要随机的ISN"></a>为什么需要随机的ISN</h5><p><a href="https://www.quora.com/Why-in-a-TCP-sequence-is-a-number-taken-as-a-random-number-and-what-is-the-actual-number-at-the-start" target="_blank" rel="noopener">https://www.quora.com/Why-in-a-TCP-sequence-is-a-number-taken-as-a-random-number-and-what-is-the-actual-number-at-the-start</a></p><p><a href="https://www.techrepublic.com/article/tcp-hijacking/" target="_blank" rel="noopener">https://www.techrepublic.com/article/tcp-hijacking/</a></p><p><a href="https://pdos.csail.mit.edu/~rtm/papers/117.pdf" target="_blank" rel="noopener">https://pdos.csail.mit.edu/~rtm/papers/117.pdf</a></p><p>主要是与一些攻击方式有关系。具体的原理尚未明白。</p><h4 id="Implementing-the-TCP-Sender"><a href="#Implementing-the-TCP-Sender" class="headerlink" title="Implementing the TCP Sender"></a>Implementing the TCP Sender</h4><h5 id="前置的思考探索"><a href="#前置的思考探索" class="headerlink" title="前置的思考探索"></a>前置的思考探索</h5><p>TCP  sender会接收byte-stream，然后将其拆分、填充成segments。对于来自receiver的segment，主要关心ackno和window size。</p><ul><li>类似于receiver，应该同样需要涉及到stream index和absolute seqno/seqno之间的转换。</li></ul><p>如何实现ARQ？</p><ul><li><p>注意segment可能有部分byte被确认了——返回的ackno之前的。</p></li><li><p>我们怎么知道哪些segment需要重传？有两个方面需要考虑，一是所有未被确认的segment，二是与计时器相关。我们采用的是累计确认，每次从receiver获得ackno之后，ackno之前的segment都被确认了。确认了那么也就没有必要继续保存了。我们在<code>queue&lt;TCPSegment&gt; _segments_out</code>中保存了发送出去的segments。那么可以考虑未被确认的继续留在<code>_segment_out</code>中。</p><p>对于<code>tick(const size_t ms_since_last_tick)</code>我们知道参数是自从上次<code>tick()</code>被调用经历的毫秒数，但是它负责什么？startercode里面并没有<code>retransmissions timer</code>。</p><blockquote><p>看了一下网上的实现，发现<code>tick()</code>的调用是在Lab4……决定去看看测试</p></blockquote></li></ul><h5 id="从测试开始"><a href="#从测试开始" class="headerlink" title="从测试开始"></a>从测试开始</h5><blockquote><p>本来的想法是根据对指导书以及TCP的理解自顶向下地完成，但是看了几遍都没有清晰的思路。所以还是去看test cases从而知道我们需要完成的具体任务。</p></blockquote><p>首先是从<code>send_connect</code>即发送连接开始。</p><p>具体的test包括：</p><blockquote><p>SYN sent test</p><p>SYN acked test</p><p>SYN -&gt; wrong ack test</p><p>SYN acked, data</p></blockquote><p>我们需要理解test。例如第二个case：</p><div class="hljs"><pre><code class="hljs c++">&#123;            TCPConfig cfg;            <span class="hljs-function">WrappingInt32 <span class="hljs-title">isn</span><span class="hljs-params">(rd())</span></span>;            cfg.fixed_isn = isn;            TCPSenderTestHarness test&#123;<span class="hljs-string">"SYN acked test"</span>, cfg&#125;;            test.execute(ExpectState&#123;TCPSenderStateSummary::SYN_SENT&#125;);            test.execute(ExpectSegment&#123;&#125;.with_no_flags().with_syn(<span class="hljs-literal">true</span>).with_payload_size(<span class="hljs-number">0</span>).with_seqno(isn));            test.execute(ExpectBytesInFlight&#123;<span class="hljs-number">1</span>&#125;);            test.execute(AckReceived&#123;WrappingInt32&#123;isn + <span class="hljs-number">1</span>&#125;&#125;);            test.execute(ExpectState&#123;TCPSenderStateSummary::SYN_ACKED&#125;);            test.execute(ExpectNoSegment&#123;&#125;);            test.execute(ExpectBytesInFlight&#123;<span class="hljs-number">0</span>&#125;);        &#125;</code></pre></div><p>有一个<code>TCPSenderStateSummary::SYN_SENT</code>，我们直接转到定义去看看：</p><p><img src="https://i.loli.net/2021/03/08/CP4Sdj8ZlrzhvWV.png" srcset="/img/loading.gif" alt="image-20210308153212253" style="zoom:67%;" /></p><p><img src="https://i.loli.net/2021/03/08/bDnT3iFqJMl7G4m.png" srcset="/img/loading.gif" alt="image-20210308153328456" style="zoom: 67%;" /></p><p>所以这些cases可以告诉我们执行了哪些操作、预期的结果是什么，从而帮助我们建立起思路。</p><h5 id="fill-window"><a href="#fill-window" class="headerlink" title="fill_window"></a><code>fill_window</code></h5><ul><li>首先我们初始的状态应该是<code>CLOSED</code>，等待发送SYN。因此我们需要确保第一个segment是SYN。所以需要<code>bool _SYN_sent</code>。完成对segment的填充之后我们将其push进入<code>_segments_out</code>。同时由于需要进行重传，所以备份至<code>queue&lt;TCPSegment&gt; _outstanding_segs</code>。另外更新<code>_bytes_in_flight</code>。由于尚未接收到<code>ackno = isn + 1</code>，所以更新为1。</li></ul><h5 id="ack-received"><a href="#ack-received" class="headerlink" title="ack_received"></a><code>ack_received</code></h5><ul><li><p>从上面的逻辑我们可以看出，在接收到<code>ackno</code>之后我们需要遍历<code>_outstanding_segs</code>，将<code>ackno</code>之前的segs pop掉。</p><ul><li><p>需要注意接收到的<code>ackno</code>是<code>WrappingInt32</code>类型，segment里面的seqno同样也是这个类型，但是由于存在回绕的情况，我们需要将两者都转为abs seqno从而便于比较。</p></li><li><p>既然是需要转化，那么<code>checkpoint</code>就是必要的。类似于receiver，我们直接使用上一次接收到的ackno即可。<strong>TODO</strong></p></li></ul></li><li></li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
      <category>CS144</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
      <tag>CS144</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CS144-03-Lab2</title>
    <link href="/2021/03/03/CS144-03-Lab2/"/>
    <url>/2021/03/03/CS144-03-Lab2/</url>
    
    <content type="html"><![CDATA[<hr><p>读完《TCP/IP详解 卷一：协议》CH12之后对于指导书中的图有了大致的理解，包括TCP头部各个字段的含义。</p><p>TCP接收方需要告诉发送方两方面的信息：</p><ul><li><p>接收方期待的下一个字节在stream中的序号。回想Lab1，我们有first_unread/first_unassembled/first_unacceptable。其中<code>[first_unread, first_unassembled)</code>即为已经组装好的segments，接收方希望下一个字节是first_unassembled对应的字节，接收方已经接收了此前的字节。这里的first_unassembled即为<strong>ackno——acknowledgment number</strong>。</p></li><li><p><code>[first_unassembled, first_unacceptable)</code>即为<strong>滑动窗口</strong>——此时接收方希望接收的字节的序列号的范围。</p></li></ul><h4 id="Translating-between-64-bit-indexes-and-32-bit-seqnos"><a href="#Translating-between-64-bit-indexes-and-32-bit-seqnos" class="headerlink" title="Translating between 64-bit indexes and 32-bit seqnos"></a>Translating between 64-bit indexes and 32-bit seqnos</h4><p>我们有三种序列：</p><ul><li>在TCP传输中标志每个字节的序列号，从ISN开始，32位</li><li>absolute seqno 将上者变为从0开始</li><li>stream中每个字节的序列号，即真正传输的数据的序列号</li></ul><p><img src="https://i.loli.net/2021/03/04/d3xwi5Pqo87GaAE.png" srcset="/img/loading.gif" alt="image-20210304175138487" style="zoom: 67%;" /></p><p>我们首先需要完成<code>WrappingInt32</code>类——对uint32_t进行封装，从而使其与uint64_t转换更加方便。</p><h5 id="wrap"><a href="#wrap" class="headerlink" title="wrap"></a><code>wrap</code></h5><p>很显然，我们取出<code>uint64_t n</code>的低32位，然后与<code>ISN</code>相加即可。</p><div class="hljs"><pre><code class="hljs c++"><span class="hljs-function">WrappingInt32 <span class="hljs-title">wrap</span><span class="hljs-params">(<span class="hljs-keyword">uint64_t</span> n, WrappingInt32 isn)</span> </span>&#123;   <span class="hljs-keyword">return</span> WrappingInt32(<span class="hljs-keyword">uint32_t</span>(n &amp; <span class="hljs-number">0x00000000FFFFFFFF</span>) + isn.raw_value());&#125;</code></pre></div><h5 id="unwrap"><a href="#unwrap" class="headerlink" title="unwrap"></a><code>unwrap</code></h5><p>从seqence number 向absolute sequence number转换：</p><ul><li><p>很显然这种转换不是唯一的——seqno每次增加$2^{32}$值都不变，但是absolute seqno变化。为了确定唯一的结果，我们需要<code>checkpoint</code>，即将可能的结果中距离<code>checkpoint</code>最近的作为最终结果。</p></li><li><p><del>我们知道这里<code>checkpoint</code>实际上是last reassembled bytes，那么新来的segment对应的seqno转换成absolute seqno之后应当大于<code>checkpoint</code>。</del>我们知道这里<code>checkpoint</code>实际上是last reassembled bytes，那么新来的segment对应的seqno转换成absolute seqno之后应当大于<code>checkpoint</code>。所以如果我们知道<code>checkpoint</code>最少增加多少就变成答案即可。答案记作<code>ans</code>，那么如果我们将<code>checkpoint</code>转换成32位的seqno，记作<code>cp_seqno</code>，那么实际上从<code>cp_seqno</code>走到<code>n</code>与<code>checkpoint</code>走到<code>ans</code>距离应该是一样的。</p><p><del>如何得到这个距离？如果<code>n - cp_seqno &gt;= 0</code>，那么是正常的；如果<code>n - cp_seqno &lt; 0</code>，那么说明其实是从<code>cp_seqno</code>继续增长、溢出$2^{32}-1$从0开始，所以我们需要将<code>n</code>加上$2^{32}$。</del></p><p>写完发现报错了。马上想到，新来的segment的seqno在整个stream中未必是在<code>checkpoint</code>之后，也有可能在之前——会导致被抛弃，这是合理的。所以有可能比<code>checkpoint</code>小。</p><div class="hljs"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">uint64_t</span> <span class="hljs-title">unwrap</span><span class="hljs-params">(WrappingInt32 n, WrappingInt32 isn, <span class="hljs-keyword">uint64_t</span> checkpoint)</span> </span>&#123;  <span class="hljs-keyword">int32_t</span> tmp = n - wrap(checkpoint, isn);  <span class="hljs-keyword">int64_t</span> ans = checkpoint + tmp;  <span class="hljs-keyword">return</span> ans &gt;= <span class="hljs-number">0</span> ? ans : ans + (<span class="hljs-number">1u</span>l &lt;&lt; <span class="hljs-number">32</span>);&#125;</code></pre></div></li></ul><h4 id="Implementing-the-TCP-receiver"><a href="#Implementing-the-TCP-receiver" class="headerlink" title="Implementing the TCP receiver"></a>Implementing the TCP receiver</h4><h5 id="关于TCP"><a href="#关于TCP" class="headerlink" title="关于TCP"></a>关于TCP</h5><p>首先有一个问题，为什么SYN 也需要一个序列号？序列号存在的意义有两方面：</p><ul><li>为了重组segment。只有标示了segment的data在整个stream中的index，我们才能将乱序的data再重组成完成的stream，才能实现一种可靠的流模式</li><li>为了可靠性——连接中任意一方发送的数据能够被对方通过ack确认，否则需要重传。那么显然发送SYN的一方也需要知道自己的SYN是否被接收了，怎么办？给SYN一个sequence number，如果有ack = sequence number + 1，那么便OK了。自然这里的sequence number就是ISN。</li></ul><p>TCP连接建立的根本目的是交换双方的ISN，这是可靠性的基础。</p><h5 id="Enable-C-17-support-in-VSCode-C-C-extension"><a href="#Enable-C-17-support-in-VSCode-C-C-extension" class="headerlink" title="Enable C++17 support in VSCode C/C++ extension"></a>Enable C++17 support in VSCode C/C++ extension</h5><p>起因是<code>tcp_receiver.hh/cc</code>中，关于<code>std::optional&lt;WrappingInt32&gt; ackno() const</code>报错：</p><blockquote><p>不允许使用限定名</p></blockquote><p>有点奇怪，之前没遇到过。查了一下<code>optional</code>发现这是C++17才有的，而且代码本身应该是没问题的，那应该是vscode c++扩展没有支持C++17。找到设置里面，搜索<code>cppstandard</code>，然后改成<code>c++ 17</code>即可。</p><h5 id="整体结构"><a href="#整体结构" class="headerlink" title="整体结构"></a>整体结构</h5><p>我们需要完成三个函数，主要的是<code>segment_received</code>。回忆我们的<code>stream_reassembler</code>，其中<code>push_substring</code>需要<code>string data/ size_t index/ bool eof</code>三个参数。而<code>segment</code>包括：<code>TCP header / data</code>。因此在接收到<code>segment</code>之后我们需要得到这些信息、然后调用<code>push_substring</code>函数。</p><p>那么现在逐渐变得清晰：</p><ul><li><p>得到<code>segment</code>的<code>SYN</code>字段，从而判断是否需要设置</p><ul><li>所以我们需要知道sponge 库里面TCP segment 提供的方法</li><li>另外，考虑到后续还需要用到<code>ISN</code>，所以有必要设置一个私有成员存储<code>ISN</code></li></ul></li><li><p>得到<code>FIN</code>字段，从而去结束<code>stream_reassembler</code></p></li><li><p>注意<code>push_substring</code>中<code>index</code>为<code>size_t</code>，我们需要将<code>int32_t</code>的sequence number转化成<code>int64_t</code>。这就需要调用<code>WrappingInt32</code>，并且我们需要知道<code>checkpoint</code>。提示：</p><blockquote><p>In your TCP implementation, you’ll use the index of the last reassembled byte as the checkpoint.</p></blockquote><p>这样也就是窗口左边的index——<code>_first_unreassembled</code>左边。</p></li><li><p>如何得到<code>data</code>？<code>tcp_segment</code>提供了接口：</p><div class="hljs"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">const</span> Buffer &amp;<span class="hljs-title">payload</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123; <span class="hljs-keyword">return</span> _payload; &#125;<span class="hljs-function">Buffer &amp;<span class="hljs-title">payload</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> _payload; &#125;</code></pre></div></li></ul><p>另外关于<code>optional</code>的使用，参考：</p><blockquote><p><a href="https://en.cppreference.com/w/cpp/utility/optional" target="_blank" rel="noopener">https://en.cppreference.com/w/cpp/utility/optional</a></p></blockquote><h5 id="segment-received的思路与细节"><a href="#segment-received的思路与细节" class="headerlink" title="segment_received的思路与细节"></a><code>segment_received</code>的思路与细节</h5><p>原本的思路过于简陋，存在很多bug。后续通过test修补了很多。</p><p><strong>debug：</strong></p><p>在<code>FIN = true</code>时，我们以为直接<code>push_substring</code>，由于<code>EOF = true</code>会使得重组器的<code>ByteTream _output</code>结束输入。但是事实上并没有——<code>_output</code>的输入结束必须是不存在unreassembled_segs。</p><p>回顾实验一中<code>push_substring</code>的定义：</p><blockquote><p><code>eof</code>: the last byte of this substring will be the last byte in the entire stream</p></blockquote><p>也就是说，<code>eof = true</code>仅仅说明当前的substring是最后的字符串。这是很符合实际的，由于网络延迟的存在，后续到来的substring可能是在该substring之前，我们当然应该将其reassembled而不是拒绝输入。</p><p>在<code>reassembled_bytes</code>中，我们的逻辑是这样的：</p><div class="hljs"><pre><code class="hljs c++"><span class="hljs-keyword">if</span>(eof)_eof = <span class="hljs-literal">true</span>;<span class="hljs-keyword">if</span>(_eof &amp;&amp; empty())_output.end_input();</code></pre></div><p>现在，我们在<code>FIN</code>之后到来的segment<strong>应该能够</strong>让<code>_output</code>结束输入。上面的逻辑是可以处理的。</p><p>排查发现<code>segment_received</code>里面多了第一行：</p><div class="hljs"><pre><code class="hljs c++"><span class="hljs-keyword">if</span>(_has_fin)<span class="hljs-keyword">return</span>;</code></pre></div><p>显然，并不能这样处理。删除之后即可。</p><h5 id="ackno-实现"><a href="#ackno-实现" class="headerlink" title="ackno()实现"></a><code>ackno()</code>实现</h5><blockquote><p>Returns anoptional<WrappingInt32>containing the sequence number of the first byte that the receiver doesn’t already know.  This is the windows’s left edge:  the first byte the receiveris interested in receiving.  If the ISN hasn’t been set yet, return an empty optional.</p></blockquote><p>初始版本：</p><div class="hljs"><pre><code class="hljs c++"><span class="hljs-function">optional&lt;WrappingInt32&gt; <span class="hljs-title">TCPReceiver::ackno</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;    <span class="hljs-keyword">if</span>(_has_syn)&#123;        <span class="hljs-keyword">size_t</span> tmp = <span class="hljs-number">1</span>;        <span class="hljs-comment">//firstly get the absolute sequence number </span>            <span class="hljs-comment">//normally just add 1 but if fin add 2 </span>        <span class="hljs-comment">//then using wrap -- translating the asn to sq</span>        <span class="hljs-keyword">if</span>(_has_fin &amp;&amp; _reassembler.unassembled_bytes() == <span class="hljs-number">0</span>)tmp = <span class="hljs-number">2</span>;        <span class="hljs-keyword">return</span> wrap(_reassembler.stream_out().bytes_written() + tmp, _ISN_peer);    &#125;    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-built_in">std</span>::nullopt;&#125;</code></pre></div><p>注释：</p><p>因为我们需要返回的是absolute seqno，因此是在stream index基础上增加一。而且需要考虑，如果<code>FIN</code>已经到达并且没有unassembled bytes，那么我们需要对<code>FIN</code>进行确认。当然，如果还存在unassembled bytes，那么ackno并不需要特别处理。</p><p><strong>报错：</strong></p><blockquote><p>Failure message:<br>        The TCPReceiver reported ackno <code>6</code>, but it was expected to be <code>7</code></p><p>List of steps that executed successfully:<br>        Initialized with (capacity=4000)<br>        Action:      segment arrives Header(flags=SF,seqno=5,ack=0,win=0)<br>        Expectation: in state <code>input to stream has ended</code></p></blockquote><p>test case如下：</p><p><img src="https://i.loli.net/2021/03/09/Cy3UPoYOX1i5eSu.png" srcset="/img/loading.gif" alt="image-20210309105109752"></p><p>结合<code>segment_received</code>代码可以确定，由于没有设置<code>_has_fin = true</code>导致<code>ackno</code>错误。</p><p><strong>报错：</strong></p><blockquote><p>Failure message:<br>        The TCPReceiver reported ackno <code>3836842352</code>, but it was expected to be <code>3836842365</code></p><p>List of steps that executed successfully:<br>        Initialized with (capacity=4000)<br>        Expectation: in state <code>waiting for SYN: ackno is empty</code><br>        Action:      segment arrives Header(flags=S,seqno=3836842351,ack=0,win=0) with data “Hello, CS144!”<br>        Expectation: in state <code>SYN received (ackno exists), and input to stream hasn&#39;t ended</code></p></blockquote><p>返回的<code>ackno</code>错误。可能的原因包括：</p><ul><li><code>bytes_written</code>错误，导致返回了错误的结果</li><li><code>segment_received</code>错误，即插入时设置的index错误，或者其他逻辑错误，导致<code>bytes_written</code>错误</li><li><code>wrap</code>用法错误</li></ul><p>通过在<code>ackno</code>函数中打印<code>bytes_written</code>得知其错误，输出值一直是0。</p><p>通过对比special case：SYN with data 和<code>segment_receive</code>，可以确认逻辑错误：此时得到的<code>abs_seqno</code>错误。增加对包含数据时SYN的特判即可。</p>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
      <category>CS144</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
      <tag>CS144</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CS144-02-Lab1</title>
    <link href="/2021/02/06/CS144-02-Lab1/"/>
    <url>/2021/02/06/CS144-02-Lab1/</url>
    
    <content type="html"><![CDATA[<hr><p>这次实验我们需要完成一个子串重组的类。因为我们的数据包被TCP Sender分割成很多的segments。我们需要在receiver处将其重组成完整的byte-stream。</p><p>首先，我们需要考虑大体上数据结构以及算法：</p><ul><li>substring到来随机，我们需要将其插入合适的位置。因此需要插入性能较好的结构。考虑到可能与前后的子串重合，因此需要方便地得到前后子串。</li><li>考虑到插入，那么树形结构比较合适。我们知道每个substring的index，因此可以据此进行排序。</li><li>考虑使用set。我们需要构建一个structure并且自定义如何比较以及排序方式。set支持双向迭代器，因此插入之后可以得到前后的元素进行操作。</li></ul><p>其次，如何去重？这里我们不需要考虑什么字符串匹配算法，因为我们知道index信息，根据前面元素的index以及长度结合当前元素的index就可以知道是否重合及其相应的处理方式。</p><p>另外，对于capacity的理解：</p><ul><li><p>我们有一个byte-stream——<code>_output</code>用于存储接收到并且组装好的segments。另外还有部分容量用于存储不与<code>_output</code>连续的子串。一旦连续自然也需要写入<code>_output</code></p></li><li><p>指导书上面的示意图：</p><p><img src="https://i.loli.net/2021/03/02/YLDScgfaBIdWiAw.png" srcset="/img/loading.gif" alt="image-20210302194203433"></p></li></ul><p>我们考虑一下index各种可能的情况：</p><ul><li>处于first unacceptable之后 那么直接丢弃</li><li>处于first unread之前 有可能其延申一直到first unassembled之后 仍然需要处理</li><li>处于first unread和first unassembled之间 同上 需要处理</li><li>处于first unassembled和first unacceptable之间 自然需要处理</li></ul><p>其中2/3两种情况本质是一样的，因为绿色部分已经完成，所以我们只需要截取first unassembled及其之后的部分即可。 继续这样的思路，我们应该先进行预处理、得到红色部分需要插入的substring再进行插入。当然，超出first unacceptable之后的就直接截断。</p><p>如何实现？</p><ul><li>我们必须记录<code>first_unread--_first_unread</code>。根据<code>_output.buffer_size()</code>便可以得到<code>first_unassembled</code>。</li></ul><p>现在，我们已经得到的需要插入的结构体了。</p><p>我们首先需要找到插入的位置——<code>lower_bound</code>返回第一个大于等于index的元素，之后不断尝试合并即可——这里我们考虑构建一个函数用于合并两个结构体。而且并不仅仅考虑后面的元素，<code>lower_bound</code>返回结果之前的可能也会产生重叠，需要判断。</p><p>更具体来说，如何设计这个函数？有很多种可能的方式：</p><ul><li>传入<code>set&lt;node&gt;::iterator</code>，根据迭代器得到元素进而进行比较，如果重叠那么修改待插入的结构体，删除<code>iterator</code>指向的结构体；<ul><li>我们是在函数内部删除还是在调用处删除？</li><li><a href="https://stackoverflow.com/questions/9726375/stdset-iterator-automatically-const" target="_blank" rel="noopener">https://stackoverflow.com/questions/9726375/stdset-iterator-automatically-const</a></li></ul></li><li>我们首先插入，然后直接修改<code>set&lt;node&gt;</code>。这样有一个弊端就是，我们并不能直接插入，因为可能存在相同的<code>index</code>——我们需要额外处理，但是如果只是处理这个相同<code>index</code>的元素那么在插入之后仍然需要与后续元素进行比较、处理，代码比较冗余；</li><li>注意如果能够合并，那么显然会影响<code>_unassembled_bytes</code>，如何实现？直接在内部修改还是传回返回值然后修改？</li></ul><p>其实除了上述的<code>set</code>方法之外，可能直接使用一个<code>string</code>也是可以的。我们可能需要一个<code>vector&lt;bool&gt;</code>进行标记<code>string</code>每一位是否是由<code>substring</code>占据。这样的好处是我们不需要比较繁琐的判断重叠、合并的操作，我们直接去填充<code>string</code>然后将标记为置为<code>true</code>即可。当然一开始为了保险起见用了<code>set</code>，写的过程当中就觉得<code>string</code>应该方便很多。</p><p>现在我们已经完成了讲个基本的数据结构——<code>byte_stream</code>和<code>stream_assembler</code>。</p><blockquote><p>目前尚未真正涉及TCP协议本身的内容，感觉像是完成了两道CSP模拟题。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
      <category>CS144</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
      <tag>CS144</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CS144-01-Lab0</title>
    <link href="/2021/01/30/CS144-01-Lab0/"/>
    <url>/2021/01/30/CS144-01-Lab0/</url>
    
    <content type="html"><![CDATA[<h4 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h4><h5 id="VSCode-Remote-Development"><a href="#VSCode-Remote-Development" class="headerlink" title="VSCode Remote Development"></a>VSCode Remote Development</h5><ul><li><p>随便搜了一些教程，按步骤操作即可。</p><p><img src="C:\Users\28425\AppData\Roaming\Typora\typora-user-images\image-20210131143446968.png" srcset="/img/loading.gif" alt="image-20210131143446968" style="zoom: 50%;" /></p></li><li><p>中间自动推荐了C++相关插件，安装即可。</p></li></ul><h5 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h5><ul><li><p>安装</p><div class="hljs"><pre><code class="hljs html">git config --global user.name "xxx" // user.email "xxx"</code></pre></div></li><li><p>关联远程仓库并推送</p><div class="hljs"><pre><code class="hljs xml">git remote -v可以看到已经存在的仓库 因为是从CS144的官方clone下来的git remote add qscs144 URL git add .git commit -mgit push qscs144 master</code></pre></div></li><li><p>配置SSH相关。注意ubuntu启动ssh agent: <code>exec ssh-agent bash</code></p></li></ul><h4 id="正式实验"><a href="#正式实验" class="headerlink" title="正式实验"></a>正式实验</h4><h5 id="webget-cc"><a href="#webget-cc" class="headerlink" title="webget.cc"></a>webget.cc</h5><p>我们的目标是实现<code>void get_URL(const string &amp;host, const string &amp;path)</code>函数。</p><p>具体来说：</p><ul><li><p>理解基本的socket编程</p></li><li><p>阅读sponge库 知道对应的接口</p></li></ul><div class="hljs"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">get_URL</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span> &amp;host, <span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span> &amp;path)</span> </span>&#123;    TCPSocket soct;    soct.<span class="hljs-built_in">connect</span>(Address(host, <span class="hljs-string">"http"</span>));    <span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span> httpDatagram = <span class="hljs-string">"GET "</span> + path + <span class="hljs-string">" HTTP/1.1\r\n"</span> +                                 <span class="hljs-string">"Host: "</span> + host + <span class="hljs-string">"\r\n\r\n"</span>;    soct.<span class="hljs-built_in">write</span>(httpDatagram);    soct.<span class="hljs-built_in">shutdown</span>(SHUT_WR);    <span class="hljs-keyword">while</span>(!soct.eof())        <span class="hljs-built_in">cout</span>&lt;&lt;soct.<span class="hljs-built_in">read</span>();    soct.<span class="hljs-built_in">close</span>();    <span class="hljs-keyword">return</span>;&#125;</code></pre></div><p><img src="https://i.loli.net/2021/02/01/jRvxaIM3UEVYmbc.png" srcset="/img/loading.gif" alt="image-20210201182035652" style="zoom:67%;" /></p><p><img src="https://i.loli.net/2021/02/01/ihq8ZB2t4op5dcu.png" srcset="/img/loading.gif" alt="image-20210201182059748" style="zoom:67%;" /></p><h5 id="an-in-memory-reliable-byte-stream"><a href="#an-in-memory-reliable-byte-stream" class="headerlink" title="an in-memory reliable byte stream"></a>an in-memory reliable byte stream</h5><p>在上面的实验中我们可以看到socket提供给用户的感觉就是能够将字节可靠地通过网络在主机之间进行交互。这里我们需要实现一个单线程的、位于内存的byte stream。</p><p>要求：</p><ul><li>有序 FIFO</li><li>初始化时固定容量</li><li>控制输入操作</li></ul><p>如何实现？思路：</p><ul><li>最初根据FIFO第一反应是直接使用<code>queue</code>。但是我们<code>read/write</code>的对象都是<code>string</code>，而且有时需要根据字节长度去读取，因此使用<code>queue</code>比较麻烦——需要不断地去遍历得到指定长度的<code>string</code></li><li>直接使用一个<code>string</code>对象？所有的操作直接在这个对象上进行。感觉比较方便。</li></ul><blockquote><p><code>string</code>与字符、字节之间的关系</p></blockquote><p>具体代码比较简单。</p><h4 id="关于构建"><a href="#关于构建" class="headerlink" title="关于构建"></a>关于构建</h4><ul><li><p>注意，这里我们必须列表初始化成员：</p><blockquote><p>‘ByteStream::_BStream’ should be initialized in the member initialization list [-Werror=effc++]</p></blockquote></li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
      <category>CS144</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
      <tag>CS144</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MIT6.828-02-Lab1</title>
    <link href="/2021/01/27/MIT6-828-02-Lab1/"/>
    <url>/2021/01/27/MIT6-828-02-Lab1/</url>
    
    <content type="html"><![CDATA[<h4 id="Part1-PC-Bootstrap"><a href="#Part1-PC-Bootstrap" class="headerlink" title="Part1: PC Bootstrap"></a>Part1: PC Bootstrap</h4><h5 id="熟悉x86汇编"><a href="#熟悉x86汇编" class="headerlink" title="熟悉x86汇编"></a>熟悉x86汇编</h5><ul><li><p><a href="https://www.ibm.com/developerworks/cn/linux/l-assembly/" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/linux/l-assembly/</a> 介绍了Linux环境下基本的AT&amp;T风格的汇编</p><p>在编写<code>hello.s</code>之后<code>as -o hello.o hello.s</code>提示：</p><blockquote><p>hello.s: Assembler messages:<br>hello.s: Warning: end of file not at end of a line; newline inserted</p></blockquote><p>在<code>hello.s</code>末尾添加新行即可。<strong>WHY</strong></p><p>另外介绍了inline assembly的基本用法，有点好玩，GCC的支持使得我们可以直接在C语言中直接写汇编。</p></li><li><p><a href="https://pdos.csail.mit.edu/6.828/2018/readings/i386/toc.htm" target="_blank" rel="noopener">80386 Programmer’s Reference Manual</a> 包括从基本的计算机组成到x86 assembly，1.2介绍了历史发展，可以与操作系统的知识结合在一起：从段式分配到页式分配。另外appendix里面包括了80x86 instructions，比较方便。</p></li></ul><h5 id="启动过程"><a href="#启动过程" class="headerlink" title="启动过程"></a>启动过程</h5><ul><li><p><strong>Exercise 2</strong>： Use GDB’s si (Step Instruction) command to trace into the ROM BIOS for a few more instructions, and try to guess what it might be doing.</p><p>首先我们想知道电脑启动的整体过程。<a href="https://medium.com/an-idea/the-not-so-magic-of-how-your-computer-boots-up-2f5e8289451d" target="_blank" rel="noopener">这篇文章介绍了大致过程</a> </p><p>其次使用<code>si</code>去看具体执行了那些命令。</p></li></ul><h4 id="Part2-The-Boot-Loader"><a href="#Part2-The-Boot-Loader" class="headerlink" title="Part2: The Boot Loader"></a>Part2: The Boot Loader</h4><ul><li><p><img src="https://i.loli.net/2021/01/30/vEmgqHpltSQM5CA.png" srcset="/img/loading.gif" alt="image-20210130160415527"></p><p>上图中，左边是使用GDB单步执行的过程，右边是boot.S。</p></li></ul><h5 id="理解boot-loader-source-code"><a href="#理解boot-loader-source-code" class="headerlink" title="理解boot loader source code"></a>理解boot loader source code</h5>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
      <category>MIT6.828</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
      <tag>MIT6.828</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MIT6.828-01-环境配置与工具使用</title>
    <link href="/2021/01/27/MIT6.828-01-%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    <url>/2021/01/27/MIT6.828-01-%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h4 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h4><blockquote><p>Ubuntu 18.04</p></blockquote><p>这门课实验的最终目标是实现一个微内核操作系统JOS，它是在xv6的基础上改写的。xv6是运行在x86架构上的用于教学的类UNIX操作系统。因此，一方面我们需要利用QEMU来运行xv6，另一方面需要编译工具链来对内核进行编译。官方给的指导：<a href="https://pdos.csail.mit.edu/6.828/2018/tools.html" target="_blank" rel="noopener">https://pdos.csail.mit.edu/6.828/2018/tools.html</a></p><p>事实上这中间可能会遇到一些问题，例如：</p><p><code>make &amp;&amp; make install</code>之后报错：</p><div class="hljs"><pre><code class="hljs html">qga/commands-posix.c: In function ‘dev_major_minor’:qga/commands-posix.c:633:13: error: In the GNU C Library, "major" is defined by <span class="hljs-tag">&lt;<span class="hljs-name">sys</span>/<span class="hljs-attr">sysmacros.h</span>&gt;</span>. For historical compatibility, it is currently defined by <span class="hljs-tag">&lt;<span class="hljs-name">sys</span>/<span class="hljs-attr">types.h</span>&gt;</span> as well, but we plan to remove this soon. To use "major", include <span class="hljs-tag">&lt;<span class="hljs-name">sys</span>/<span class="hljs-attr">sysmacros.h</span>&gt;</span> directly. If you did not intend to use a system-defined macro "major", you should undefine it after including <span class="hljs-tag">&lt;<span class="hljs-name">sys</span>/<span class="hljs-attr">types.h</span>&gt;</span>. [-Werror]         *devmajor = major(st.st_rdev);             ^~~~~~~~~~~~~~~~~~~~~~~~~~  qga/commands-posix.c:634:13: error: In the GNU C Library, "minor" is defined by <span class="hljs-tag">&lt;<span class="hljs-name">sys</span>/<span class="hljs-attr">sysmacros.h</span>&gt;</span>. For historical compatibility, it is currently defined by <span class="hljs-tag">&lt;<span class="hljs-name">sys</span>/<span class="hljs-attr">types.h</span>&gt;</span> as well, but we plan to remove this soon. To use "minor", include <span class="hljs-tag">&lt;<span class="hljs-name">sys</span>/<span class="hljs-attr">sysmacros.h</span>&gt;</span> directly. If you did not intend to use a system-defined macro "minor", you should undefine it after including <span class="hljs-tag">&lt;<span class="hljs-name">sys</span>/<span class="hljs-attr">types.h</span>&gt;</span>. [-Werror]         *devminor = minor(st.st_rdev);             ^~~~~~~~~~~~~~~~~~~~~~~~~~</code></pre></div><p>好在一般前人都踩过坑，Google一下直接照葫芦画瓢即可。</p><p>注：官方QEMU安装教程里面给出的提示，看到网上一些教程貌似没有注意到这里踩了挺多坑。</p><blockquote><p>On Linux, you may need to install several libraries. We have successfully built 6.828 QEMU on Debian/Ubuntu 16.04 after installing the following packages: libsdl1.2-dev, libtool-bin, libglib2.0-dev, libz-dev, and libpixman-1-dev</p></blockquote><h4 id="工具使用"><a href="#工具使用" class="headerlink" title="工具使用"></a>工具使用</h4><h5 id="QEMU"><a href="#QEMU" class="headerlink" title="QEMU"></a>QEMU</h5><ul><li>之前做CS:APP MIPS版本的bomb lab时使用过。主要是模拟硬件，这门课程中模拟了一个32位x86平台。</li></ul><h5 id="GDB"><a href="#GDB" class="headerlink" title="GDB"></a>GDB</h5><ul><li>用得不多，没有系统学过。</li></ul>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
      <category>MIT6.828</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
      <tag>6.828</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
