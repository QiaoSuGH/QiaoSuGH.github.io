<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>字符串相关</title>
    <link href="/2021/04/20/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E5%85%B3/"/>
    <url>/2021/04/20/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E5%85%B3/</url>
    
    <content type="html"><![CDATA[<h4 id="最小表示法"><a href="#最小表示法" class="headerlink" title="最小表示法"></a>最小表示法</h4><h5 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h5><p>找出循环同构的字符串中字典序最小的循环起点。</p><h5 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h5><div class="hljs"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>, i = <span class="hljs-number">0</span>, j = <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span> (k &lt; n &amp;&amp; i &lt; n &amp;&amp; j &lt; n) &#123;  <span class="hljs-keyword">if</span> (sec[(i + k) % n] == sec[(j + k) % n]) &#123;    k++;  &#125; <span class="hljs-keyword">else</span> &#123;    sec[(i + k) % n] &gt; sec[(j + k) % n] ? i = i + k + <span class="hljs-number">1</span> : j = j + k + <span class="hljs-number">1</span>; <span class="hljs-comment">//*</span>    <span class="hljs-keyword">if</span> (i == j) i++;    k = <span class="hljs-number">0</span>;  &#125;&#125;i = <span class="hljs-built_in">min</span>(i, j);</code></pre></div><h5 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h5><ul><li><p>如果进入<code>*</code>式，说明之前的都相等，那么如果<code>sec[i+k] &gt; sec[j+k]</code>，则以从<code>i</code>到<code>k</code>为起点的循环串必然不可能字典序最小。</p></li><li><p>这里之所以取两者中的较小者，是考虑到两者均有可能成为答案。结束时，如果是因为<code>i/j</code>到达<code>n</code>，那么说明其中较小者才是答案——较大者仍然在尝试移动。</p><p>如果是因为<code>k</code>才结束循环，说明此时<code>sec[i] == sec[j]</code>（<code>k</code>从0开始），且之后的一致相等，那么两者均为答案，取较小者不影响正确性。</p></li><li><p>如果两者相等，需要错开继续判断。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
      <tag>算法</tag>
      
      <tag>字符串</tag>
      
      <tag>最小表示法</tag>
      
      <tag>字典序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Nachos-03-文件系统</title>
    <link href="/2021/04/19/Nachos-03-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
    <url>/2021/04/19/Nachos-03-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<h4 id="Nachos硬盘与文件系统"><a href="#Nachos硬盘与文件系统" class="headerlink" title="Nachos硬盘与文件系统"></a>Nachos硬盘与文件系统</h4><h5 id="创建硬盘"><a href="#创建硬盘" class="headerlink" title="创建硬盘"></a>创建硬盘</h5><p>入口：<code>\#ifdef FILESYS synchDisk = new SynchDisk(&quot;DISK&quot;);\#endif</code></p><p>我们的硬盘对应的类为<code>Disk</code>，考虑到并发访问以及阻塞之后唤醒的问题，我们又封装了一层形成了<code>SynchDisk</code>类。因此创建硬盘时在初始化<code>SynchDisk</code>的过程中初始化<code>Disk</code>。：</p><div class="hljs"><pre><code class="hljs c++">SynchDisk::SynchDisk(<span class="hljs-keyword">char</span>* name)&#123;    semaphore = <span class="hljs-keyword">new</span> Semaphore(<span class="hljs-string">"synch disk"</span>, <span class="hljs-number">0</span>);    lock = <span class="hljs-keyword">new</span> Lock(<span class="hljs-string">"synch disk lock"</span>);    disk = <span class="hljs-keyword">new</span> Disk(name, DiskRequestDone, (_int) <span class="hljs-keyword">this</span>);&#125;</code></pre></div><p>解释：</p><ul><li>这里的<code>DiskRequestDone</code>为中断处理函数，参数即为<code>(_int) this</code>。真正执行时将<code>this</code>再转换成指向<code>SynchDisk</code>的指针，然后调用类方法<code>RequestDone()</code>，执行信号量的<code>v()</code>操作。</li><li><code>Disk</code>的构造并不复杂，主要是判断文件是否存在——不存在则创建；并完成魔数的处理；将0写入到文件末尾避免EOF。</li></ul><h5 id="格式化"><a href="#格式化" class="headerlink" title="格式化"></a>格式化</h5><p>在以<code>-f</code>参数运行、进入<code>Initialize()</code>函数之后，<code>format</code>值为<code>true</code>，因此进入文件系统的初始化过程。</p><blockquote><p>// FileSystem::FileSystem</p><p>// Initialize the file system. If format = TRUE, the disk has nothing on it, and we need to initialize the disk to contain</p><p>// an empty directory, and a bitmap of free sectors (with almost but not all of the sectors marked as free). </p></blockquote><div class="hljs"><pre><code class="hljs c++"><span class="hljs-built_in">FileSystem</span>::<span class="hljs-built_in">FileSystem</span>(<span class="hljs-keyword">bool</span> format)&#123;     DEBUG(<span class="hljs-string">'f'</span>, <span class="hljs-string">"Initializing the file system.\n"</span>);    <span class="hljs-keyword">if</span> (format) &#123;        BitMap *freeMap = <span class="hljs-keyword">new</span> BitMap(NumSectors); <span class="hljs-comment">//NumSectors定义在disk.h当中，32磁道*每磁道32扇区</span>        Directory *directory = <span class="hljs-keyword">new</span> Directory(NumDirEntries); <span class="hljs-comment">//NumDirEntries为10</span>FileHeader *mapHdr = <span class="hljs-keyword">new</span> FileHeader; <span class="hljs-comment">//文件头 即FCB</span>FileHeader *dirHdr = <span class="hljs-keyword">new</span> FileHeader;</code></pre></div><p>解释：</p><ul><li><p><code>BitMap</code>底层结构就是一个<code>int</code>数组，定义了一些函数从而方便位级别的操作。用于表示空闲的扇区。</p></li><li><p><code>Directory</code>就是目录，包括诸多目录项——这里是10个，意味着我们只能有10个文件。</p><div class="hljs"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DirectoryEntry</span> &#123;</span>  <span class="hljs-keyword">public</span>:    <span class="hljs-keyword">bool</span> inUse;<span class="hljs-comment">// Is this directory entry in use?</span>    <span class="hljs-keyword">int</span> sector;<span class="hljs-comment">// Location on disk to find the </span><span class="hljs-comment">//   FileHeader for this file </span>    <span class="hljs-keyword">char</span> name[FileNameMaxLen + <span class="hljs-number">1</span>];<span class="hljs-comment">// Text name for file, with +1 for </span><span class="hljs-comment">// the trailing '\0'</span>&#125;;Directory::Directory(<span class="hljs-keyword">int</span> <span class="hljs-built_in">size</span>)&#123;    table = <span class="hljs-keyword">new</span> DirectoryEntry[<span class="hljs-built_in">size</span>];    tableSize = <span class="hljs-built_in">size</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; tableSize; i++)table[i].inUse = FALSE;&#125;</code></pre></div></li><li><p>注意代码中我们有这样的逻辑：<code>freeMapFile = new OpenFile(FreeMapSector); freeMap-&gt;WriteBack(freeMapFile);</code>。</p><p>这是因为<code>freeMap</code>只是我们内存中的对象，但是尚未写入磁盘，在调用<code>writeBack</code>之后才是真正写入。</p></li></ul><h5 id="具体操作"><a href="#具体操作" class="headerlink" title="具体操作"></a>具体操作</h5><p><code>Disk::ReadRequest/WriteRequest</code></p><ul><li>通过<code>Read/WriteFile</code>函数来模拟磁盘读取的物理操作</li><li>整体逻辑是首先计算出访问时间——包括寻道时间、旋转延迟、传输时间。在函数末尾（实际上此时已经完成了读取），添加一个中断——时间是访问时间，这个中断实际上执行的就是将<code>active</code>置为<code>false</code>，表示操作结束，并且最终执行<code>SynchDisk::RequestDone()</code>。从而这样模拟了花费一段时间的读取操作。</li></ul><p><code>SynchDisk::ReadSector/WriteSector</code></p><ul><li>通过互斥锁来确保对<code>Disk</code>的互斥访问，通过信号量来实现阻塞唤醒——上面的逻辑。</li></ul><h4 id="命令测试"><a href="#命令测试" class="headerlink" title="命令测试"></a>命令测试</h4><h5 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h5><ul><li><p><a href="https://man7.org/linux/man-pages/man1/hexdump.1.html" target="_blank" rel="noopener">hexdump</a></p><p>仅仅查看魔数：<code>hd  -n 4 DISK</code></p></li><li><p><a href="https://man7.org/linux/man-pages/man1/od.1.html" target="_blank" rel="noopener">od</a></p></li></ul><h5 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h5><ul><li><p><code>-D</code>：</p><p><img src="https://i.loli.net/2021/04/19/jov6D3dWFXIYZRC.png" srcset="/img/loading.gif" alt="image-20210419164856376" style="zoom: 50%;" /></p></li><li><p><code>-cp test/small small</code></p><p><img src="https://i.loli.net/2021/04/19/gI9hBcOj7TwUuCe.png" srcset="/img/loading.gif" alt="image-20210419165819294" style="zoom:67%;" /></p><p><img src="https://i.loli.net/2021/04/19/Rnb8aCwVprh7Nxv.png" srcset="/img/loading.gif" alt="image-20210419165931544"></p><p>可以看到命令成功执行了。</p><p>之后执行<code>-cp test/medium medium</code>同样成功</p></li><li><p><code>-cp test/big big</code></p><p><img src="https://i.loli.net/2021/04/19/a1eZXYMJtKRScEV.png" srcset="/img/loading.gif" alt="image-20210419170747228" style="zoom:67%;" /></p><p><img src="https://i.loli.net/2021/04/19/54DBj3vsfNXzY7R.png" srcset="/img/loading.gif" alt="image-20210419170829843" style="zoom: 67%;" /></p><p>根据上图可知，第10扇区是big文件的文件头，由于连续分配的策略，之后的11/12/13均是big文件的具体内容。</p><p><img src="https://i.loli.net/2021/04/19/oDkRvpzi4OCYLry.png" srcset="/img/loading.gif" alt="image-20210419171257794" style="zoom: 67%;" /></p><p><img src="https://i.loli.net/2021/04/19/5Xw9kH814Dhx2R3.png" srcset="/img/loading.gif" alt="image-20210419171235921" style="zoom: 67%;" /></p></li><li><p><code>-r small</code></p><p>连续删除small、big之后：</p><p><img src="https://i.loli.net/2021/04/19/eiYWDBr17EFvjmq.png" srcset="/img/loading.gif" alt="image-20210419171656448"></p></li></ul><h4 id="扩展文件系统"><a href="#扩展文件系统" class="headerlink" title="扩展文件系统"></a>扩展文件系统</h4><h5 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h5><p>首先梳理一下Nachos文件系统的整体结构：</p><ul><li>磁盘类为<code>Disk</code>和<code>synchDisk</code>，后者封装了前者，并且提供了两个基本的接口：以sector为单位进行读写。</li><li>位图、根目录表用于管理文件，后者包括了所有文件文件头的所在扇区。文件头包括基本的分配、取消分配以及针对文件头的<code>FetchFrom/WriteBack</code>。</li><li><code>OpenFile</code>根据文件头的信息对文件进行读写操作——底层都是调用<code>synchDisk</code>。</li><li><code>FileSystem</code>提供了更为上层的接口，包括初始化文件系统、创建删除文件等。</li></ul><p>如何实现从文件的任意位置添加数据：</p><ul><li>首先我们明确，因为只有文件头拥有文件占用的扇区、文件长度等信息，所以应该扩展<code>OpenFile</code>的写操作。其中<code>write</code>又是对<code>writeAt</code>的封装，因此核心在于<code>writeAt</code>函数。</li><li>原本的实现约束了对文件的扩展——一旦写入长度大于目前文件长度就拒绝执行。因此需要去除这些限制。</li><li><p>扩展可以简单的分为两种：</p><ul><li>最后一个扇区的空闲位置已经足够，不需要再分配扇区</li><li>写满最后扇区之后，仍然需要分配<ul><li>可能由于没有足够的扇区或者文件大小超过30个扇区导致失败</li></ul></li></ul></li><li><p><strong>如何判断是否有足够的空间分配给新来的数据？</strong></p><ul><li>一方面我们需要文件系统的位图的信息，直接的做法是新建一个位图实例和打开文件的实例，前者以后者为参数调用<code>FetchFrom</code>得到文件系统的位图。更加美观的做法是，直接扩展我们的文件系统类，让其提供<code>getBitMap</code>方法从而方便我们直接得到位图。</li><li>另一方面需要结合当前文件的信息判断能否继续分配以及怎样分配扇区——这需要文件头去操作——通过当前<code>OpenFile</code>实例对应的文件头（私有成员<code>hdr</code>）进行相关逻辑的处理。<ul><li>这里我们重载了文件头类的<code>Allocate</code>方法。如果可以正常进行返回<code>true</code>。</li></ul></li></ul></li><li>重载的<code>Allocate</code>方法逻辑非常清晰，主要有三部分：<ul><li>如果文件当前大小为0并且需要写入数据，先暂时分配一个扇区，从而与后续逻辑保持一致。</li><li>判断最后一个扇区空闲空间是否足够，足够的话那么无需分配。</li><li>不足，需要分配，尝试分配。失败的可能包括：文件过大；没有足够的空闲磁盘块。</li></ul></li><li>如果分配成功，那么需要将修改后的位图写回磁盘。</li><li>之后就是写入过程了，与原本的逻辑一致，不用改动。</li></ul><p>如何实现文件初始时大小为0？</p><ul><li>很简单，从文件头入手，构造函数内部将文件大小修改为0即可。</li></ul><h5 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h5><p>首先在small之后添加small（见DEBUG截图），之后再次添加big文件：</p><p><img src="https://i.loli.net/2021/04/20/6BADFapk8bMzTE1.png" srcset="/img/loading.gif" alt="image-20210420152541719" style="zoom: 50%;" /></p><p>可见，确实是在将原本文件所在扇区写满之后再分配新的扇区。因为目前我们只有一个文件，所以位图分配的结果就是连续的。</p><p>接着我们测试在small中间写入medium：</p><p><img src="https://i.loli.net/2021/04/20/5b3excA6lVT4gKo.png" srcset="/img/loading.gif" alt="image-20210420152802319" style="zoom: 50%;" /></p><p>验证删除机制：</p><p>定义：<code>FileSystem::Remove(char *name)</code>。逻辑如下：</p><ul><li><p>首先读取1号扇区的跟目录表文件，接着寻找文件头所在扇区</p><ul><li>底层依靠的是目录表的<code>FindeIndex</code>，遍历<code>table</code>，如果在使用且名字相同，那么返回对应的index。<code>Find</code>函数根据index返回文件头所在扇区。</li></ul></li><li><p>因为我们只有文件头存储了文件所在扇区的信息，所以需要依靠文件头调用<code>Deallocate</code>从而清除位图对应位。</p><ul><li><p>这里清除调用的是位图的<code>clear</code>函数，实现很简单：</p><div class="hljs"><pre><code class="hljs c++"><span class="hljs-keyword">void</span> BitMap::Clear(<span class="hljs-keyword">int</span> which) &#123;    ASSERT(which &gt;= <span class="hljs-number">0</span> &amp;&amp; which &lt; numBits);    <span class="hljs-comment">//将对应位置为1，其它位均为0，那么取反之后相与即可</span>    <span class="hljs-built_in">map</span>[which / BitsInWord] &amp;= ~(<span class="hljs-number">1</span> &lt;&lt; (which % BitsInWord)); &#125;</code></pre></div></li></ul></li><li><p>另外，还需要清除位图中的文件头对应位，清除目录表中对应的目录项——将<code>table</code>中对应的项<code>inUse</code>置为<code>false</code>即可。</p></li></ul><p>那么，预期就是尽管删除了文件、<code>-D</code>不会显示文件，但是使用<code>hexdump -C DISK</code>依然可以看到已经删除的文件（只要没被覆盖）。</p><p>首先初始化文件系统，然后复制test/small至small：</p><p><img src="https://i.loli.net/2021/04/20/tEXbyAOd3nagl4v.png" srcset="/img/loading.gif" alt="image-20210420155003241" style="zoom:67%;" /></p><p><img src="https://i.loli.net/2021/04/20/KX6UTgy9QjRLVZl.png" srcset="/img/loading.gif" alt="image-20210420155052975" style="zoom:67%;" /></p><p>接着删除：</p><p><img src="https://i.loli.net/2021/04/20/jMbtROfFgKn4qu6.png" srcset="/img/loading.gif" alt="image-20210420155130906" style="zoom:67%;" /></p><p>文件系统中已经没有了。但是通过<code>hexdump</code>还可以看到内容：</p><p><img src="https://i.loli.net/2021/04/20/cZN9fn2eRyP4UCp.png" srcset="/img/loading.gif" alt="image-20210420155221978" style="zoom:67%;" /></p><h5 id="DEBUG"><a href="#DEBUG" class="headerlink" title="DEBUG"></a>DEBUG</h5><p>发现在<code>-ap test/small small</code>之后报错，提示没有足够的空间或者文件过大。显然这不应该出现。</p><p>考虑到只有<code>writeAt</code>返回<code>-1</code>时才会出现这样的提示，而其中：</p><div class="hljs"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> ((numBytes &lt;= <span class="hljs-number">0</span>) || (<span class="hljs-built_in">position</span> &gt;= fileLength))<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<span class="hljs-comment">// check request</span></code></pre></div><p>经过测试，<code>numBBytes</code>没有问题，说明后者出现问题。通过输出信息可以确定原因是<code>position == fileLength</code>：</p><p><img src="https://i.loli.net/2021/04/20/Gi1KHdsMqj7UF2e.png" srcset="/img/loading.gif" alt="image-20210420121120587" style="zoom:80%;" /></p><p>注意之前的写操作导致<code>position == fileLength</code>。因此不合法的情况应该是<code>position &gt; fileLength</code>。相等时应该进行文件的扩展。</p><p>重新编译测试，正确：</p><p><img src="https://i.loli.net/2021/04/20/a9Myrlo7jzIf4DJ.png" srcset="/img/loading.gif" alt="image-20210420122031247" style="zoom:80%;" /></p><p><img src="https://i.loli.net/2021/04/20/BnJxEkPRNtIljb2.png" srcset="/img/loading.gif" alt="image-20210420122103862" style="zoom:80%;" /></p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
      <category>Nachos</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
      <tag>Nachos</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>分布式系统整体框架</title>
    <link href="/2021/04/17/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E6%95%B4%E4%BD%93%E6%A1%86%E6%9E%B6/"/>
    <url>/2021/04/17/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E6%95%B4%E4%BD%93%E6%A1%86%E6%9E%B6/</url>
    
    <content type="html"><![CDATA[<h4 id="CAP理论"><a href="#CAP理论" class="headerlink" title="CAP理论"></a>CAP理论</h4><h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h5><h5 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h5><h4 id="一致性协议raft"><a href="#一致性协议raft" class="headerlink" title="一致性协议raft"></a>一致性协议raft</h4><h4 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h4><h4 id="分布式缓存"><a href="#分布式缓存" class="headerlink" title="分布式缓存"></a>分布式缓存</h4>]]></content>
    
    
    <categories>
      
      <category>分布式系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MapReduce</tag>
      
      <tag>分布式系统</tag>
      
      <tag>MIT6.824</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CS144-06-关于Sponge</title>
    <link href="/2021/04/17/CS144-06-%E5%85%B3%E4%BA%8ESponge/"/>
    <url>/2021/04/17/CS144-06-%E5%85%B3%E4%BA%8ESponge/</url>
    
    <content type="html"><![CDATA[<p>一个核心问题在于，<code>CS144TCPSocket</code>究竟是如何工作的？我们熟悉了这里TCP的逻辑，但是真正通信还需要两方面的支持：</p><ul><li>上层：<code>CS144TCPSocket</code>是如何封装的？</li><li>下层：这里实际上也实现了<code>IPV4</code>协议，如何使用的？<code>TUN/TAP</code>是如何使用的？</li></ul><hr><p>关于tun/tap：</p><p><a href="https://www.cnblogs.com/bakari/p/10474600.html" target="_blank" rel="noopener">https://www.cnblogs.com/bakari/p/10474600.html</a></p>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
      <category>CS144</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
      <tag>CS144</tag>
      
      <tag>TUN</tag>
      
      <tag>TAP</tag>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MIT6.824-Lab1-MapReduce</title>
    <link href="/2021/04/16/MIT6-824-Lab1-MapReduce/"/>
    <url>/2021/04/16/MIT6-824-Lab1-MapReduce/</url>
    
    <content type="html"><![CDATA[<h5 id="分布式系统的特性"><a href="#分布式系统的特性" class="headerlink" title="分布式系统的特性"></a>分布式系统的特性</h5><ul><li><p>可扩展性——性能</p></li><li><p>容错</p><ul><li>可用性</li><li>自我可恢复性</li></ul><p>工具：非易失存储；复制</p></li><li><p>一致性</p><ul><li>强一致性：确保读取到的总是最新的数据；需要很高的代价</li><li>弱一致性</li></ul></li></ul><h5 id="Go语言层面"><a href="#Go语言层面" class="headerlink" title="Go语言层面"></a>Go语言层面</h5><ul><li><p>插件的使用</p><p><code>go build -buildmode = plugin ...</code></p><blockquote><p>Plguin 需要有自己的 main package<br>编译的时候，使用 go build -buildmode=plugin file.go 来编译<br>使用 plugin.Open(path string) 来打开.so文件，同一插件只能打开一次，重复打开会报错<br>使用 plugin.LookUp(name string) 来获取插件中对外暴露的方法或者类型<br>使用类型断言，断言后执行相应的方法</p></blockquote><p><code>mrsequential.loadPlugin</code>体现了上面的步骤。</p></li></ul><h5 id="本地的顺序执行的MR"><a href="#本地的顺序执行的MR" class="headerlink" title="本地的顺序执行的MR"></a>本地的顺序执行的MR</h5>]]></content>
    
    
    <categories>
      
      <category>分布式系统</category>
      
      <category>MIT6.824</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MapReduce</tag>
      
      <tag>分布式系统</tag>
      
      <tag>MIT6.824</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go-13-MESI协议与原子操作</title>
    <link href="/2021/04/15/Go-13-MESI%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C/"/>
    <url>/2021/04/15/Go-13-MESI%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<h3 id="MESI协议"><a href="#MESI协议" class="headerlink" title="MESI协议"></a>MESI协议</h3><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><ul><li><p><a href="https://en.wikipedia.org/wiki/MESI_protocol" target="_blank" rel="noopener">MESI维基百科</a></p></li><li><p><a href="https://en.wikipedia.org/wiki/Cache_coherence" target="_blank" rel="noopener">缓存一致性维基百科</a></p></li></ul><h4 id="状态转移"><a href="#状态转移" class="headerlink" title="状态转移"></a>状态转移</h4><p>维基百科已经给出了状态机以及响应的解释，这里记录一点点更详细的解释作为补充。P：CPU。</p><p><img src="https://i.loli.net/2021/04/15/rGN9UfKpV1Dxca5.png" srcset="/img/loading.gif" alt="image-20210415202913308" style="zoom:67%;" /></p><p>注：黑色表示P引起的转移，<strong>/</strong>后面的表示向总线发出的信号。</p><blockquote><p>Processor Requests to Cache includes the following operations:</p><ol><li>PrRd: The processor requests to <strong>read</strong> a Cache block.</li><li>PrWr: The processor requests to <strong>write</strong> a Cache block</li></ol><p>Bus side requests are the following:</p><ol><li>BusRd: Snooped request that indicates there is a <strong>read</strong> request to a Cache block requested by another processor</li><li>BusRdX: Snooped request that indicates there is a <strong>write</strong> request to a Cache block requested by another processor that <strong>doesn’t already have the block.</strong></li><li>BusUpgr: Snooped request that indicates that there is a write request to a Cache block requested by another processor but that processor already has that <strong>Cache block residing in its own Cache</strong>.</li><li>Flush: Snooped request that indicates that an entire cache block is written back to the main memory by another processor.</li><li>FlushOpt: Snooped request that indicates that an entire cache block is posted on the bus in order to supply it to another processor(Cache to Cache transfers).</li></ol></blockquote><h5 id="状态I"><a href="#状态I" class="headerlink" title="状态I"></a>状态I</h5><ul><li><p>如果是所在P发出的PrRd，那么会向总线发出信号BusRd。其他cache检查是否有并返回响应的信号。</p><ul><li>如果其他cache有valid copy，那么通过bus发送值，当前cache会被更新，状态转为<strong>S</strong></li><li>否则，会从main memory取值进行更新，状态转为<strong>E</strong></li></ul></li><li><p>如果是收到来自bus的请求：BusRd，直接忽略。</p></li><li><p>如果是PrWr，状态转变为<strong>M</strong>，其他缓存如果存有copy那么失效。</p></li></ul><h5 id="实现LOCK指令"><a href="#实现LOCK指令" class="headerlink" title="实现LOCK指令"></a>实现LOCK指令</h5><p>为什么保持住M、E状态即可？</p><ul><li><p>如果当前状态为I——假设为写操作，向总线发送<code>BusRdX</code>，如果其他缓存有copy，例如如果是M状态，那么会<code>Put FlushOpt on Bus with data.Received by sender of BusRdx and Memory Controller, which writes to Main memory.</code>同时状态变为I。而当前cache line变为M。</p><p><u>看到有资料介绍说也是让其他的失效，但是不确定正确性。</u></p></li><li><p>如果当前状态为s——让其他的失效即可。</p></li><li><p>如果为M或者E，那么是独占的，<u>需要解决的是如何阻塞其他的cache的请求？</u></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>MESI</tag>
      
      <tag>体系结构</tag>
      
      <tag>原子操作</tag>
      
      <tag>CAS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MapReduce</title>
    <link href="/2021/04/15/MapReduce/"/>
    <url>/2021/04/15/MapReduce/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>分布式系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MapReduce</tag>
      
      <tag>分布式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go-12-Mutex的实现</title>
    <link href="/2021/04/12/Go-12-Mutex%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <url>/2021/04/12/Go-12-Mutex%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h4 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h4><p>根据<a href="https://github.com/golang/go/blob/41d8e61a6b9d8f9db912626eb2bbc535e929fefc/src/sync/mutex.go#L25" target="_blank" rel="noopener">注释</a>可知，互斥锁有如下性质：</p><blockquote><p>互斥锁有两种状态：正常状态和饥饿状态。</p><p>在正常状态下，所有等待锁的 goroutine 按照FIFO顺序等待。唤醒的 goroutine 不会直接拥有锁，而是会和新请求锁的 goroutine 竞争锁的拥有。新请求锁的 goroutine 具有优势：它正在 CPU 上执行，而且可能有好几个，所以刚刚唤醒的 goroutine 有很大可能在锁竞争中失败。在这种情况下，这个被唤醒的 goroutine 会加入到等待队列的前面。 如果一个等待的 goroutine 超过 1ms 没有获取锁，那么它将会把锁转变为饥饿模式。</p><p>在饥饿模式下，锁的所有权将从 unlock 的 goroutine 直接交给交给等待队列中的第一个。新来的 goroutine 将不会尝试去获得锁，即使锁看起来是 unlock 状态, 也不会去尝试自旋操作，而是放在等待队列的尾部。</p><p>如果一个等待的 goroutine 获取了锁，并且满足一以下其中的任何一个条件：(1)它是队列中的最后一个；(2)它等待的时候小于1ms。它会将锁的状态转换为正常状态。</p><p>正常状态有很好的性能表现，饥饿模式也是非常重要的，因为它能阻止尾部延迟的现象。</p></blockquote><p>除了上面两种模式，还有一个<code>woken</code>模式，即唤醒标记，主要用作自旋状态的通知和锁公平性的保证。</p><ul><li>新的goroutine申请锁时，如果锁被占用了而且满足自旋的条件，那么自旋，并且对锁标记woken。那么占用锁的goroutine在释放锁时会检查该标记，如果已经标记了，那么并不会去唤醒阻塞队列上面的goroutine，而是直接return，从而使得自旋的goroutine有更大的机会抢到锁。</li><li>释放锁时如果woken标记为空，而且阻塞队列里goroutine需要被唤醒，那么唤醒时标记锁woken。这样新来的goroutine不会直接获取到锁，而是进入<code>slowpath</code>。否则，g被唤醒之后，还需要等调度器调度、运行，那么这期间可能锁被抢走了，不太公平。</li></ul><h5 id="自旋"><a href="#自旋" class="headerlink" title="自旋"></a>自旋</h5><p>考虑如果不自旋，那么正常状态下所有g都在等待队列中——有可能临界区代码执行时间很短，这时候先阻塞再唤醒带来的切换成本比较高。而空闲资源充足的情况下自旋可以带来更高的效率。</p><h5 id="公平"><a href="#公平" class="headerlink" title="公平"></a>公平</h5><ul><li><p>在锁释放时，主动设置Woken标记，防止新的竞争者轻易抢到锁。</p></li><li><p>竞争者进阻塞队列策略不一样。新的竞争者，抢不到锁，就排在队列尾部。先来竞争者，从队列中被唤醒后，还是抢不到锁，就放在队列头部。</p></li><li><p>任何竞争者，被阻塞等待的时间超过指定阀值(1ms)。锁就转为饥饿模式。这时锁释放时会唤醒它们，手递手式把锁资源给它们。别的竞争者（包括新来的）都抢不到。直到把饥饿问题解决掉。</p></li></ul><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><h5 id="CAS操作"><a href="#CAS操作" class="headerlink" title="CAS操作"></a>CAS操作</h5><h5 id="Mutex结构体"><a href="#Mutex结构体" class="headerlink" title="Mutex结构体"></a>Mutex结构体</h5><div class="hljs"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Mutex <span class="hljs-keyword">struct</span> &#123;state <span class="hljs-keyword">int32</span>sema  <span class="hljs-keyword">uint32</span>&#125;</code></pre></div><p><code>state</code>总共32位，低三位分别表示 <code>mutexLocked</code>、<code>mutexWoken</code> 和 <code>mutexStarving</code></p><div class="hljs"><pre><code class="hljs go"><span class="hljs-keyword">const</span> (mutexLocked = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-literal">iota</span> <span class="hljs-comment">// mutex is locked</span>mutexWoken <span class="hljs-comment">//表示某个唤醒的goroutine想要获取锁</span>mutexStarving <span class="hljs-comment">//饥饿模式</span>mutexWaiterShift = <span class="hljs-literal">iota</span> <span class="hljs-comment">//通过state&gt;&gt;mutexWaiterShift得到等待锁的goroutine个数</span>starvationThresholdNs = <span class="hljs-number">1e6</span>)</code></pre></div><h5 id="加锁"><a href="#加锁" class="headerlink" title="加锁"></a>加锁</h5><p><a href="https://en.wikipedia.org/wiki/Fast_path" target="_blank" rel="noopener">Fast path</a>：简单来说，将最可能的情况/最频繁执行的部分放到前面，各种少见的情况放到后面，这样可以减少不必要的判断。</p><div class="hljs"><pre><code class="hljs go"><span class="hljs-comment">// Lock locks m.</span><span class="hljs-comment">// If the lock is already in use, the calling goroutine</span><span class="hljs-comment">// blocks until the mutex is available.</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *Mutex)</span> <span class="hljs-title">Lock</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-comment">// Fast path: grab unlocked mutex.</span><span class="hljs-keyword">if</span> atomic.CompareAndSwapInt32(&amp;m.state, <span class="hljs-number">0</span>, mutexLocked) &#123;<span class="hljs-keyword">if</span> race.Enabled &#123;race.Acquire(unsafe.Pointer(m))&#125;<span class="hljs-keyword">return</span>&#125;<span class="hljs-comment">// Slow path (outlined so that the fast path can be inlined)</span>m.lockSlow()&#125;</code></pre></div><p>这里的<code>lockSlow()</code>比较复杂，包括了一下逻辑：</p><ul><li><p>判断当前 Goroutine 能否进入自旋；</p></li><li><p>通过自旋等待互斥锁的释放；</p></li><li><p>计算互斥锁的最新状态；</p></li><li><p>更新互斥锁的状态并获取锁</p></li></ul><div class="hljs"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *Mutex)</span> <span class="hljs-title">lockSlow</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">var</span> waitStartTime <span class="hljs-keyword">int64</span> starving := <span class="hljs-literal">false</span>awoke := <span class="hljs-literal">false</span>iter := <span class="hljs-number">0</span> <span class="hljs-comment">//自旋次数</span>old := m.state<span class="hljs-keyword">for</span> &#123;<span class="hljs-comment">// Don't spin in starvation mode, ownership is handed off to waiters</span><span class="hljs-comment">// so we won't be able to acquire the mutex anyway.</span><span class="hljs-keyword">if</span> old&amp;(mutexLocked|mutexStarving) == mutexLocked &amp;&amp; runtime_canSpin(iter) &#123;<span class="hljs-comment">// Active spinning makes sense.</span><span class="hljs-comment">// Try to set mutexWoken flag to inform Unlock</span><span class="hljs-comment">// to not wake other blocked goroutines.</span>                        <span class="hljs-comment">//如果当前goroutine没有设为唤醒状态、等待队列当中存在goroutine、锁的状态没有更新</span>            <span class="hljs-comment">//那么将当前goroutine设为唤醒状态，并且更新锁的状态</span><span class="hljs-keyword">if</span> !awoke &amp;&amp; old&amp;mutexWoken == <span class="hljs-number">0</span> &amp;&amp; old&gt;&gt;mutexWaiterShift != <span class="hljs-number">0</span> &amp;&amp;atomic.CompareAndSwapInt32(&amp;m.state, old, old|mutexWoken) &#123;awoke = <span class="hljs-literal">true</span>&#125;            <span class="hljs-comment">//执行30次PAUSE指令</span>runtime_doSpin()iter++old = m.state<span class="hljs-keyword">continue</span>&#125;</code></pre></div><p>解释：</p><ul><li><p><code>old&amp;(mutexLocked|mutexStarving) == mutexLocked</code>为真即表示当前锁处于锁定状态并且不处于饥饿模式</p></li><li><p><code>runtime_canSpin(iter)</code>为真：</p><ul><li><p>运行在多 CPU 的机器上；</p></li><li><p>当前 Goroutine 为了获取该锁进入自旋的次数小于四次；</p></li><li><p>当前机器上至少存在一个正在运行的处理器 P 并且处理的运行队列为空；</p></li></ul></li></ul><div class="hljs"><pre><code class="hljs go"><span class="hljs-comment">/*</span><span class="hljs-comment">此时状态可能：</span><span class="hljs-comment">锁被获取 且 正常</span><span class="hljs-comment">锁被获取 且 饥饿</span><span class="hljs-comment">锁空闲 且 正常 --&gt;结束自旋，尝试去获取锁</span><span class="hljs-comment">锁空闲 且 饥饿 --&gt;注意假设锁处于饥饿模式 恢复正常的条件尚未满足</span><span class="hljs-comment"></span><span class="hljs-comment">g可能处于唤醒或者未唤醒的状态</span><span class="hljs-comment">*/</span><span class="hljs-built_in">new</span> := old<span class="hljs-keyword">if</span> old&amp;mutexStarving == <span class="hljs-number">0</span> &#123;    <span class="hljs-comment">//非饥饿模式下抢锁</span><span class="hljs-built_in">new</span> |= mutexLocked&#125;<span class="hljs-keyword">if</span> old&amp;(mutexLocked|mutexStarving) != <span class="hljs-number">0</span> &#123;    <span class="hljs-comment">//如果已经上锁了或者处于饥饿模式 那么将当前g阻塞——等待的g数量+1</span><span class="hljs-built_in">new</span> += <span class="hljs-number">1</span> &lt;&lt; mutexWaiterShift&#125;<span class="hljs-keyword">if</span> starving &amp;&amp; old&amp;mutexLocked != <span class="hljs-number">0</span> &#123;    <span class="hljs-comment">//如果当前g处于饥饿模式 并且锁为锁定状态——否则可以直接赋给g 将锁转为饥饿模式</span><span class="hljs-built_in">new</span> |= mutexStarving&#125;<span class="hljs-keyword">if</span> awoke &#123;    <span class="hljs-comment">// The goroutine has been woken from sleep,</span><span class="hljs-comment">// so we need to reset the flag in either case.</span><span class="hljs-keyword">if</span> <span class="hljs-built_in">new</span>&amp;mutexWoken == <span class="hljs-number">0</span> &#123;throw(<span class="hljs-string">"sync: inconsistent mutex state"</span>)&#125;<span class="hljs-built_in">new</span> &amp;^= mutexWoken&#125;<span class="hljs-keyword">if</span> atomic.CompareAndSwapInt32(&amp;m.state, old, <span class="hljs-built_in">new</span>) &#123;<span class="hljs-keyword">if</span> old&amp;(mutexLocked|mutexStarving) == <span class="hljs-number">0</span> &#123;                <span class="hljs-comment">//因为old状态为正常模式且没有锁定——结合上面的判断，可以确定新的状态已经锁定，当前g获得锁，直接退出循环</span><span class="hljs-keyword">break</span> <span class="hljs-comment">// locked the mutex with CAS</span>&#125;<span class="hljs-comment">// If we were already waiting before, queue at the front of the queue.</span>queueLifo := waitStartTime != <span class="hljs-number">0</span><span class="hljs-keyword">if</span> waitStartTime == <span class="hljs-number">0</span> &#123;waitStartTime = runtime_nanotime()&#125;runtime_SemacquireMutex(&amp;m.sema, queueLifo, <span class="hljs-number">1</span>)starving = starving || runtime_nanotime()-waitStartTime &gt; starvationThresholdNsold = m.state<span class="hljs-keyword">if</span> old&amp;mutexStarving != <span class="hljs-number">0</span> &#123;<span class="hljs-comment">// If this goroutine was woken and mutex is in starvation mode,</span><span class="hljs-comment">// ownership was handed off to us but mutex is in somewhat</span><span class="hljs-comment">// inconsistent state: mutexLocked is not set and we are still</span><span class="hljs-comment">// accounted as waiter. Fix that.</span><span class="hljs-keyword">if</span> old&amp;(mutexLocked|mutexWoken) != <span class="hljs-number">0</span> || old&gt;&gt;mutexWaiterShift == <span class="hljs-number">0</span> &#123;throw(<span class="hljs-string">"sync: inconsistent mutex state"</span>)&#125;delta := <span class="hljs-keyword">int32</span>(mutexLocked - <span class="hljs-number">1</span>&lt;&lt;mutexWaiterShift)<span class="hljs-keyword">if</span> !starving || old&gt;&gt;mutexWaiterShift == <span class="hljs-number">1</span> &#123;<span class="hljs-comment">// Exit starvation mode.</span><span class="hljs-comment">// Critical to do it here and consider wait time.</span><span class="hljs-comment">// Starvation mode is so inefficient, that two goroutines</span><span class="hljs-comment">// can go lock-step infinitely once they switch mutex</span><span class="hljs-comment">// to starvation mode.</span>delta -= mutexStarving&#125;atomic.AddInt32(&amp;m.state, delta)<span class="hljs-keyword">break</span>&#125;awoke = <span class="hljs-literal">true</span>iter = <span class="hljs-number">0</span>&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go-11-OOP in Go</title>
    <link href="/2021/04/11/Go-11-OOP-in-Go/"/>
    <url>/2021/04/11/Go-11-OOP-in-Go/</url>
    
    <content type="html"><![CDATA[<p>ToDoList：</p><ul><li>如何理解OOP</li><li>为什么Go没有类似于C++/JAVA中的实现</li><li>如何使用Go去解决适合OOP解决的问题</li></ul><blockquote><p>发现事情逐渐变得不可控——因为我并没有“架构”上的经验。</p><p>所以还是回到最初的问题——如何使用Go的method/interface。</p></blockquote><hr><h5 id="如何理解OOP"><a href="#如何理解OOP" class="headerlink" title="如何理解OOP"></a>如何理解OOP</h5><p>简单来说，这是一种设计思想——如何架构一个比较复杂的项目/程序？一种方式是抽象出很多节点，节点内部的状态是隐藏的，节点之间通过传递消息来改变状态。</p><p>为了方便这种想法的落地，我们有了封装、继承和多态等特性。</p><hr><h5 id="Is-Go-an-object-oriented-language"><a href="#Is-Go-an-object-oriented-language" class="headerlink" title="Is Go an object-oriented language?"></a><a href="https://golang.org/doc/faq#Is_Go_an_object-oriented_language" target="_blank" rel="noopener">Is Go an object-oriented language?</a></h5><p>Yes and no. Although Go has types and methods and allows an object-oriented style of programming, there is no type hierarchy. The concept of “interface” in Go provides a different approach that we believe is easy to use and in some ways more general. There are also ways to embed types in other types to provide something analogous—but not identical—to subclassing. Moreover, methods in Go are more general than in C++ or Java: they can be defined for any sort of data, even built-in types such as plain, “unboxed” integers. They are not restricted to structs (classes).</p><p>Also, the lack of a type hierarchy makes “objects” in Go feel much more lightweight than in languages such as C++ or Java.</p><hr><h5 id="导出的方法构造未导出的结构体"><a href="#导出的方法构造未导出的结构体" class="headerlink" title="导出的方法构造未导出的结构体"></a>导出的方法构造未导出的结构体</h5><p>如果我们并不希望导出某个包中的结构体但是确实需要使用，一种可行的模式是实现<code>func New(args)type receiver</code>函数从而返回构造之后的实例。</p><div class="hljs"><pre><code class="hljs go"><span class="hljs-comment">//package test</span><span class="hljs-keyword">struct</span> test&#123;    name <span class="hljs-keyword">string</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">New</span><span class="hljs-params">(s <span class="hljs-keyword">string</span>)</span><span class="hljs-title">test</span></span>&#123;    <span class="hljs-keyword">return</span> test&#123;name:s&#125;&#125;<span class="hljs-comment">//package main</span>a := test.New(<span class="hljs-string">"TEST"</span>)</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go-10-map的实现</title>
    <link href="/2021/04/06/Go-10-map%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <url>/2021/04/06/Go-10-map%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<p>我们首先考虑实现一个性能良好的哈希表的可能方面：</p><ul><li>哈希函数的选择——如何选择性能较好的哈希函数</li><li><p>冲突的解决</p><ul><li>拉链法相较于开放寻址的优点</li><li>装载因子对性能的影响</li></ul></li><li><p>扩容</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go-09-net/http</title>
    <link href="/2021/03/30/Go-09-net-http/"/>
    <url>/2021/03/30/Go-09-net-http/</url>
    
    <content type="html"><![CDATA[<h4 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h4><p>参考：</p><ul><li>深入学习用 Go 编写 HTTP 服务器 - Kevin Yan的文章 - 知乎 <a href="https://zhuanlan.zhihu.com/p/104182198" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/104182198</a></li></ul><h5 id="注册路由"><a href="#注册路由" class="headerlink" title="注册路由"></a>注册路由</h5><p>从接口出发：</p><ul><li><p><code>http.HandleFunc(pattern,相应的处理函数P)</code></p><ul><li><p>调用<code>Mux.HandleFunc</code>，将P转换成<code>HandlerFunc</code>类型，然后调用<code>Mux.Handle(pattern,Handler接口实例)</code>，<code>Handler</code>接口拥有方法<code>ServerHTTP</code>。</p><p>注意这里的转换，因为<code>HandlerFunc</code>实现了方法<code>ServerHTTP</code>，该方法会调用函数本身。换句话说，这里的接收器为一个函数，方法调用接收器。从而我们可以将其转换成<code>Handler</code>接口</p></li></ul></li><li><p><code>http.Handle(pattern,Handler接口的实例)</code></p></li></ul><p><code>ServerMux</code>结构体：</p><ul><li><code>map[key]muxEntry</code>。<code>key:pattern</code>；<code>muxEntry</code>是一个结构体，包括成员：<code>Handler</code>接口；<code>pattern</code></li><li><code>es []muEntry</code> ：用于部分匹配</li><li><code>mu/hosts</code></li><li>实现的方法：<ul><li><code>ServerHTTP</code>：与上面提到的同名，但是用于寻找对应的路由、处理函数</li><li><code>Handle</code>：<ul><li>向<code>map</code>添加项</li><li><code>/</code>结尾，<code>[]muxEntry</code></li></ul></li></ul></li></ul><h5 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h5><p>从接口出发：</p><ul><li><code>http.ListenAndServer(addr string, handler Handler)</code>。注意，这里的<code>handler</code>是<code>ServerMux</code>。<ul><li>生成<code>server := &amp;Server...</code></li><li>调用<code>server</code>的<code>ListenAndServer</code></li></ul></li><li>在<code>Server.ListenAndServer</code>当中：<ul><li>判断错误 设置默认等等</li><li>调用<code>Server.Serve</code>函数，参数是一个监听对象<code>l net.Listener</code><ul><li>创建一个上下文对象，<code>l.Accept</code>接受监听到的网络连接；一旦有新的连接建立，那么调用<code>Server.newConn()</code>创建新的连接对象，设置状态，然后开启goroutine处理连接请求。</li></ul></li></ul></li></ul><blockquote><p>涉及到了context包，转而去阅读了。目前对HTTP Server有了大致的了解：我们首先需要注册路由（当然可以自己设置，或者使用默认的）。在http包当中已经有了完整的处理流程：当连接当来时，服务器对象会生成一个新的连接对象，然后开启goroutine去处理连接中的请求，对于每一个请求，其会调用mux来尝试精确匹配路由，如果失败，那么近似匹配。最终找到了对应的路由，然后再得到对应的处理函数。</p></blockquote><h5 id="停止服务"><a href="#停止服务" class="headerlink" title="停止服务"></a>停止服务</h5><hr>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go-08-工具链</title>
    <link href="/2021/03/29/Go-08-%E5%B7%A5%E5%85%B7%E9%93%BE/"/>
    <url>/2021/03/29/Go-08-%E5%B7%A5%E5%85%B7%E9%93%BE/</url>
    
    <content type="html"><![CDATA[<h4 id="pprof"><a href="#pprof" class="headerlink" title="pprof"></a>pprof</h4><h4 id="Protobuf"><a href="#Protobuf" class="headerlink" title="Protobuf"></a>Protobuf</h4>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Nachos-02-信号量与线程同步</title>
    <link href="/2021/03/28/Nachos-02-%E4%BF%A1%E5%8F%B7%E9%87%8F%E4%B8%8E%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5/"/>
    <url>/2021/03/28/Nachos-02-%E4%BF%A1%E5%8F%B7%E9%87%8F%E4%B8%8E%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5/</url>
    
    <content type="html"><![CDATA[<h5 id="make出错"><a href="#make出错" class="headerlink" title="make出错"></a>make出错</h5><p><img src="https://i.loli.net/2021/03/28/a6ZvVFCtSoUceQb.png" srcset="/img/loading.gif" alt="image-20210328150825718"></p><ul><li>首先查了一下C++目录下的其他版本，包括7/7.5.0都没有该文件。</li><li><a href="https://stackoverflow.com/questions/4643197/missing-include-bits-cconfig-h-when-cross-compiling-64-bit-program-on-32-bit" target="_blank" rel="noopener">查了一下</a>，推荐<code>sudo apt-get install gcc-multilib g++-multilib</code>。但是我已经装了。看到提示可能需要安装对应的版本，尝试了一下，<code>sudo apt install g++-8-multilib</code>，成功。</li></ul><h5 id="环形队列"><a href="#环形队列" class="headerlink" title="环形队列"></a>环形队列</h5><p>想到了Go中的channel，不过这里非常简陋，仅仅对数组封装了一下，<code>full/empty</code>没有实现，<code>get/put</code>没有判断元素数目/锁，更不用说阻塞/唤醒了。而且指导书说不做任何修改……所以我们需要自己手动去同步。</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><h5 id="整体结构"><a href="#整体结构" class="headerlink" title="整体结构"></a>整体结构</h5><ul><li>生产者负责将消息送入队列；每个消费者都会创建一个对应的文件，拿到消息之后写入文件。</li><li>这里我们需要信号量表示空闲slot的数目，初始值为<code>BUFF_SIZE</code>；需要信号量表示满的slot的数目，初始值为0；另外对队列的访问需要互斥锁。</li><li>接下来主要是理解信号量和线程的创建部分。</li></ul><h5 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h5><p>接口非常简单，提供名字和初始值即可：</p><p><img src="https://i.loli.net/2021/03/28/yxBciu2EHLJ6eoG.png" srcset="/img/loading.gif" alt="image-20210328191923922" style="zoom:67%;" /></p><p>这里有一个List，比较灵活的地方在于元素类型并不确定，因为提供指针、key即可：</p><p><img src="https://i.loli.net/2021/03/28/TVOqMlt9PcoJGRi.png" srcset="/img/loading.gif" alt="image-20210328192616857" style="zoom:67%;" /></p><p>P操作：</p><ul><li>关中断</li><li>循环：将当前线程添加到List末尾，然后进入睡眠，知道信号量值大于0</li><li>信号量值-1</li><li>恢复原来的中断状态（注释：并不在乎原本状态是开是关，直接恢复即可）</li></ul><p>V操作：</p><ul><li>关中断</li><li>从List当中取出线程；如果存在那么加入就绪队列；</li><li>信号量值+1</li><li>恢复中断</li></ul><h5 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h5><p><img src="https://i.loli.net/2021/03/28/nGvAJieWYBDyRsV.png" srcset="/img/loading.gif" alt="image-20210328193344528"></p><p>只是对信号量封装了一下—初始值为1的信号量，<code>Acquire</code>和<code>Release</code>都是基于P/V操作的。</p><h5 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h5><p>开始的注释还提示了一下，栈大小是固定的，所以如果数据占空间比较大应该动态分配。线程也提供了一个函数<code>CheckOverFlow</code>。</p><p>具体使用类似于实验一中forked thread：先创建然后再<code>fork</code>传入具体需要执行的函数及其参数。</p><h5 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h5><p><img src="https://i.loli.net/2021/03/28/Io6cdPrYAty2TZb.png" srcset="/img/loading.gif" alt="image-20210328215241273"></p><p><img src="https://i.loli.net/2021/03/28/UAO1SifMpG24LhH.png" srcset="/img/loading.gif" alt="image-20210328215251296"></p><p>正常执行。</p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
      <category>Nachos</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
      <tag>Nachos</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go-07-分布式缓存</title>
    <link href="/2021/03/27/Go-07-%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98/"/>
    <url>/2021/03/27/Go-07-%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98/</url>
    
    <content type="html"><![CDATA[<blockquote><p>使用Go仿照groupcache实现分布式缓存的教程：<a href="https://geektutu.com/post/geecache.html" target="_blank" rel="noopener">https://geektutu.com/post/geecache.html</a></p></blockquote><h4 id="分布式缓存"><a href="#分布式缓存" class="headerlink" title="分布式缓存"></a>分布式缓存</h4><h5 id="memcache"><a href="#memcache" class="headerlink" title="memcache"></a>memcache</h5><ul><li><p>C-S架构，服务器之间并不会通信，由客户端负责决定使用哪个节点——一致性哈希。</p><p><img src="https://i.loli.net/2021/04/11/f7qyuZFKb4GpXY5.png" srcset="/img/loading.gif" alt="image-20210411210109813" style="zoom: 50%;" /></p></li><li><p>内存分配也是多级的结构：<code>slab_class_t[200]</code>，每一个对应的item的大小不同，增长因子可以设置。每一个<code>slab_class_t</code>结构体拥有诸多的<code>slab</code>，每个<code>slab</code>是由<code>chunk</code>构成的双向链表——LRU链表，大小1M。分配时根据item的大小找到合适的<code>slab_class_t</code>，然后找到空闲的<code>chunk</code>。</p></li></ul><h5 id="redis"><a href="#redis" class="headerlink" title="redis"></a>redis</h5><h5 id="groupcache"><a href="#groupcache" class="headerlink" title="groupcache"></a>groupcache</h5><h4 id="缓存淘汰算法"><a href="#缓存淘汰算法" class="headerlink" title="缓存淘汰算法"></a>缓存淘汰算法</h4><h5 id="LRU"><a href="#LRU" class="headerlink" title="LRU"></a>LRU</h5><ul><li><p>最近最少使用——主要是根据使用的时间来决定淘汰与否。优先淘汰最久未使用的</p></li><li><p>缺点：偶然的、周期性的批量操作会导致命中率下降——缓存被污染。因为其主要是根据访问时间来决定淘汰与否的。</p></li><li>优点：实现简单，时间复杂度低。</li></ul><h5 id="ARC"><a href="#ARC" class="headerlink" title="ARC"></a>ARC</h5><h5 id="LRU-k"><a href="#LRU-k" class="headerlink" title="LRU-k"></a>LRU-k</h5><h4 id="整体结构"><a href="#整体结构" class="headerlink" title="整体结构"></a>整体结构</h4><h5 id="整体获取缓存的逻辑："><a href="#整体获取缓存的逻辑：" class="headerlink" title="整体获取缓存的逻辑："></a>整体获取缓存的逻辑：</h5><div class="hljs"><pre><code class="hljs go">                            是接收 key --&gt; 检查是否被缓存 -----&gt; 返回缓存值 ⑴                |  否                         是                |-----&gt; 是否应当从远程节点获取 -----&gt; 与远程节点交互 --&gt; 返回缓存值 ⑵                            |  否                            |-----&gt; 调用<span class="hljs-string">`回调函数`</span>，获取值并添加到缓存 --&gt; 返回缓存值 ⑶</code></pre></div><h5 id="单机并发缓存"><a href="#单机并发缓存" class="headerlink" title="单机并发缓存"></a>单机并发缓存</h5><ul><li>首先自然是缓存的实现——K-V结构。因此在底层，我们使用<code>map</code>来实现。</li><li>同时我们需要考虑淘汰策略，最常见、实现又非常简单的自然是LRU了。</li><li>注意上述实现并不是并发安全的，所以我们考虑再抽象出<code>cache</code>的结构，主要是结合互斥锁进行封装。</li><li>由于我们可能存在多个缓存实例，因此名字也是必要的。</li><li>结合上述部分，我们抽象除了<code>Group</code>结构体，包括缓存名称、LRU缓存实例、回调接口。</li></ul><h5 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h5><p>每一个节点都可以是服务端/客户端。</p><ul><li><p>作为服务端：接受请求，返回值。</p></li><li><p>作为客户端：通过一致性哈希得到远程节点，构造请求发送给远程节点，得到返回值。</p></li></ul><p>为了避免缓存击穿，我们通过singleflight模式从远程获取数据。</p><h4 id="防止缓存击穿"><a href="#防止缓存击穿" class="headerlink" title="防止缓存击穿"></a>防止缓存击穿</h4><blockquote><p>所谓的缓存击穿是指某个热点key在失效时，大量的并发请求击穿缓存、直接打到数据库上。</p><p>另外还有缓存雪崩——某一时刻大量缓存失效导致大量请求落在数据库上。——设置不同的过期时间；分级缓存；永不过期；互斥锁；熔断机制，限流降级。</p><p>缓存穿透——缓存和数据库中都不存在的值。——将无效的key放入缓存，设置value为NULL；布隆过滤器。</p></blockquote><h5 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h5><ul><li><p>非常直接的，如果热点数据永不过期，那么自然不会击穿。</p><ul><li>物理上，没有过期时间</li><li>逻辑上，不断更新</li></ul></li><li><p>限制并发读取某个key，可以使用“互斥锁”或者队列。</p></li></ul><h5 id="singleflight"><a href="#singleflight" class="headerlink" title="singleflight"></a>singleflight</h5><blockquote><p>一种比较巧妙的限制并发请求的方法，在<code>sync.singleflight</code>中有较完整的实现，groupcache实现了简单的子集。</p></blockquote><p><a href="https://pkg.go.dev/golang.org/x/sync/singleflight" target="_blank" rel="noopener">官方文档</a></p><p><a href="https://github.com/golang/sync/blob/036812b2e83c/singleflight/singleflight.go#L86" target="_blank" rel="noopener">源码</a></p><p><strong>关键逻辑：</strong></p><ul><li>首先我们将请求抽象成<code>call</code>结构体，自然肯定需要包括我们的返回值以及返回的错误；另外为了确保第一个请求之后的请求并不会执行、而是等待第一个请求执行完成，我们使用<code>sync.WaitGroup</code>。</li><li>为了处理很多的请求，我们使用<code>map[string]*call</code>来进行标示、记录。而且，由于<code>map</code>并非线程安全的，所以需要互斥锁。从而抽象出<code>Group</code>结构体。</li><li>如果暂时忽略掉错误处理等部分，只关心<code>Do</code>核心逻辑，那么大致过程如下：<ul><li>首先拿到锁。如果此时尚未初始化<code>Group</code>，那么初始化——<strong>延迟初始化</strong>。</li><li>之后我们尝试获取对应的<code>call</code><ul><li>如果存在，那么已经拿到了，此时可以对<code>Group</code>解锁——因为对其他<code>call</code>的操作并不会影响到我们当前的<code>call</code>。此时我们调用<code>wg.Wait()</code>。<ul><li>如果存在其他线程正在持有该<code>call</code>进行请求、尚未完成，那么当前线程等待。</li><li>如果并不存在，那么直接继续执行，返回值。</li></ul></li><li>如果不存在，那么构建一个。并且<code>wg.Add(1)</code>，然后将其添加到<code>Group</code>的<code>map</code>当中，然后解锁。接着我们再调用<code>doCall</code>完成请求——当然这中间涉及到<code>wg.Done()</code>。</li></ul></li></ul></li></ul><p>其他接口：</p><ul><li><p><code>func (g *Group) Forget(key string)</code>：从<code>Group</code>中删除<code>key</code>，这样根据上面的逻辑，之后的请求会形成新的<code>call</code>、重新拿到数据。</p></li><li><p><code>func (g *Group) DoChan(key string, fn func() (interface{}, error)) &lt;-chan Result</code>：类似于<code>Do</code>，但是会返回<code>Result</code>类型的只读的channel。具体执行逻辑在<code>doCall</code>中：</p><div class="hljs"><pre><code class="hljs go"><span class="hljs-comment">// Normal return</span><span class="hljs-keyword">for</span> _, ch := <span class="hljs-keyword">range</span> c.chans &#123;ch &lt;- Result&#123;c.val, c.err, c.dups &gt; <span class="hljs-number">0</span>&#125;&#125;</code></pre></div><p>可以看到，在请求成功执行完毕之后，遍历<code>call</code>中的<code>chans []chan&lt;- Result</code>，发送数据。其中<code>Result</code>定义如下：</p><div class="hljs"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Result <span class="hljs-keyword">struct</span> &#123;Val    <span class="hljs-keyword">interface</span>&#123;&#125;Err    errorShared <span class="hljs-keyword">bool</span>&#125;</code></pre></div><p>无论是在<code>Do</code>还是在<code>DoChan</code>中，一旦<code>call</code>存在，那么之后的调用都会将<code>dup</code>字段加一。所以这里<code>Shared == c.dups &gt; 0</code>代表了结果将会被返回给多个调用者。</p></li></ul><p>groupcache中的singleflight包：<a href="https://github.com/golang/groupcache/tree/master/singleflight" target="_blank" rel="noopener">https://github.com/golang/groupcache/tree/master/singleflight</a></p><p>这里实现得很简洁，整体思路、逻辑是一样的，只是去除了用不上的部分，只有一个<code>func (g *Group) Do(key string, fn func() (interface{}, error)) (interface{}, error)</code>。</p><h4 id="HTTP通信"><a href="#HTTP通信" class="headerlink" title="HTTP通信"></a>HTTP通信</h4><h5 id="HTTP包"><a href="#HTTP包" class="headerlink" title="HTTP包"></a>HTTP包</h5><p><a href="https://golang.org/pkg/net/http/" target="_blank" rel="noopener">官方文档</a></p><h5 id="一致性哈希"><a href="#一致性哈希" class="headerlink" title="一致性哈希"></a>一致性哈希</h5><p>作用在于稳定地将某个key映射到同一远程节点。这里的远程节点的表示可以是名称，也可以是标号、IP地址等。当然，最终都需要获取到IP地址。</p><h5 id="如何实现从远程节点获取数据"><a href="#如何实现从远程节点获取数据" class="headerlink" title="如何实现从远程节点获取数据"></a>如何实现从远程节点获取数据</h5><p>逻辑：</p><ul><li>首先是触发从远程获取：未能从本地获取。</li><li>初始化时对于每个<code>Group</code>注册远程节点——将创建的<code>HTTPPool</code>对象赋值给<code>Group.peers</code><ul><li>每个<code>HTTPPool</code>对象持有一个一致性哈希的实例，用于将<code>key</code>映射到对应的真实节点</li><li>同时还持有一个<code>httpGetters  map[string]*httpGetter</code>，用于将真实节点映射到客户端</li><li>如果我们初始化时使用的是节点的IP地址，那么一致性哈希当中会增加节点、<code>httpGetters</code>中增加客户端。从而之后我们可以根据<code>key</code>获取客户端</li></ul></li><li>客户端拥有数据：<code>baseURL</code>，例如：<code>http://IPAddr:port/_qscache</code>。调用客户端的<code>Get</code>方法时传入<code>Group</code>和<code>key</code>即可构造出最终的请求。</li></ul><p>实现细节：</p><ul><li>我们的客户端的表示是结构体<code>httpGetter</code>，只有一个<code>baseURL</code>字段，用于构造请求。</li></ul><h4 id="Protobuf"><a href="#Protobuf" class="headerlink" title="Protobuf"></a>Protobuf</h4><h5 id="序列化与反序列化"><a href="#序列化与反序列化" class="headerlink" title="序列化与反序列化"></a>序列化与反序列化</h5><p>我们知道程序都是运行在内存中的，所有的数据在内存中都是一个个的01比特。如果我们将内存中的对象传输到远程节点，怎么讲01的比特流恢复成我们原本的对象？这就需要指定两种表示方式之间的转化规则——这就是序列化和反序列化。</p><p>从OSI七层模型的角度考虑，其实表示层的作用就是将应用层的数据/对象转化成二进制串。从TCP/IP协议的角度考虑，序列化和反序列化属于应用层。</p><p>如何去衡量一个序列化协议？</p><ul><li>通用性：是否支持跨平台跨语言；生态是否完善</li><li>鲁棒性</li><li>可调式性/可读性</li><li>性能：时间/空间开销</li><li>可扩展性/兼容性</li><li>等等</li></ul><blockquote><p>典型的序列化和反序列化过程往往需要如下组件：</p><ul><li>IDL（Interface description language）文件：参与通讯的各方需要对通讯的内容需要做相关的约定（Specifications）。为了建立一个与语言和平台无关的约定，这个约定需要采用与具体开发语言、平台无关的语言来进行描述。这种语言被称为接口描述语言（IDL），采用IDL撰写的协议约定称之为IDL文件。</li><li>IDL Compiler：IDL文件中约定的内容为了在各语言和平台可见，需要有一个编译器，将IDL文件转换成各语言对应的动态库。</li><li>Stub/Skeleton Lib：负责序列化和反序列化的工作代码。Stub是一段部署在分布式系统客户端的代码，一方面接收应用层的参数，并对其序列化后通过底层协议栈发送到服务端，另一方面接收服务端序列化后的结果数据，反序列化后交给客户端应用层；Skeleton部署在服务端，其功能与Stub相反，从传输层接收序列化参数，反序列化后交给服务端应用层，并将应用层的执行结果序列化后最终传送给客户端Stub。</li><li>Client/Server：指的是应用层程序代码，他们面对的是IDL所生存的特定语言的class或struct。</li><li>底层协议栈和互联网：序列化之后的数据通过底层的传输层、网络层、链路层以及物理层协议转换成数字信号在互联网中传递。</li></ul></blockquote><h5 id="protobuf的特点"><a href="#protobuf的特点" class="headerlink" title="protobuf的特点"></a>protobuf的特点</h5><blockquote><ul><li><p>标准的IDL和IDL编译器，这使得其对工程师非常友好。</p></li><li><p>序列化数据非常简洁，紧凑，与XML相比，其序列化之后的数据量约为1/3到1/10。</p></li><li><p>解析速度非常快，比对应的XML快约20-100倍。</p></li><li><p>提供了非常友好的动态库，使用非常简介，反序列化只需要一行代码。</p></li></ul></blockquote><h5 id="使用protobuf"><a href="#使用protobuf" class="headerlink" title="使用protobuf"></a>使用protobuf</h5><p><a href="https://pkg.go.dev/google.golang.org/protobuf@v1.26.0/proto#pkg-overview" target="_blank" rel="noopener">官方文档</a></p><p>首先，我们需要定义message。因为主要是用于编码<code>group key value</code>，所以很简单：</p><div class="hljs"><pre><code class="hljs go">message Request&#123;    <span class="hljs-keyword">string</span> group = <span class="hljs-number">1</span>;    <span class="hljs-keyword">string</span> key = <span class="hljs-number">2</span>;&#125;message Response&#123;    bytes value = <span class="hljs-number">1</span>;&#125;</code></pre></div><p>使用protoc-gen-go生成go代码。</p><p>接着将以前的HTTP报文的主体部分改成用protobuf编码。主要是<code>ServeHTTP</code>的响应报文的body部分、客户端<code>Get</code>方法对于响应报文进行解码、改变调用<code>PeerGetter</code>方法。</p>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>分布式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go-06-sort源码分析</title>
    <link href="/2021/03/20/Go-06-sort%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <url>/2021/03/20/Go-06-sort%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h4 id="基本排序算法总结"><a href="#基本排序算法总结" class="headerlink" title="基本排序算法总结"></a>基本排序算法总结</h4><h5 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h5><ul><li>从插入排序开始。插入排序基本想法就是通过交换的方式将当前元素插入到已经有序的元素序列当中。如果已经有序，那么直接扫描一遍就直接结束了；如果是完全逆序的，那么n个元素，1+2+……n-1，复杂度为$O(n^2)$。</li><li>改进：上述方式弊端就在于很小的元素可能需要移动很多次才能从数组右端移动到左端，为此对数组进行分组，使得元素可以跨多个元素直接移动。</li></ul><h5 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h5><ul><li><p>首先找到一个基准数据，根据基准数据将所有数据分成大于它的和小于它的两个分区，再对两个分区进行同样的处理。</p></li><li><p>简单示例：</p><div class="hljs"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">quickSort</span><span class="hljs-params">(s []<span class="hljs-keyword">int</span>, l, r <span class="hljs-keyword">int</span>)</span></span> &#123;<span class="hljs-keyword">if</span> l &lt; r &#123;<span class="hljs-comment">//we need index of s[l] after partition -- i</span>i := lj := rtmp := s[l]<span class="hljs-keyword">for</span> i &lt; j &#123;<span class="hljs-keyword">for</span> i &lt; j &amp;&amp; s[j] &gt;= tmp &#123;j--&#125;<span class="hljs-keyword">if</span> i &lt; j &#123;s[i] = s[j]i++&#125;<span class="hljs-keyword">for</span> i &lt; j &amp;&amp; s[i] &lt; tmp &#123;i++&#125;<span class="hljs-keyword">if</span> i &lt; j &#123;s[j] = s[i]j--&#125;&#125;s[i] = tmpquickSort(s, i+<span class="hljs-number">1</span>, r)quickSort(s, l, i<span class="hljs-number">-1</span>)&#125;&#125;</code></pre></div></li><li><p>显然，快排是不稳定的。例如连续的两个小于基准的数据，由于发现的大于基准数据的位置是由小到大变化的，会导致顺序发生翻转。</p><ul><li>具体实现可能有不同的方法。解释也就不一样了。</li></ul></li></ul><h5 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h5><ul><li><p>主要是利用建堆、重构堆从而不断得到区间内的最大元素，然后交换使其到达数组末端。</p></li><li><p>简单实现：</p><div class="hljs"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">heapModify</span><span class="hljs-params">(s []<span class="hljs-keyword">int</span>, start, end <span class="hljs-keyword">int</span>)</span></span> &#123;<span class="hljs-comment">//start为非叶子节点 意味着其至少存在孩子</span><span class="hljs-comment">//2*start+1得到左孩子</span><span class="hljs-comment">//不断往下重构</span>son := <span class="hljs-number">2</span>*start + <span class="hljs-number">1</span><span class="hljs-keyword">for</span> son &lt;= end &#123;<span class="hljs-keyword">if</span> son+<span class="hljs-number">1</span> &lt;= end &amp;&amp; s[son] &lt; s[son+<span class="hljs-number">1</span>] &#123;son++&#125;<span class="hljs-keyword">if</span> s[start] &gt; s[son] &#123;<span class="hljs-keyword">return</span>&#125;s[start], s[son] = s[son], s[start]start = sonson = start*<span class="hljs-number">2</span> + <span class="hljs-number">1</span>&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">buildHeap</span><span class="hljs-params">(s []<span class="hljs-keyword">int</span>, end <span class="hljs-keyword">int</span>)</span></span> &#123;<span class="hljs-comment">//建堆 s[0--end)</span><span class="hljs-keyword">for</span> start := (<span class="hljs-built_in">len</span>(s) / <span class="hljs-number">2</span>) - <span class="hljs-number">1</span>; start &gt;= <span class="hljs-number">0</span>; start-- &#123;heapModify(s, start, end<span class="hljs-number">-1</span>)&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">heapSort</span><span class="hljs-params">(s []<span class="hljs-keyword">int</span>)</span></span> &#123;buildHeap(s, <span class="hljs-built_in">len</span>(s))<span class="hljs-keyword">for</span> i := <span class="hljs-built_in">len</span>(s) - <span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span>; i-- &#123;s[<span class="hljs-number">0</span>], s[i] = s[i], s[<span class="hljs-number">0</span>]heapModify(s, <span class="hljs-number">0</span>, i<span class="hljs-number">-1</span>)&#125;&#125;</code></pre></div></li><li><p>堆排也是不稳定的。考虑很简单的三个元素的情况：<code>1 1 1</code>。建堆之后不需要调整（即使调整也不影响结论），那么第一个元素会变成最后一个元素。</p></li></ul><h5 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h5><ul><li><p>常见排序算法：</p><p>| Algorithm                                                  | Best-case     | Worst-case    | Average-case  | Space Complexity        | Stable?     |<br>| ————————————————————————————— | ——————- | ——————- | ——————- | ———————————- | —————- |<br>| <a href="https://brilliant.org/wiki/merge/" target="_blank" rel="noopener">Merge Sort</a>            | $O(n \log n)$ | $O(n \log n)$ | $O(n \log n)$ | $O(n)$                  | Yes         |<br>| <a href="https://brilliant.org/wiki/insertion/" target="_blank" rel="noopener">Insertion Sort</a>    | $O(n)$        | $O(n^2)$      | $O(n^2)$      | $O(1)$                  | Yes         |<br>| <a href="https://brilliant.org/wiki/bubble-sort/" target="_blank" rel="noopener">Bubble Sort</a>     | $O(n)$        | $O(n^2)$      | $o(n^2)$      | $O(1)$                  | Yes         |<br>| <a href="https://brilliant.org/wiki/quick-sort/" target="_blank" rel="noopener">Quicksort</a>        | $O(n \log n)$ | $O(n^2)$      | $O(n \log n)$ | $\log n$  best, $n$ avg | Usually not |<br>| <a href="https://brilliant.org/wiki/heap-sort/" target="_blank" rel="noopener">Heapsort</a>          | $O(n \log n)$ | $O(n\log n)$  | $O(n \log n)$ | $O(1)$                  | No          |<br>| <a href="https://brilliant.org/wiki/counting-sort/" target="_blank" rel="noopener">Counting Sort</a> | $O(k+n)$      | $O(k+n)$      | $O(k+n)$      | $O(k+n)$                | Yes         |</p></li><li><p>基于比较的排序方法的渐近下界是$\Omega( n\log n)$</p><p>可以从决策树模型简单分析：如果待排序元素为n，那么依次比较所有元素，各种情况构成一棵二叉树（从根节点到叶子节点的路径代表一种排序结果）。设决策树的高度为h，所有可能的排序种数为$n!$，而决策树最多有$2^h$个叶子节点，从而$2^h \ge n!$。两边取对数，然后使用斯特林近似公式展开就可以得到渐近下届。</p></li><li><p>实际选择排序算法需要综合多个角度考虑：</p><ul><li>数据规模</li><li>是否近似有序</li><li>稳定性要求</li><li>空间要求</li><li>cache友好</li></ul><p>……</p><p>所以尽管快排的平均时间复杂度最好，但是并非所有情况下直接上快排。</p></li></ul><h4 id="排序源码分析"><a href="#排序源码分析" class="headerlink" title="排序源码分析"></a>排序源码分析</h4><h5 id="整体结构"><a href="#整体结构" class="headerlink" title="整体结构"></a>整体结构</h5><ul><li><p>对于待排序的数据必须实现三种方法：<code>Len/Less/Swap</code></p><ul><li>目前主流的方法都是基于比较的，可以通过对<code>Less</code>进行封装从而得到大于、等于、小于等于……</li><li>根据索引进行交换也是必须的。</li></ul></li><li><p>大体上有两种：稳定排序和不稳定排序</p></li><li><p>函数调用路径</p><p>不稳定的排序：</p><p><code>sort</code></p><ul><li><code>maxDepth</code></li><li><code>quickSort</code><ul><li><code>heapSort</code><ul><li><code>siftDown</code></li></ul></li><li><code>doPivot</code><ul><li><code>medianOfThree</code></li></ul></li><li><code>insertionSort</code></li></ul></li></ul></li></ul><h5 id="qucikSort"><a href="#qucikSort" class="headerlink" title="qucikSort"></a><code>qucikSort</code></h5><div class="hljs"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">quickSort</span><span class="hljs-params">(data Interface, a, b, maxDepth <span class="hljs-keyword">int</span>)</span></span> &#123;<span class="hljs-keyword">for</span> b-a &gt; <span class="hljs-number">12</span> &#123; <span class="hljs-comment">// Use ShellSort for slices &lt;= 12 elements</span><span class="hljs-keyword">if</span> maxDepth == <span class="hljs-number">0</span> &#123;heapSort(data, a, b)<span class="hljs-keyword">return</span>&#125;maxDepth--mlo, mhi := doPivot(data, a, b)<span class="hljs-comment">// Avoiding recursion on the larger subproblem guarantees</span><span class="hljs-comment">// a stack depth of at most lg(b-a).</span><span class="hljs-keyword">if</span> mlo-a &lt; b-mhi &#123;quickSort(data, a, mlo, maxDepth)a = mhi <span class="hljs-comment">// i.e., quickSort(data, mhi, b)</span>&#125; <span class="hljs-keyword">else</span> &#123;quickSort(data, mhi, b, maxDepth)b = mlo <span class="hljs-comment">// i.e., quickSort(data, a, mlo)</span>&#125;&#125;<span class="hljs-keyword">if</span> b-a &gt; <span class="hljs-number">1</span> &#123;<span class="hljs-comment">// Do ShellSort pass with gap 6</span><span class="hljs-comment">// It could be written in this simplified form cause b-a &lt;= 12</span><span class="hljs-keyword">for</span> i := a + <span class="hljs-number">6</span>; i &lt; b; i++ &#123;<span class="hljs-keyword">if</span> data.Less(i, i<span class="hljs-number">-6</span>) &#123;data.Swap(i, i<span class="hljs-number">-6</span>)&#125;&#125;insertionSort(data, a, b)&#125;&#125;</code></pre></div><p>上面函数就是关键部分。可以看到根据数据规模和<code>maxDepth</code>选择不同的排序算法：在规模很小时选择希尔和插入；规模比较大时选择堆排序，并且递归调用了<code>quickSort</code></p><h6 id="第一个问题，maxDepth是什么？"><a href="#第一个问题，maxDepth是什么？" class="headerlink" title="第一个问题，maxDepth是什么？"></a>第一个问题，<code>maxDepth</code>是什么？</h6><div class="hljs"><pre><code class="hljs go"><span class="hljs-comment">// maxDepth returns a threshold at which quicksort should switch</span><span class="hljs-comment">// to heapsort. It returns 2*ceil(lg(n+1)).</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxDepth</span><span class="hljs-params">(n <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<span class="hljs-keyword">var</span> depth <span class="hljs-keyword">int</span><span class="hljs-keyword">for</span> i := n; i &gt; <span class="hljs-number">0</span>; i &gt;&gt;= <span class="hljs-number">1</span> &#123;depth++&#125;<span class="hljs-keyword">return</span> depth * <span class="hljs-number">2</span>&#125;</code></pre></div><p>可以知道计算的是$[\log(n+1)]$（向上取整）。所以为什么选择这种方式去衡量数据规模而不是直接根据<code>len(data)</code>？后续究竟是如何根据这一指标去选择算法的：为0时为何选择堆排？</p><h6 id="第二个问题，doPivot函数干了什么？"><a href="#第二个问题，doPivot函数干了什么？" class="headerlink" title="第二个问题，doPivot函数干了什么？"></a>第二个问题，<code>doPivot</code>函数干了什么？</h6><p>很容易让人想到快排里面选择pivot。具体仔细看：</p><div class="hljs"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">doPivot</span><span class="hljs-params">(data Interface, lo, hi <span class="hljs-keyword">int</span>)</span> <span class="hljs-params">(midlo, midhi <span class="hljs-keyword">int</span>)</span></span> &#123;m := <span class="hljs-keyword">int</span>(<span class="hljs-keyword">uint</span>(lo+hi) &gt;&gt; <span class="hljs-number">1</span>) <span class="hljs-comment">// Written like this to avoid integer overflow.</span><span class="hljs-keyword">if</span> hi-lo &gt; <span class="hljs-number">40</span> &#123;<span class="hljs-comment">// Tukey's ``Ninther,'' median of three medians of three.</span>s := (hi - lo) / <span class="hljs-number">8</span>medianOfThree(data, lo, lo+s, lo+<span class="hljs-number">2</span>*s)medianOfThree(data, m, m-s, m+s)medianOfThree(data, hi<span class="hljs-number">-1</span>, hi<span class="hljs-number">-1</span>-s, hi<span class="hljs-number">-1</span><span class="hljs-number">-2</span>*s)&#125;medianOfThree(data, lo, m, hi<span class="hljs-number">-1</span>)</code></pre></div><p>其中的<code>medianOfThree</code>：</p><div class="hljs"><pre><code class="hljs go"><span class="hljs-comment">// medianOfThree moves the median of the three values data[m0], data[m1], data[m2] into data[m1].</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">medianOfThree</span><span class="hljs-params">(data Interface, m1, m0, m2 <span class="hljs-keyword">int</span>)</span></span> &#123;<span class="hljs-comment">// sort 3 elements</span><span class="hljs-keyword">if</span> data.Less(m1, m0) &#123;data.Swap(m1, m0)&#125;<span class="hljs-comment">// data[m0] &lt;= data[m1]</span><span class="hljs-keyword">if</span> data.Less(m2, m1) &#123;data.Swap(m2, m1)<span class="hljs-comment">// data[m0] &lt;= data[m2] &amp;&amp; data[m1] &lt; data[m2]</span><span class="hljs-keyword">if</span> data.Less(m1, m0) &#123;data.Swap(m1, m0)&#125;&#125;<span class="hljs-comment">// now data[m0] &lt;= data[m1] &lt;= data[m2]</span>&#125;</code></pre></div><p>可以看出来，上面函数的作用就是将中间值移到<code>m1</code>，最小值放在<code>m0</code>。结合注释，我们知道了<code>doPivot</code>首先会尝试找到中间值。如果数据长度超过40，那么我们取出九个点：<code>lo lo+s······hi-1</code>，然后每三个找出中间值，最后再找出三者中的中间值，最后中间值位于<code>lo</code>处。如果长度比较小，那么直接根据<code>lo m hi</code>取中间值即可。</p><p>之后需要对数据划分。值得注意的是，这里的<code>Less</code>就是严格小于。细节看注释。</p><div class="hljs"><pre><code class="hljs go">pivot := loa, c := lo+<span class="hljs-number">1</span>, hi<span class="hljs-number">-1</span><span class="hljs-keyword">for</span> ; a &lt; c &amp;&amp; data.Less(a, pivot); a++ &#123;&#125; <span class="hljs-comment">//结束时 a == c 或者 data[lo &lt; i &lt; a] &lt; data[pivot] 这一段是小于基准的</span>b := a<span class="hljs-keyword">for</span> &#123;<span class="hljs-keyword">for</span> ; b &lt; c &amp;&amp; !data.Less(pivot, b); b++ &#123; <span class="hljs-comment">// data[b] &lt;= pivot 注意!Less 等价于 data[pivot] &gt;= data[b]</span>&#125;<span class="hljs-keyword">for</span> ; b &lt; c &amp;&amp; data.Less(pivot, c<span class="hljs-number">-1</span>); c-- &#123; <span class="hljs-comment">// data[c-1] &gt; pivot </span>            <span class="hljs-comment">//从hi-2开始是因为前面的划分中hi-1已经大于等于pivot了</span>&#125;        <span class="hljs-comment">//此时：</span>        <span class="hljs-comment">/*</span><span class="hljs-comment">        data[c &lt;= i &lt; hi-1] &gt; pivot</span><span class="hljs-comment">        data[lo] = pivot (set up by ChoosePivot)</span><span class="hljs-comment">data[lo &lt; i &lt; a] &lt; pivot</span><span class="hljs-comment">data[a &lt;= i &lt; b] &lt;= pivot</span><span class="hljs-comment">如果b == c说明已经划分完毕</span><span class="hljs-comment">        */</span><span class="hljs-keyword">if</span> b &gt;= c &#123;<span class="hljs-keyword">break</span>&#125;<span class="hljs-comment">// data[b] &gt; pivot; data[c-1] &lt;= pivot </span>        <span class="hljs-comment">//交换之后使得data[a &lt;= i &lt;= b] &lt;= pivot data[c-1 &lt;= i &lt; hi -1] 所以b++ c-- 维持不变式</span>data.Swap(b, c<span class="hljs-number">-1</span>)b++c--&#125;</code></pre></div><p>总之，上述过程结束之后，我们完成了对数据的分区。</p><p>最后，<code>doPivot</code>返回了第一个分区最后一个数据的索引和第二个分区第一个索引。</p><h6 id="quickSort结构梳理"><a href="#quickSort结构梳理" class="headerlink" title="quickSort结构梳理"></a><code>quickSort</code>结构梳理</h6><p>在解决了上面两个问题之后，我们对这个函数有了初步的整体性的理解。在数据长度大于12、<code>maxDepth</code>不为0时，我们会分区、再递归排序。这里为了避免出现递归爆栈的问题，每次都是选择一个较小的分区进行快排，然后通过<code>a = mhi or b = mlo</code>，从而使得下次调用<code>doPivot</code>时对另外一个分区进行划分、快排。</p><h5 id="希尔排序-1"><a href="#希尔排序-1" class="headerlink" title="希尔排序"></a>希尔排序</h5><p>在数据长度小于12时，我们使用的是希尔排序。这里直接将步长设为6，然后进行插入排序。实现很简单。</p><h5 id="heapSort"><a href="#heapSort" class="headerlink" title="heapSort"></a><code>heapSort</code></h5><p>整体结构和示例中的类似：</p><div class="hljs"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">heapSort</span><span class="hljs-params">(data Interface, a, b <span class="hljs-keyword">int</span>)</span></span> &#123;first := alo := <span class="hljs-number">0</span>hi := b - a<span class="hljs-comment">// Build heap with greatest element at top.</span><span class="hljs-keyword">for</span> i := (hi - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i-- &#123;siftDown(data, i, hi, first)&#125;<span class="hljs-comment">// Pop elements, largest first, into end of data.</span><span class="hljs-keyword">for</span> i := hi - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i-- &#123;data.Swap(first, first+i)siftDown(data, lo, i, first)&#125;&#125;</code></pre></div><p>主要是用到了<code>siftDown</code>这个函数，作用是重构堆。</p><div class="hljs"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">siftDown</span><span class="hljs-params">(data Interface, lo, hi, first <span class="hljs-keyword">int</span>)</span></span> &#123;root := lo<span class="hljs-keyword">for</span> &#123;child := <span class="hljs-number">2</span>*root + <span class="hljs-number">1</span><span class="hljs-keyword">if</span> child &gt;= hi &#123;<span class="hljs-keyword">break</span>&#125;<span class="hljs-keyword">if</span> child+<span class="hljs-number">1</span> &lt; hi &amp;&amp; data.Less(first+child, first+child+<span class="hljs-number">1</span>) &#123;child++&#125;<span class="hljs-keyword">if</span> !data.Less(first+root, first+child) &#123;<span class="hljs-keyword">return</span>&#125;data.Swap(first+root, first+child)root = child&#125;&#125;</code></pre></div><p>这里实现和上面示例也很类似，需要注意的就是我们是对区间[a,b)排序，所以以a为基础转移至区间[0,b-a)上，在比较元素时又需要原数组的索引，所以再传入<code>first int</code>。</p><h5 id="稳定排序"><a href="#稳定排序" class="headerlink" title="稳定排序"></a>稳定排序</h5><p>从函数<code>stable</code>开始：</p><div class="hljs"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">stable</span><span class="hljs-params">(data Interface, n <span class="hljs-keyword">int</span>)</span></span> &#123;blockSize := <span class="hljs-number">20</span> <span class="hljs-comment">// must be &gt; 0</span>a, b := <span class="hljs-number">0</span>, blockSize<span class="hljs-keyword">for</span> b &lt;= n &#123;insertionSort(data, a, b)a = bb += blockSize&#125;insertionSort(data, a, n)<span class="hljs-keyword">for</span> blockSize &lt; n &#123;a, b = <span class="hljs-number">0</span>, <span class="hljs-number">2</span>*blockSize<span class="hljs-keyword">for</span> b &lt;= n &#123;symMerge(data, a, a+blockSize, b)a = bb += <span class="hljs-number">2</span> * blockSize&#125;<span class="hljs-keyword">if</span> m := a + blockSize; m &lt; n &#123;symMerge(data, a, m, n)&#125;blockSize *= <span class="hljs-number">2</span>&#125;&#125;</code></pre></div><p>第一部分很直白，因为插入排序是稳定的、数据量小时表现很好，所以我们每20个元素都插入排序一次，最后不足20个也插入排序。</p><p>对于第二部分主要是调用了<code>symMerge</code>函数合并两个<code>blockSize</code>大小的元素(最后不足两个的部分类似处理)，<code>blockSize</code>不断翻倍。</p><h6 id="symMerge"><a href="#symMerge" class="headerlink" title="symMerge"></a><code>symMerge</code></h6><p>由于代码比较长、贴出来不怎么好看，所以直接解释。</p><p>第一部分：如果任何一部分（我们传入了三个数，表示两个有序部分，需要将它们合并）只有一个元素，那么将另外一边使用二分查找得到待插入的位置索引，然后不断交换插入到该位置。</p><p>第二部分：比较难以理解。看注释：</p><blockquote><p>symMerge merges the two sorted subsequences data[a:m] and data[m:b] using the SymMerge algorithm from Pok-Son Kim and Arne Kutzner, “Stable Minimum Storage Merging by Symmetric Comparisons”, in Susanne Albers and Tomasz Radzik, editors, Algorithms - ESA 2004, volume 3221 of Lecture Notes in Computer Science, pages 714-723. Springer, 2004.</p></blockquote><p><a href="http://itbe.hanyang.ac.kr/ak/papers/esa2004.pdf" target="_blank" rel="noopener">这篇论文</a>前面的部分已经足够详细地解释了SYM-Merge算法，从一个线性的对称比较的方法改进到基于二分查找。后面主要是最坏情况下的性能分析以及实际上的效果。</p><p><img src="https://i.loli.net/2021/03/31/nMsk9tVgjYTINO5.png" srcset="/img/loading.gif" alt="image-20210331151538169" style="zoom:67%;" /></p><p>和源码中几乎一致。</p><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><h5 id="内建数据类型切片的排序"><a href="#内建数据类型切片的排序" class="headerlink" title="内建数据类型切片的排序"></a>内建数据类型切片的排序</h5><p>sort包支持int/float64/string三种内置类型的切片的排序。以int切片为例：</p><div class="hljs"><pre><code class="hljs go"><span class="hljs-comment">// Ints sorts a slice of ints in increasing order.</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Ints</span><span class="hljs-params">(x []<span class="hljs-keyword">int</span>)</span></span> &#123; Sort(IntSlice(x)) &#125;</code></pre></div><p>首先将x转换为<code>IntSlice</code>，因为其实现了接口，直接调用<code>Sort()</code>即可。</p><h5 id="sort包中的其他文件"><a href="#sort包中的其他文件" class="headerlink" title="sort包中的其他文件"></a>sort包中的其他文件</h5><ul><li><code>example</code>开头的文件：都是一些实际使用sort的例子。</li><li><code>slice.go</code>：提供接口使得我们只需要传入切片和<code>less</code>函数就可以排序，这样不用我们自己每次定义<code>swap</code>函数——基于反射。</li><li><code>search</code>：使用“二分查找”算法来找出能使 <code>f(x)(0&lt;=x&lt;n)</code> 返回 ture 的最小值 i。 前提条件 : <code>f(x)(0&lt;=x&lt;i)</code>均返回 false,<code>f(x)(i&lt;=x&lt;n)</code> 均返回 ture。 如果不存在 i 可以使 f(i) 返回 ture, 则返回 n。</li></ul><h5 id="降序排序的实现"><a href="#降序排序的实现" class="headerlink" title="降序排序的实现"></a>降序排序的实现</h5><div class="hljs"><pre><code class="hljs go"><span class="hljs-keyword">type</span> reverse <span class="hljs-keyword">struct</span> &#123;<span class="hljs-comment">// This embedded Interface permits Reverse to use the methods of</span><span class="hljs-comment">// another Interface implementation.</span>Interface&#125;<span class="hljs-comment">// Less returns the opposite of the embedded implementation's Less method.</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r reverse)</span> <span class="hljs-title">Less</span><span class="hljs-params">(i, j <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">bool</span></span> &#123;<span class="hljs-keyword">return</span> r.Interface.Less(j, i)&#125;<span class="hljs-comment">// Reverse returns the reverse order for data.</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Reverse</span><span class="hljs-params">(data Interface)</span> <span class="hljs-title">Interface</span></span> &#123;<span class="hljs-keyword">return</span> &amp;reverse&#123;data&#125;&#125;</code></pre></div><p>我们实际使用时，先调用<code>Reverse</code>将待排序的数据转换成<code>reverse</code>这个结构体，该结构体的<code>Less</code>方法与原本数据的<code>Less</code>方法刚好相反，另外的方法不用改动。</p>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go-05-并发编程</title>
    <link href="/2021/03/19/Go-05-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    <url>/2021/03/19/Go-05-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h4 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h4><p>之前在操作系统实验中，进程/线程之间的通信我们主要有三种方式：信号量；消息队列；共享内存。实现起来其实是比较麻烦的，因为我们一般需要对系统调用进行封装，方便我们后续调用；并且对于共享资源访问时需要实现各种锁的机制，比如信号量/互斥锁。</p><h4 id="channel"><a href="#channel" class="headerlink" title="channel"></a>channel</h4><h5 id="理解channel"><a href="#理解channel" class="headerlink" title="理解channel"></a>理解channel</h5><ul><li>悲观锁与乐观锁<ul><li>悲观：假定每次持有数据时别人都会尝试修改，所以会给数据加锁。因此共享资源每次都会只有一个线程持有。适合多写的场景</li><li>乐观：假定持有数据时别人不会修改，因此不会上锁。但是在更新时会判断别人是否修改了数据，具体实现可以使用版本号/CAS。</li></ul></li></ul><p>相比C/C++里面使用系统调用、手动上锁，channel显然方便了很多。</p><h5 id="实现细节"><a href="#实现细节" class="headerlink" title="实现细节"></a>实现细节</h5><ul><li><p><code>hchan</code>结构体：</p><div class="hljs"><pre><code class="hljs go"><span class="hljs-keyword">type</span> hchan <span class="hljs-keyword">struct</span> &#123;qcount   <span class="hljs-keyword">uint</span>           <span class="hljs-comment">// 队列中元素总数量</span>dataqsiz <span class="hljs-keyword">uint</span>           <span class="hljs-comment">// 循环队列的长度</span>buf      unsafe.Pointer <span class="hljs-comment">// 指向长度为 dataqsiz 的底层数组，只有在有缓冲时这个才有意义</span>elemsize <span class="hljs-keyword">uint16</span>         <span class="hljs-comment">// 能够发送和接受的元素大小</span>closed   <span class="hljs-keyword">uint32</span>         <span class="hljs-comment">// 是否关闭</span>elemtype *_type <span class="hljs-comment">// 元素的类型</span>sendx    <span class="hljs-keyword">uint</span>   <span class="hljs-comment">// 当前已发送的元素在队列当中的索引位置</span>recvx    <span class="hljs-keyword">uint</span>   <span class="hljs-comment">// 当前已接收的元素在队列当中的索引位置</span>recvq    waitq  <span class="hljs-comment">// 接收 Goroutine 链表</span>sendq    waitq  <span class="hljs-comment">// 发送 Goroutine 链表</span>lock mutex <span class="hljs-comment">// 互斥锁</span>&#125;<span class="hljs-comment">// waitq 是一个双向链表，里面保存了 goroutine</span><span class="hljs-keyword">type</span> waitq <span class="hljs-keyword">struct</span> &#123;first *sudoglast  *sudog&#125;</code></pre></div></li><li><p>创建策略：</p><ul><li>无缓冲：直接给<code>hchan</code>分配内存</li><li>有缓冲：<ul><li>无指针：给<code>hchan</code>和底层数组分配一段连续的内存空间</li><li>有指针：为<code>hchan</code>和底层数组分别分配内存</li></ul></li></ul></li><li><p>发送数据：主要工作由<code>chansend</code>完成。逻辑大致如下：（存在加锁解锁的行为，这里略去）</p><ul><li><p>一些提前的判断处理</p></li><li><p>已经关闭了，直接<code>panic</code></p></li><li><p>如果存在阻塞等待数据的goroutine，那么将数据传给它，然后返回</p><ul><li>修改goroutine状态为可运行的，并将其放到发送数据的goroutine所在的p的<code>runnext</code>。</li></ul></li><li><p>如果存在缓冲区并且缓冲区没有满，那么加入缓冲区。注意是环形队列，变量更新。</p></li><li><p>如果处理到这里，说明上述条件都不会满足。如果是非阻塞的，那么直接返回，如果是阻塞的，那么我们需要对goroutine进行后续的处理：</p><ul><li>设置相关信息</li></ul></li></ul></li><li>加入等待队列：sendq<ul><li>挂起当前goroutine</li><li>保证当前数据处于活跃状态避免被回收</li><li>……</li></ul></li></ul><h5 id="关闭channel"><a href="#关闭channel" class="headerlink" title="关闭channel"></a>关闭channel</h5><ul><li>不要从接收端关闭channel，也不要关闭有多个发送者的channel，从而避免panic。</li><li>多生产者消费者的情况下，可以让第三方的goroutine在设定情况——例如<code>wg.Wait()</code>之后关闭channel。或者让最后一个生产者关闭channel也可以。</li></ul><h4 id="sync包"><a href="#sync包" class="headerlink" title="sync包"></a>sync包</h4><h5 id="互斥锁Mutex"><a href="#互斥锁Mutex" class="headerlink" title="互斥锁Mutex"></a>互斥锁Mutex</h5><p>类似于初值为1的信号量，只是用起来更加方便。看上去也非常的暴力。</p><div class="hljs"><pre><code class="hljs go"><span class="hljs-keyword">var</span> mu sync.Mutexmu.Lock()mu.Unlock()</code></pre></div><h5 id="读写锁RWMutex"><a href="#读写锁RWMutex" class="headerlink" title="读写锁RWMutex"></a>读写锁RWMutex</h5><h5 id="sync-Once"><a href="#sync-Once" class="headerlink" title="sync.Once"></a><code>sync.Once</code></h5><p>顾名思义，可以确保某个函数只执行一次，而且是并发安全的，一般可以用来初始化变量。</p><p>实现原理也非常简单：标记函数是否执行过；没有，那么使用互斥锁，执行，并标记。</p><div class="hljs"><pre><code class="hljs go"><span class="hljs-keyword">package</span> sync<span class="hljs-keyword">import</span> (    <span class="hljs-string">"sync/atomic"</span>)<span class="hljs-keyword">type</span> Once <span class="hljs-keyword">struct</span> &#123;    done <span class="hljs-keyword">uint32</span>    m    Mutex&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(o *Once)</span> <span class="hljs-title">Do</span><span class="hljs-params">(f <span class="hljs-keyword">func</span>()</span>)</span> &#123;    <span class="hljs-keyword">if</span> atomic.LoadUint32(&amp;o.done) == <span class="hljs-number">0</span> &#123;        o.doSlow(f)    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(o *Once)</span> <span class="hljs-title">doSlow</span><span class="hljs-params">(f <span class="hljs-keyword">func</span>()</span>)</span> &#123;    o.m.Lock()    <span class="hljs-keyword">defer</span> o.m.Unlock()    <span class="hljs-keyword">if</span> o.done == <span class="hljs-number">0</span> &#123;        <span class="hljs-keyword">defer</span> atomic.StoreUint32(&amp;o.done, <span class="hljs-number">1</span>)        f()    &#125;&#125;</code></pre></div><p>值得注意的是注释部分：</p><div class="hljs"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Once <span class="hljs-keyword">struct</span> &#123;    <span class="hljs-comment">// done indicates whether the action has been performed.</span>    <span class="hljs-comment">// It is first in the struct because it is used in the hot path.</span>    <span class="hljs-comment">// The hot path is inlined at every call site.</span>    <span class="hljs-comment">// Placing done first allows more compact instructions on some architectures (amd64/x86),</span>    <span class="hljs-comment">// and fewer instructions (to calculate offset) on other architectures.</span>    done <span class="hljs-keyword">uint32</span>    m    Mutex&#125;</code></pre></div><p>解释：对于结构体的第一个字段的访问可以通过直接对指针解引用得到，但是之后的字段则需要加上一个偏移量——前者无疑更快速。从而将访问较多的<code>done</code>放到第一位可以提升性能。</p><h5 id="sync-Pool"><a href="#sync-Pool" class="headerlink" title="sync.Pool"></a><code>sync.Pool</code></h5><p>保存和复用临时对象，从而减少内存分配、降低GC压力。</p><div class="hljs"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Pool <span class="hljs-keyword">struct</span> &#123;    <span class="hljs-comment">// New optionally specifies a function to generate</span>    <span class="hljs-comment">// a value when Get would otherwise return nil.</span>    <span class="hljs-comment">// It may not be changed concurrently with calls to Get.</span>    New <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span> <span class="hljs-title">interface</span></span>&#123;&#125;    <span class="hljs-comment">// contains filtered or unexported fields</span>&#125;</code></pre></div><p>创建时可以定义一个返回空接口的函数。</p><h4 id="Context包"><a href="#Context包" class="headerlink" title="Context包"></a>Context包</h4><h4 id="实际场景应用"><a href="#实际场景应用" class="headerlink" title="实际场景应用"></a>实际场景应用</h4><h5 id="结束goroutine"><a href="#结束goroutine" class="headerlink" title="结束goroutine"></a>结束goroutine</h5><ul><li><p>单个：A结束B：使用channel+select的方式。</p><p>我们可以在A中创建一个channel，在B中for循环select监听该channel。A想要结束B，就发送消息，那么B select满足条件之后结束退出。</p><p>这种方式无法应对多个B的情况。</p></li><li><p>context包：非常方便。</p><div class="hljs"><pre><code class="hljs go">ctx,cancel := context.WithCancel(context.Background())<span class="hljs-comment">//启动goroutine时传入ctx从而可以跟踪goroutine</span><span class="hljs-keyword">for</span>&#123;    <span class="hljs-keyword">select</span>&#123;        <span class="hljs-keyword">case</span> &lt;-ctx.Done():        <span class="hljs-keyword">return</span>        <span class="hljs-keyword">default</span>:        ......    &#125;&#125;<span class="hljs-comment">//“父goroutine”直接调用cancel()那么所有其创建的goroutine都会结束</span></code></pre></div></li></ul><h5 id="经典同步问题"><a href="#经典同步问题" class="headerlink" title="经典同步问题"></a>经典同步问题</h5><ul><li><p>生产者消费者问题</p><div class="hljs"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">"context"</span><span class="hljs-string">"fmt"</span><span class="hljs-string">"time"</span>)<span class="hljs-keyword">const</span> numConsumer = <span class="hljs-number">10</span><span class="hljs-keyword">const</span> numProducer = <span class="hljs-number">10</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">producer</span><span class="hljs-params">(ctx context.Context,src <span class="hljs-keyword">chan</span>&lt;- <span class="hljs-keyword">int</span>, index <span class="hljs-keyword">int</span>)</span></span> &#123;<span class="hljs-keyword">for</span> &#123;<span class="hljs-keyword">select</span> &#123;<span class="hljs-keyword">case</span> &lt;-ctx.Done():<span class="hljs-keyword">return</span><span class="hljs-keyword">default</span>:src &lt;- indexfmt.Printf(<span class="hljs-string">"%d producer puts %d\n"</span>, index, index)&#125;&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">consumer</span><span class="hljs-params">(ctx context.Context,src &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>, index <span class="hljs-keyword">int</span>)</span></span> &#123;<span class="hljs-keyword">for</span> &#123;<span class="hljs-keyword">select</span> &#123;<span class="hljs-keyword">case</span> &lt;-ctx.Done():<span class="hljs-keyword">return</span><span class="hljs-keyword">default</span>:<span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> src &#123;fmt.Printf(<span class="hljs-string">"%d consumer get %d\n"</span>, index, i)&#125;&#125;&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;ctx, cancel := context.WithCancel(context.Background())src := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>, <span class="hljs-number">5</span>)<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;<span class="hljs-keyword">go</span> producer(ctx, src, i)<span class="hljs-keyword">go</span> consumer(ctx, src, i)&#125;time.Sleep(time.Second * <span class="hljs-number">1</span>)cancel()<span class="hljs-built_in">close</span>(src)&#125;</code></pre></div></li><li><p>轮流执行：多个goroutine按照特定顺序执行</p><p>e.g：有三个函数 分别可以打印AAA BBB CCC，要求每个函数都起一个goroutine按照上面的顺序打印在屏幕上</p><p>第一种方式：启动三个goroutine，每个goroutine内部循环打印，通过无缓冲channel控制执行的顺序；通过WaitGroup来等待结束；注意为了保证能正常运行，最后一次不要再向channel发送，否则会阻塞。</p><div class="hljs"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">"fmt"</span><span class="hljs-string">"sync"</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;cha := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;)chb := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;)chc := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;)<span class="hljs-keyword">defer</span> <span class="hljs-built_in">close</span>(cha)<span class="hljs-keyword">defer</span> <span class="hljs-built_in">close</span>(chb)<span class="hljs-keyword">defer</span> <span class="hljs-built_in">close</span>(chc)<span class="hljs-keyword">var</span> wg sync.WaitGroupwg.Add(<span class="hljs-number">3</span>)<span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(wg *sync.WaitGroup)</span></span> &#123;<span class="hljs-keyword">defer</span> wg.Done()<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++ &#123;&lt;-chafmt.Printf(<span class="hljs-string">"AAA\n"</span>)chb &lt;- <span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125;&#125;&#125;(&amp;wg)<span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(wg *sync.WaitGroup)</span></span> &#123;<span class="hljs-keyword">defer</span> wg.Done()<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++ &#123;&lt;-chbfmt.Printf(<span class="hljs-string">"BBB\n"</span>)chc &lt;- <span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125;&#125;&#125;(&amp;wg)<span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(wg *sync.WaitGroup)</span></span> &#123;<span class="hljs-keyword">defer</span> wg.Done()<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++ &#123;&lt;-chcfmt.Printf(<span class="hljs-string">"CCC\n"</span>)<span class="hljs-keyword">if</span> i != <span class="hljs-number">99</span> &#123;cha &lt;- <span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125;&#125;&#125;&#125;(&amp;wg)cha &lt;- <span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125;wg.Wait()&#125;</code></pre></div><p>当然，直接在main函数中循环100次，每次创建三个goroutine去执行也是可以的，代码更加的简洁。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go-04-内存管理</title>
    <link href="/2021/03/18/Go-04-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <url>/2021/03/18/Go-04-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h5 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h5><p>常见的内存分配方式</p><ul><li>线性分配：无法直接重用已经释放的空闲内存，需要配合特定的GC算法</li><li>空闲链表分配：通过指针构成的链表，分配时需要遍历整个链表。联想起操作系统里面学过的给页分配内存。只不过这里是在堆上进行分配。自然有多种分配算法：First-Fit/Best-Fit……<ul><li>隔离适应策略：分级。每个链表内存块均相同，不同内存块不同。</li></ul></li></ul><p>Go采用多级缓存内存分配</p><ul><li><p>类似于TCmalloc</p></li><li><p>根据申请内存的大小分为三个级别，微对象、小对象、大对象。</p></li><li><p>线程内部有thread cache，上一级是central cache，最高级是page heap。大对象直接在page heap上面分配大内存。</p></li></ul><p>在1.10及其之前我们是堆区的内存是连续的：分为三个区域，分别是spans/bitmap/arena，其中arena分成了很多的页，每一页8KB。spans区域存储的是指针，指向内存管理单元msapn。arena是真正的堆区，bitmap用于标示哪些被使用了。</p><ul><li>bitmap中一个字节对应着arena中的32字节。<strong>4bits标记是否有指针，4bits标记扫描。与GC的关系？</strong></li></ul><p>在1.11开始将堆分成很多的页——稀疏内存。</p><p>注意所有的内存最终都是需要向操作系统申请的。<strong>怎么申请的？返回的是什么？mmap等系统调用？</strong></p><h4 id="内存管理组件"><a href="#内存管理组件" class="headerlink" title="内存管理组件"></a>内存管理组件</h4><p>小结：</p><p>每一个P都会持有一个mcache：指向一个mcache结构体的指针。这个结构体中有一个alloc成员，其是一个指针数组，每一个指针指向一个内存管理单元mspan。数组长度为numSpanClass。</p><ul><li>总共有67+1个跨度类，spanClass是uint8类型的整数，高7位为类别，低位是标记是否含有指针——GC会对标记了的进行扫描。</li></ul><h5 id="mspan："><a href="#mspan：" class="headerlink" title="mspan："></a>mspan：</h5><ul><li>拥有两个指针，分别指向前后的mspan，构成双向链表的结构。</li></ul><ul><li><code>startAddr</code> 和 <code>npages</code> — 确定该结构体管理的多个页所在的内存，每个页的大小都是 8KB；</li><li><code>freeindex</code> — 扫描页中空闲对象的初始索引；</li><li><code>allocBits</code> 和 <code>gcmarkBits</code> — 分别用于标记内存的占用和回收情况；</li><li><code>allocCache</code> — <code>allocBits</code> 的补码，可以用于快速查找内存中未被使用的内存</li></ul><p>mcache</p><p>初始化：</p><p>在初始化P的时候，会调用<code>runtime.allocmcache</code>初始化线程的缓存，其会调用<code>runtime.mheap</code>中的线程缓存分配器来初始化。</p>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go-02-接口与反射</title>
    <link href="/2021/03/16/Go-02-%E6%8E%A5%E5%8F%A3%E4%B8%8E%E5%8F%8D%E5%B0%84/"/>
    <url>/2021/03/16/Go-02-%E6%8E%A5%E5%8F%A3%E4%B8%8E%E5%8F%8D%E5%B0%84/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go-01-GMP模型</title>
    <link href="/2021/03/16/Go-01-GMP%E6%A8%A1%E5%9E%8B/"/>
    <url>/2021/03/16/Go-01-GMP%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h5 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h5><ul><li><p><a href="https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-goroutine/#651-%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86" target="_blank" rel="noopener">https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-goroutine/#651-%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86</a></p><p>《Go语言设计与实现》</p></li><li><p><a href="https://juejin.cn/post/6886321367604527112" target="_blank" rel="noopener">https://juejin.cn/post/6886321367604527112</a> </p></li></ul><h5 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h5><p>task_struct结构体成员非常多，400个左右</p><h5 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h5><h5 id="调度的整体流程"><a href="#调度的整体流程" class="headerlink" title="调度的整体流程"></a>调度的整体流程</h5><ul><li>P中存在着一个本地队列以及<code>runnext guintptr</code>，用于M获取runable的G。M首先要与P绑定，然后不断地获取G去执行。</li><li>获取过程：<ul><li>如果M绑定的P为空，那么前往全局队列尝试获取G<ul><li>如果全局队列仍然为空，那么work-stealing</li><li>如果一直没有G，那么进入idle状态</li></ul></li></ul></li><li>执行过程：<ul><li>如果G因为systemcall而阻塞，那么对应的M也会阻塞。这是M会与P解绑，P会尝试绑定一个休眠的M；如果没有休眠的M但是本地队列中仍然存在G需要执行，那么就去创建一个M。当系统调用完成之后？<strong>ToDo</strong></li><li>如果G因为channel阻塞，那么G会被放到某个等待队列——关于channel的具体实现，M会尝试获取下一个G。当原本的G被G1唤醒时，会被加入到G1所在P的<code>runnext</code>。</li><li>如果没有阻塞，那么M执行完毕之后不会被销毁，而是继续获取G再执行，这样就避免了线程创建销毁带来的开销。获取：首先切换到自身的G: g0，由g0调度一个G然后切换运行。</li></ul></li></ul><h5 id="设计原理"><a href="#设计原理" class="headerlink" title="设计原理"></a>设计原理</h5><p>很早版本的单线程调度器已经有了G和M，下面是切换G时保存状态的代码：</p><div class="hljs"><pre><code class="hljs assembly">TEXT gosave(SB), 7, $0MOVQ8(SP), AX&#x2F;&#x2F; gobufMOVQSP, 0(AX)&#x2F;&#x2F; save SPMOVQ0(SP), BXMOVQBX, 8(AX)&#x2F;&#x2F; save PCMOVL$0, AX&#x2F;&#x2F; return 0RET</code></pre></div><h5 id="实现细节"><a href="#实现细节" class="headerlink" title="实现细节"></a>实现细节</h5><ul><li><p>Goroutine就是一个<code>runtime.go</code>的结构体，里面存储了很多数据，包括执行栈、状态、当前占用的线程等等。</p><div class="hljs"><pre><code class="hljs go"><span class="hljs-keyword">type</span> g <span class="hljs-keyword">struct</span> &#123;stack <span class="hljs-keyword">struct</span> &#123;lo <span class="hljs-keyword">uintptr</span>hi <span class="hljs-keyword">uintptr</span>&#125; <span class="hljs-comment">// 栈内存：[stack.lo, stack.hi)</span>stackguard0<span class="hljs-keyword">uintptr</span>stackguard1 <span class="hljs-keyword">uintptr</span>_panic       *_panic_defer       *_deferm            *m<span class="hljs-comment">// 当前的 m</span>sched        gobuf          <span class="hljs-comment">//包括sp/pc等信息 用于切换、恢复上下文</span>stktopsp     <span class="hljs-keyword">uintptr</span><span class="hljs-comment">// 期望 sp 位于栈顶，用于回溯检查</span>param        unsafe.Pointer <span class="hljs-comment">// wakeup 唤醒时候传递的参数</span>atomicstatus <span class="hljs-keyword">uint32</span>goid         <span class="hljs-keyword">int64</span>preempt      <span class="hljs-keyword">bool</span>       <span class="hljs-comment">// 抢占信号，stackguard0 = stackpreempt 的副本</span>timer        *timer         <span class="hljs-comment">// 为 time.Sleep 缓存的计时器</span>...&#125;</code></pre></div></li><li><p>M对应<code>runtime.m</code>结构体。个数上限为<code>GOMAXPROCS</code>，默认等于核心个数，从而可以减少上下文切换带来的开销。</p><div class="hljs"><pre><code class="hljs go"><span class="hljs-keyword">type</span> m <span class="hljs-keyword">struct</span> &#123;g0   *g <span class="hljs-comment">//与运行时调度密切相关</span>curg *g<span class="hljs-comment">//当前正在执行的G</span>...    p             puintptr<span class="hljs-comment">//当前绑定的P</span>nextp         puintptroldp          puintptr    ...&#125;</code></pre></div></li><li><p>P对应<code>runtime.p</code>结构体。</p><div class="hljs"><pre><code class="hljs go"><span class="hljs-keyword">type</span> p <span class="hljs-keyword">struct</span> &#123;m           muintptrrunqhead <span class="hljs-keyword">uint32</span>runqtail <span class="hljs-keyword">uint32</span>runq     [<span class="hljs-number">256</span>]guintptr<span class="hljs-comment">//</span>runnext guintptr...&#125;</code></pre></div></li></ul><h5 id="状态流转"><a href="#状态流转" class="headerlink" title="状态流转"></a>状态流转</h5><h5 id="sysmon"><a href="#sysmon" class="headerlink" title="sysmon"></a>sysmon</h5><h5 id="M的spin-unspin"><a href="#M的spin-unspin" class="headerlink" title="M的spin/unspin"></a>M的spin/unspin</h5><h5 id="LockOSThread"><a href="#LockOSThread" class="headerlink" title="LockOSThread"></a>LockOSThread</h5>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Nachos-01-线程管理</title>
    <link href="/2021/03/15/Nachos-01-%E7%BA%BF%E7%A8%8B%E7%AE%A1%E7%90%86/"/>
    <url>/2021/03/15/Nachos-01-%E7%BA%BF%E7%A8%8B%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<hr><p>在学操作系统的时候就有很多疑惑：</p><ul><li>上下文切换细节是什么，硬件软件层面分别做了哪些具体的工作？</li><li>线程的映射模型到底是什么意思？什么是映射？为何需要映射？不同的映射模型到底是如何实现的？</li><li>共享内存是如何实现的？怎么映射到同一块内存——物理的？Linux里面<code>task_struct</code>结构体中拥有指向<code>mm_struct</code>的指针，对<code>mm_struct</code>的理解</li><li>第一个进程是如何创建的？</li></ul><p>……</p><p>产生疑惑的重要原因就在于没有看内核设计、没有看源码，导致都是在一些抽象概念上面游走。所以现在结合Nachos以及Linux内核设计与实现来真正理解OS。当然，并不会逐句分析源码，仅仅分析关键部分。</p><blockquote><p>以下内容主要围绕参考书的问题</p></blockquote><h5 id="Nachos命令行参数及其处理"><a href="#Nachos命令行参数及其处理" class="headerlink" title="Nachos命令行参数及其处理"></a>Nachos命令行参数及其处理</h5><p>主要是赋给初始化函数，然后处理一些debug相关的设置。</p><h5 id="main线程的创建"><a href="#main线程的创建" class="headerlink" title="main线程的创建"></a>main线程的创建</h5><p><code>main.cc--&gt;system.cc.Initialize--&gt;currentthread = new Thread(&quot;main&quot;)</code></p><p><code>thread.h</code>定义了线程类，我们创建线程的时候只需要提供一个<code>char * debugName</code>。真正执行时我们会用到<code>fork</code>函数：<code>void Fork(VoidFunctionPtr func, _int arg); // Make thread run (*func)(arg)</code>。</p><div class="hljs"><pre><code class="hljs c++">currentThread = <span class="hljs-keyword">new</span> Thread(<span class="hljs-string">"main"</span>);currentThread-&gt;setStatus(RUNNING);</code></pre></div><p>在<code>new Thread</code>之后我们进入了<code>thread</code>类的构造函数，不过目前我们并没有为其分配栈等资源，状态为<code>JUST_CREATED</code>。</p><p><img src="https://i.loli.net/2021/03/24/4VeKdGRlAnYoarp.png" srcset="/img/loading.gif" alt="image-20210324145718373"></p><p>可以看到<strong>main thread的地址为0x56562c60</strong>。</p><p>后续又进行了中断相关的设置，最后完成了初始化的函数。接着就进入下面的函数。</p><h5 id="ThreadTest"><a href="#ThreadTest" class="headerlink" title="ThreadTest"></a><code>ThreadTest</code></h5><ul><li>创建了一个线程，名为“forked thread”：</li></ul><p><img src="https://i.loli.net/2021/03/24/9QsRZCJHBzSdqUM.png" srcset="/img/loading.gif" alt="image-20210324155308502"></p><p>​       <strong>可以看到其地址为0x56562cc0</strong></p><ul><li>接着我们调用<code>Fork</code>，传入了函数<code>simpleThread</code>——循环，每次都会释放CPU的使用权。在<code>Fork</code>成员函数内部为其分配栈空间：<code>StackAllocate(func, arg);</code>。</li></ul><p><img src="https://i.loli.net/2021/03/24/aFJO9gkQxEc4r6n.png" srcset="/img/loading.gif" alt="image-20210324152753095" style="zoom:67%;" /></p><p>​        <strong>继续，我们可以得到：</strong></p><p>​        ThreadRoot ：1448449594</p><p>​        InterruptEnable：1448442119</p><p>​        func：1448442679 16进制：0x56557b37 </p><p>​        arg：1</p><p>​        ThreadFinish：1448442080</p><p>​        完成栈空间的分配以及state的设置之后，我们关闭中断、将当前线程加入readyList，然后再恢复中断。</p><ul><li><p>调用<code>Yield</code>时会发生什么？</p><div class="hljs"><pre><code class="hljs c++"><span class="hljs-keyword">void</span>Thread::Yield ()&#123;    Thread *nextThread;    IntStatus oldLevel = interrupt-&gt;SetLevel(IntOff);        ASSERT(<span class="hljs-keyword">this</span> == currentThread);        DEBUG(<span class="hljs-string">'t'</span>, <span class="hljs-string">"Yielding thread \"%s\"\n"</span>, getName());        nextThread = scheduler-&gt;FindNextToRun();    <span class="hljs-keyword">if</span> (nextThread != <span class="hljs-literal">NULL</span>) &#123;scheduler-&gt;ReadyToRun(<span class="hljs-keyword">this</span>);scheduler-&gt;Run(nextThread);    &#125;    (<span class="hljs-keyword">void</span>) interrupt-&gt;SetLevel(oldLevel);&#125;</code></pre></div><p>可以看到，我们首先关中断，然后确保执行Yield的是当前运行的线程。之后调度器寻找下一个线程，如果存在那么将当前线程加入readyList，运行下一个线程。最后恢复中断。</p><ul><li>如果不存在下一个线程，那么在将其加入ready queue之后调度器应该会再次运行它？</li></ul><p><img src="https://i.loli.net/2021/03/24/cFpaxYX54jRuwzK.png" srcset="/img/loading.gif" alt="image-20210324155350706" style="zoom:67%;" /></p><p>因为目前我们只有主线程和forked thread，所以在主线程执行<code>SimpleTthread(0)</code>之后两者交替运行。</p></li><li><p>关于<code>SWITCH</code></p><p>在主线程执行<code>Run(nextThread)</code>之后进入<code>Run</code>函数，然后执行<code>SWITCH</code>。</p></li></ul><h5 id="SWITCH的返回地址"><a href="#SWITCH的返回地址" class="headerlink" title="SWITCH的返回地址"></a><code>SWITCH</code>的返回地址</h5><p>在<code>SWITCH</code>函数处断点，然后si单指令跟踪执行。结合<code>switch_linux.s</code>的注释我们知道其会将返回地址存在eax中，使用info r查看可知：</p><p><img src="https://i.loli.net/2021/03/28/xPdasASrztK9BMv.png" srcset="/img/loading.gif" alt="image-20210328143559736" style="zoom:67%;" /></p><p>注意结合我们前面<code>ThreadRoot</code>的地址：1448449594 == 0x56559631。也就是说我们第一次主线程执行<code>SWITCH</code>之后会转而执行<code>ThreadRoot</code>函数。这和我们直接执行完成的结果一致：</p><p><img src="https://i.loli.net/2021/03/28/U4b5xh7otXkmzDC.png" srcset="/img/loading.gif" alt="image-20210328144017834"></p><p>上面是主线程执行的结果，接下来再次执行<code>SWITCH</code>的是forked thread。</p><p><img src="https://i.loli.net/2021/03/28/QuZqFi9WbYGmK7L.png" srcset="/img/loading.gif" alt="image-20210328144312431"></p><p>显然，执行之后返回了<code>Yield</code>函数。</p><blockquote><p>其实注释里面都写了。</p></blockquote><h5 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h5><ul><li>Nachos的上下文切换：当前线程执行<code>Yield</code>：关中断；调度器找到就绪队列中的队首元素并返回，设置其状态为就绪，然后调用<code>run</code>函数——其中执行<code>SWITCH</code>进行切换，主要是寄存器的切换；然后恢复中断。</li></ul>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
      <category>Nachos</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
      <tag>Nachos</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CS144-05-Lab4</title>
    <link href="/2021/03/11/CS144-05-Lab4/"/>
    <url>/2021/03/11/CS144-05-Lab4/</url>
    
    <content type="html"><![CDATA[<blockquote><p>We’d discourage you from trying to read the test source code, unless it is as a last resort</p></blockquote><p>看来还是不要测试驱动开发了。</p><hr><h5 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h5><p>总结一下之前的实验二和三，我们已经实现了receiver/sender，里面的逻辑已经基本清晰：</p><ul><li>receiver<ul><li>接收segment，根据SYN/FIN/seqno等信息决定舍弃与否，如果接收那么放入reassembler的一个实例</li><li>返回期望接收的第一个byte的seqno</li></ul></li><li>sender<ul><li>根据接收到的window_size以及ackno来发送bytes</li><li>记录了连续重传的相关信息，可以用来判断是否应该断开连接</li><li>重要的逻辑是计时器相关，什么时候开/关/之后的行为</li></ul></li></ul><p>而在实验四，我们需要完成<code>tcp_connection</code>，即包括receiver and sender。因为TCP是全双工的，连接的一方既会接收也会发送。我们首先考虑一下两者之间的联系：</p><ul><li>receiver接收到的seg里面可能包括ackno/window_size，需要反馈给sender</li><li>receiver接收到SYN/FIN/reset信息</li></ul><hr><h5 id="FAQs"><a href="#FAQs" class="headerlink" title="FAQs"></a>FAQs</h5><p>完成了几个normal functions，接下来仔细阅读FAQs。</p><ul><li><p>为什么connection也有一个<code>_segments_out</code>。但是sender不是有一个<code>_segments_out</code>吗</p><ul><li>注意在sender中我们并没有真正的发送——只是将segments放入到了<code>_segment_out</code> 当中。那么connection的实现需要我们将  sender的<code>_segments_out</code>传到connection的<code>_segments_out</code>。</li><li>这里需要结合那张图：CS144TCPSocket来理解。connection封装了sender/receiver。对于接受来说，首先是connection接受了，然后再传送给receiver。</li></ul></li><li><p>关于RST</p><ul><li>收到了怎么办</li><li>什么情况应该发送</li></ul></li><li><p>ACK</p><ul><li>发送时的设置</li><li>接收segment时判断</li></ul></li><li><p>结束connection</p><ul><li>unclean</li><li>clean</li></ul></li></ul><h5 id="clean-unclean-shutdown"><a href="#clean-unclean-shutdown" class="headerlink" title="clean/unclean shutdown"></a>clean/unclean shutdown</h5><blockquote><p> If the inbound stream ends before theTCPConnection has reached EOF on its outbound stream, this variable needs to be set to false</p></blockquote><p>不难理解，对于主动关闭，我们发送FIN、收到ACK，然后对方发送FIN，我们返回ACK，这时我们需要等待——即<strong>TIME_WAIT</strong>状态。因为我们返回的ACK可能丢失、对方可能重传，此时等待就有了意义。而对于被动关闭来说，我们收到了FIN，返回ACK，之后如果我们发送了FIN，那么在收到ACK之后便可以直接关闭了——无需等待。很显然，这里被动主动是相对的。</p><p>所以我们什么时候应该clean_shutdown？什么时候应该unclean_shutdown。对于后者应该容易回答：</p><ul><li>重传次数过多</li><li>收到RST</li><li>析构时仍然处于active状态</li></ul><p>注意，双方stream关闭之后延迟一段时间再转为close。</p><p>而对于clean_shutdown，我们必须弄清楚其条件，然后在可能满足条件的地方调用。</p><p>条件：</p><ul><li><p>receiver收到了FIN、关闭inbound stream</p><ul><li><p>如果此时outbount stream尚未关闭 那么说明是passive close，我们无需等待</p></li><li><p>如果outbound stream已经关闭、并且所有bytes均被确认，那么如果不需要等待就直接close，或者超时也close。</p></li></ul></li></ul><p>调用：</p><ul><li>其实很粗暴的方法是每个函数都加上一个，毕竟如果不满足条件也没啥关系。</li></ul><h5 id="write"><a href="#write" class="headerlink" title="write"></a>write</h5><ul><li>将data写入sender的ByteStream中</li><li>将sender的_segments_out pop掉</li></ul><h5 id="segment-received"><a href="#segment-received" class="headerlink" title="segment_received"></a>segment_received</h5><p>这里需要处理的逻辑比较多。如果处于关闭状态，那么自然不能接受。然后我们需要判断收到的seg的头部的标志位的情况：</p><ul><li>如果是正常的数据包，那么传给receiver同时把ack和window_size传给sender</li><li>如果收到了RST，那么调用<code>unclean_shutdown</code></li><li><p>如果是SYN，那么其可能并不携带ACK，所以不能直接传给sender</p><ul><li>如果收到SYN之后再次收到，虽然我们的receiver考虑到了这种逻辑，但是我们应该直接丢弃它</li></ul></li></ul><h5 id="DEBUG"><a href="#DEBUG" class="headerlink" title="DEBUG"></a>DEBUG</h5><p><strong>[01]</strong></p><p><img src="https://i.loli.net/2021/03/17/HJUZnEpyQ9qhkfO.png" srcset="/img/loading.gif" alt="image-20210317160039922" style="zoom:67%;" /></p><p>分析原因：我们在收到了之前发送的SYN的确认之后应该返回ACK，但是我们并没有这样做。通过分析实现中函数的调用过程，我们发现，初始时由于<code>_sender</code>的<code>_stream</code>为空，通过<code>_sender.ack_received</code>调用<code>fill_window</code>并不会真的发送seg。所以增加了这部分逻辑之后没有再出现这个错误。</p><p><strong>[02]</strong></p><p><img src="https://i.loli.net/2021/03/17/b3touBPvFWwhHkN.png" srcset="/img/loading.gif" alt="image-20210317203642020"></p><p>好家伙，重复了三句话，只是告诉我们状态不对、预期状态不是这样。</p><p>继续查看报错的信息，了解到：通过三次握手之后我们已经建立了连接，紧接着我们便主动关闭连接。经过9999ms，我们还没有超时——此时应该处于TIME_WAIT状态，再经过1ms我们便应该关闭了，但是事实上并没有。</p><p>所以还是去看函数的调用过程：在<code>tick</code>函数当中应该调用<code>clean_shutdown</code>。注：发现这点后修改了前面clean_shutdown相关内容。</p><p><strong>[03]</strong></p><p><img src="https://i.loli.net/2021/03/17/HzuNFoby7XYf94P.png" srcset="/img/loading.gif" alt="image-20210317214913957" style="zoom:67%;" /></p><p>上面的信息告诉我们处于<code>LISTEN</code>状态时应该直接拒绝所有的RST。</p><p>而我们的逻辑很粗暴：</p><div class="hljs"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">TCPConnection::segment_received</span><span class="hljs-params">(<span class="hljs-keyword">const</span> TCPSegment &amp;seg)</span> </span>&#123;     <span class="hljs-keyword">if</span>(!_active)<span class="hljs-keyword">return</span>;    <span class="hljs-keyword">if</span>(seg.header().rst)&#123;        unclean_shutdown();        <span class="hljs-keyword">return</span>;    &#125;</code></pre></div><p>所以需要在具体的状态中去修改。</p><h5 id="状态转换："><a href="#状态转换：" class="headerlink" title="状态转换："></a>状态转换：</h5><ul><li><p>首先sender处于<code>CLOSED</code>状态，receiver处于<code>LISTEN</code>状态。</p><ul><li><p>如果此时调用connect，那么意味着主动发起连接，调用sender的<code>fill_window</code>函数，并且调用<code>send_segs_in_sender()</code>。此时状态应该转换成<code>SYN_SENT</code>。</p><ul><li>如果一直没有收到ACK会怎样？超时重传——调用者调用<code>tick</code>函数。如果重传次数过多那么<code>unclean_shutdown</code></li></ul></li><li><p>如果此时收到了一个seg，我们期望它是SYN，并且<code>connect</code>之后状态变为<code>SYN_SENT</code>和<code>SYN_RECV</code></p><ul><li>不会携带ACK和window_size</li><li>如果不是SYN那么直接丢弃</li><li>我们需要发送自己的SYN，包含了ack——这里sen_segs_in_sender处理是没有问题的。</li></ul></li></ul></li><li><p>在sender处于<code>SYN_SENT</code>并且receiver尚处于<code>LISTEN</code>时，我们期望收到SYN</p><ul><li>如果有data，不符合SYN，丢弃；没有SYN丢弃；</li><li>如果有ACK，那么正常接收——receiver接收，sender调用<code>ack_received</code>。</li><li>如果没有ACK，有可能是因为双方同时尝试建立连接，receiver正常接收，并且sender发送一个空的seg，用于返回ACK。</li></ul></li></ul><h5 id="FINAL-BUG"><a href="#FINAL-BUG" class="headerlink" title="FINAL BUG"></a>FINAL BUG</h5><p>在本地测试了很多次，都会有两三个<code>FAILED</code>以及几个<code>TIME_OUT</code>。如果全部是超时感觉应该可以接收，毕竟距离遥远。但是失败则说明存在bug。而且这里的错误都是发生在真实的通信过程中。</p><p><img src="https://i.loli.net/2021/03/20/ZxgEwN4lkC2o3dz.png" srcset="/img/loading.gif" alt="image-20210320121930811" style="zoom:67%;" /></p><p>但是这里debug很困难——不是很理解其具体的调用过程。尝试直接根据参数去执行<code>tun.sh/txrx.sh</code>都失败了。为了确保不是网络的问题而是真实存在bug，我又将项目搬到了云服务器上，仍然存在失败的测试。不过网络环境确实好了很多：本地每次测试一遍都需要90-100s，但是云服务器上只需60s左右。</p><p>在尝试直接调试、折腾一番无果之后（镜像的GDB有问题，切换成LLDB……），决定使用最暴力的方式：从网上找到通过的文件逐渐替换，从而确定bug的范围。</p><p>因为<code>sender</code>中有一些地方不是很确定，比如提及到<code>tick</code>方式时特意标注了<code>If the window size is nonzero</code>。所以感觉这里出问题概率最大。果不其然，替换之后就全部通过了。所以接下来就是比对逻辑、确认细节的工作了。</p><p>由于实现的差别很多，所以非常麻烦——三个主要的函数<code>fill_window/ack_received/tick</code>都是息息相关的。所以主要是理解别人代码、根据自己的逻辑去修改，然后编译、测试，大概花了两个小时，终于大概确定了一点：一旦将别人的更新发送端窗口大小以及<code>win_size==0</code>时的代码按照我自己的逻辑进行修改，那么就会错误。</p><p>所以说明我这里的处理是有问题的。看了指导书，对上面那句话还是不太理解。不过确实找到了一个bug：原本直接更新窗口的方式是<code>_sender_window_size = abs_ackno + window_size - _next_seqno</code>，而其中<code>_sender_window_size.type ==  uint16_t</code>类型。这是非负的，但是上面相减之后是可能为负的，所以增加了一个判断。</p><p>另外对比发现<code>tick</code>的逻辑和别人的逻辑不一样，感觉很奇怪，所以尝试性地进行了一些修改。这次测试结果很奇怪：没有超时的，但是sender的测试有一个错误：<code>t_send_extra</code>。</p><p><img src="https://i.loli.net/2021/03/23/HDfTXBpSuIqkyd3.png" srcset="/img/loading.gif" alt="image-20210323212934149" style="zoom: 67%;" /></p><p>在循环里面出错了。总结一下：这里是在收到<code>win_size == 0</code>的seg之后，每次经过rto<strong>都应该</strong>发送一个seg，但是我没有发送。此时，结合前面指导书中的<strong>If tick is called and the retransmission timer has expired:……If the window size is nonzero……</strong>以及我的实现瞬间明白了问题所在。</p><p>总结一下：</p><p>因为我们会接收到<code>window_size</code>，并且需要更新发送端的窗口大小，所以我直接设置了两个成员变量：<code>_receiver_window_size /_sender_window_size</code>。前者用于保存每次的<code>window_size</code>，后者用于发送端窗口的实时更新。因为SYN尚未发送、连接尚未建立时，我们假定窗口大小为1，所以这两个变量初始化时都是1。之后在判断<code>window_size == 0</code>后，会直接赋值一个临时变量为1去代替<code>window_size</code>进行赋值。</p><p>但是，为什么之前lab3的时候<code>t_send_extra</code>过了？因为巧合的是，之前的实现里面，会先用<code>window_size</code>更新<code>_receiver_window_size</code>。</p><p>原本实现的根本错误在于<code>_consecutive_retransmission++;</code>应该在<code>window_size != 0</code>内部，但是我写在了外面，这样一旦<code>window_size == 0</code>会导致重传次数不断增加，最终超出上限、连接关闭。</p><p>修改完成之后，终于全部过了。</p><p><img src="https://i.loli.net/2021/03/23/pjdHVo2BNwK94JZ.png" srcset="/img/loading.gif" alt="image-20210323220038752"></p>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
      <category>CS144</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
      <tag>CS144</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>High Performance Mysql [Notes]</title>
    <link href="/2021/03/07/High%20Performance%20Mysql%20%5BNotes%5D/"/>
    <url>/2021/03/07/High%20Performance%20Mysql%20%5BNotes%5D/</url>
    
    <content type="html"><![CDATA[<h3 id="ch1-Mysql-Architecture-and-History"><a href="#ch1-Mysql-Architecture-and-History" class="headerlink" title="ch1 Mysql Architecture and History"></a>ch1 Mysql Architecture and History</h3><h4 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h4><h5 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h5><ul><li><p>ACID属性</p></li><li><p>隔离性的四个级别</p><ul><li><p>关于nonrepeatedable read</p><blockquote><p>…a transaction T2 could change the value of an object A that has been read by a transaction T1, while T1 is still in progress. If T1 tries to read the value of A again, it will get a different result, even though it has not modified A in the meantime… —<em>Database Management Systems</em></p></blockquote></li></ul></li></ul><h5 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h5>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>Mysql</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
      <tag>Mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CS144-04-Lab3</title>
    <link href="/2021/03/07/CS144-04-Lab3/"/>
    <url>/2021/03/07/CS144-04-Lab3/</url>
    
    <content type="html"><![CDATA[<h5 id="为什么需要随机的ISN"><a href="#为什么需要随机的ISN" class="headerlink" title="为什么需要随机的ISN"></a>为什么需要随机的ISN</h5><p><a href="https://www.quora.com/Why-in-a-TCP-sequence-is-a-number-taken-as-a-random-number-and-what-is-the-actual-number-at-the-start" target="_blank" rel="noopener">https://www.quora.com/Why-in-a-TCP-sequence-is-a-number-taken-as-a-random-number-and-what-is-the-actual-number-at-the-start</a></p><p><a href="https://www.techrepublic.com/article/tcp-hijacking/" target="_blank" rel="noopener">https://www.techrepublic.com/article/tcp-hijacking/</a></p><p><a href="https://pdos.csail.mit.edu/~rtm/papers/117.pdf" target="_blank" rel="noopener">https://pdos.csail.mit.edu/~rtm/papers/117.pdf</a></p><p>主要是与一些攻击方式有关系。具体的原理尚未明白。</p><h4 id="Implementing-the-TCP-Sender"><a href="#Implementing-the-TCP-Sender" class="headerlink" title="Implementing the TCP Sender"></a>Implementing the TCP Sender</h4><h5 id="fill-window"><a href="#fill-window" class="headerlink" title="fill_window"></a><code>fill_window</code></h5><p>如同函数名一样，填充窗口。所以问题的关键在于：</p><ul><li>什么情况不用填充</li><li>什么情况下应该填充<ul><li>窗口大小的设置问题</li></ul></li></ul><p>注意指导书的提示：</p><blockquote><p>TheTCPSender should fill the window again if new space has opened up.</p></blockquote><p>所以实际上在收到ack和win_size之后我们调用<code>fill_window</code>去执行发送。</p><p>首先不用填充的情况：</p><ul><li>没有数据需要发送<ul><li>注意判断<code>eof</code>，因为可能需要发送FIN</li></ul></li><li>发送窗口为0</li><li>已经全部完成发送了</li></ul><p>如何更新窗口设置？这里刚开始想法是错误的，通过debug解决了，见后续<code>sender的窗口如何调整</code>。</p><p>解决上述问题之后逻辑就比较简单了：</p><ul><li><p>判断SYN/FIN是否应该发送以及相应处理。</p></li><li><p>如果还有数据待发送、窗口尚未填满</p><ul><li>选择尽量长的数据单位：剩余窗口、数据、<code>MAX_PAYLOAD_SIZE</code>三者中的最小者。因为实现<code>ByteStream</code>的时候就已经考虑到了<code>read</code>数据多于现存数据的情况，所以这里比较两者即可。</li><li>更新变量，<code>_bytes_in_flight _next_seqno _sender_window_size</code>等。</li><li>注意，初始的窗口容量的设置我放在了<code>ack_received</code>函数当中。</li></ul></li><li>如果我们发送了数据并且计时器尚未启动，那么重启计时器。</li></ul><h5 id="ack-received"><a href="#ack-received" class="headerlink" title="ack_received"></a><code>ack_received</code></h5><p>逻辑并不复杂，主要有以下几点：</p><ul><li>将ack从seqno转换成abs seqno，并且判断是否有效。如果有效那么更新<code>_previous_ackno</code>：用于转换。<ul><li>有效意味着处于上一次ack和_next_seqno之间</li></ul></li><li>将被ack的segments pop掉<ul><li>如果有数据被确认了，那么设置RTO、累计时间、连续重传次数</li></ul></li><li><strong>更新发送端的窗口</strong></li></ul><h5 id="debug记录"><a href="#debug记录" class="headerlink" title="debug记录"></a>debug记录</h5><p><code>send_tmtx</code>失败。提示：</p><blockquote><p>Test Failure on expectation:<br>        Expectation: segment sent with (A=0,R=0,S=1,F=0,seqno=496550203,payload_size=0,…)</p><p>Failure message:<br>        The Sender should have produced a segment that existed, but it did not</p></blockquote><p>测试源码如下：</p><p><img src="https://i.loli.net/2021/03/10/hWICFAmzGwptkq1.png" srcset="/img/loading.gif" alt="image-20210310152456694" style="zoom:67%;" /></p><p>即其调用了两次<code>tick</code>，第一次刚好比<code>rt_timeout</code>小1，第二次又增加了1，因此第二次调用之后应该重传。但是本来的实现逻辑中，重传必须：<code>_ms_accumulated &gt; _current_retransmission</code>。改成大于等于即可。</p><h5 id="sender的窗口如何调整？"><a href="#sender的窗口如何调整？" class="headerlink" title="sender的窗口如何调整？"></a><strong>sender的窗口如何调整？</strong></h5><p><code>send_extra</code>失败。在test<code>Don&#39;t add FIN if this would make the segment exceed the receiver&#39;s window</code>处发生错误。经过检查确认了sender窗口的调整是有问题的。本来我们直接使用每次接收到的<code>window_size</code>去更新<code>_sender_window_size</code>。显然这是不正确的。</p><p>我们必须明确<code>_sender_window_size</code>的含义是：从<code>_next_seqno</code>开始，在abs seqno表示的stream中，接收端会接收的bytes的abs seqno的范围。那么在receiver处，其希望接收的范围是[ackno, ackno + window_size)。对比一下，显然是[_next_seqno, ackno + window_size)。所以<code>_sender_window_size = ackno + window_size - _next_seqno</code>。（ackno如果比 _next_seqno大那么直接舍弃）</p><p><strong>为什么receiver 返回window_size = 0时应该将window_size视为1？</strong></p><p><img src="https://i.loli.net/2021/03/11/erLhKXyD6cFIosA.png" srcset="/img/loading.gif" alt="image-20210311132440348"></p><p>考虑这样一种情况：unassembled_bytes = 0，ByteStream.size() == _capacity。那么此时返回的窗口大小为0。但是一旦ByteStream被读走了字节，那么窗口大小会调整。如果sender发送了一个字节，那么receiver会返回新的window_size。</p>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
      <category>CS144</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
      <tag>CS144</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CS144-03-Lab2</title>
    <link href="/2021/03/03/CS144-03-Lab2/"/>
    <url>/2021/03/03/CS144-03-Lab2/</url>
    
    <content type="html"><![CDATA[<hr><p>读完《TCP/IP详解 卷一：协议》CH12之后对于指导书中的图有了大致的理解，包括TCP头部各个字段的含义。</p><p>TCP接收方需要告诉发送方两方面的信息：</p><ul><li><p>接收方期待的下一个字节在stream中的序号。回想Lab1，我们有first_unread/first_unassembled/first_unacceptable。其中<code>[first_unread, first_unassembled)</code>即为已经组装好的segments，接收方希望下一个字节是first_unassembled对应的字节，接收方已经接收了此前的字节。这里的first_unassembled即为<strong>ackno——acknowledgment number</strong>。</p></li><li><p><code>[first_unassembled, first_unacceptable)</code>即为<strong>滑动窗口</strong>——此时接收方希望接收的字节的序列号的范围。</p></li></ul><h4 id="Translating-between-64-bit-indexes-and-32-bit-seqnos"><a href="#Translating-between-64-bit-indexes-and-32-bit-seqnos" class="headerlink" title="Translating between 64-bit indexes and 32-bit seqnos"></a>Translating between 64-bit indexes and 32-bit seqnos</h4><p>我们有三种序列：</p><ul><li>在TCP传输中标志每个字节的序列号，从ISN开始，32位</li><li>absolute seqno 将上者变为从0开始</li><li>stream中每个字节的序列号，即真正传输的数据的序列号</li></ul><p><img src="https://i.loli.net/2021/03/04/d3xwi5Pqo87GaAE.png" srcset="/img/loading.gif" alt="image-20210304175138487" style="zoom: 67%;" /></p><p>我们首先需要完成<code>WrappingInt32</code>类——对uint32_t进行封装，从而使其与uint64_t转换更加方便。</p><h5 id="wrap"><a href="#wrap" class="headerlink" title="wrap"></a><code>wrap</code></h5><p>很显然，我们取出<code>uint64_t n</code>的低32位，然后与<code>ISN</code>相加即可。</p><div class="hljs"><pre><code class="hljs c++"><span class="hljs-function">WrappingInt32 <span class="hljs-title">wrap</span><span class="hljs-params">(<span class="hljs-keyword">uint64_t</span> n, WrappingInt32 isn)</span> </span>&#123;   <span class="hljs-keyword">return</span> WrappingInt32(<span class="hljs-keyword">uint32_t</span>(n &amp; <span class="hljs-number">0x00000000FFFFFFFF</span>) + isn.raw_value());&#125;</code></pre></div><h5 id="unwrap"><a href="#unwrap" class="headerlink" title="unwrap"></a><code>unwrap</code></h5><p>从seqence number 向absolute sequence number转换：</p><ul><li><p>很显然这种转换不是唯一的——seqno每次增加$2^{32}$值都不变，但是absolute seqno变化。为了确定唯一的结果，我们需要<code>checkpoint</code>，即将可能的结果中距离<code>checkpoint</code>最近的作为最终结果。</p></li><li><p><del>我们知道这里<code>checkpoint</code>实际上是last reassembled bytes，那么新来的segment对应的seqno转换成absolute seqno之后应当大于<code>checkpoint</code>。</del>我们知道这里<code>checkpoint</code>实际上是last reassembled bytes，那么新来的segment对应的seqno转换成absolute seqno之后应当大于<code>checkpoint</code>。所以如果我们知道<code>checkpoint</code>最少增加多少就变成答案即可。答案记作<code>ans</code>，那么如果我们将<code>checkpoint</code>转换成32位的seqno，记作<code>cp_seqno</code>，那么实际上从<code>cp_seqno</code>走到<code>n</code>与<code>checkpoint</code>走到<code>ans</code>距离应该是一样的。</p><p><del>如何得到这个距离？如果<code>n - cp_seqno &gt;= 0</code>，那么是正常的；如果<code>n - cp_seqno &lt; 0</code>，那么说明其实是从<code>cp_seqno</code>继续增长、溢出$2^{32}-1$从0开始，所以我们需要将<code>n</code>加上$2^{32}$。</del></p><p>写完发现报错了。马上想到，新来的segment的seqno在整个stream中未必是在<code>checkpoint</code>之后，也有可能在之前——会导致被抛弃，这是合理的。所以有可能比<code>checkpoint</code>小。</p><div class="hljs"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">uint64_t</span> <span class="hljs-title">unwrap</span><span class="hljs-params">(WrappingInt32 n, WrappingInt32 isn, <span class="hljs-keyword">uint64_t</span> checkpoint)</span> </span>&#123;  <span class="hljs-keyword">int32_t</span> tmp = n - wrap(checkpoint, isn);  <span class="hljs-keyword">int64_t</span> ans = checkpoint + tmp;  <span class="hljs-keyword">return</span> ans &gt;= <span class="hljs-number">0</span> ? ans : ans + (<span class="hljs-number">1u</span>l &lt;&lt; <span class="hljs-number">32</span>);&#125;</code></pre></div></li></ul><h4 id="Implementing-the-TCP-receiver"><a href="#Implementing-the-TCP-receiver" class="headerlink" title="Implementing the TCP receiver"></a>Implementing the TCP receiver</h4><h5 id="关于TCP"><a href="#关于TCP" class="headerlink" title="关于TCP"></a>关于TCP</h5><p>首先有一个问题，为什么SYN 也需要一个序列号？序列号存在的意义有两方面：</p><ul><li>为了重组segment。只有标示了segment的data在整个stream中的index，我们才能将乱序的data再重组成完成的stream，才能实现一种可靠的流模式</li><li>为了可靠性——连接中任意一方发送的数据能够被对方通过ack确认，否则需要重传。那么显然发送SYN的一方也需要知道自己的SYN是否被接收了，怎么办？给SYN一个sequence number，如果有ack = sequence number + 1，那么便OK了。自然这里的sequence number就是ISN。</li></ul><p>TCP连接建立的根本目的是交换双方的ISN，这是可靠性的基础。</p><h5 id="Enable-C-17-support-in-VSCode-C-C-extension"><a href="#Enable-C-17-support-in-VSCode-C-C-extension" class="headerlink" title="Enable C++17 support in VSCode C/C++ extension"></a>Enable C++17 support in VSCode C/C++ extension</h5><p>起因是<code>tcp_receiver.hh/cc</code>中，关于<code>std::optional&lt;WrappingInt32&gt; ackno() const</code>报错：</p><blockquote><p>不允许使用限定名</p></blockquote><p>有点奇怪，之前没遇到过。查了一下<code>optional</code>发现这是C++17才有的，而且代码本身应该是没问题的，那应该是vscode c++扩展没有支持C++17。找到设置里面，搜索<code>cppstandard</code>，然后改成<code>c++ 17</code>即可。</p><h5 id="整体结构"><a href="#整体结构" class="headerlink" title="整体结构"></a>整体结构</h5><p>我们需要完成三个函数，主要的是<code>segment_received</code>。回忆我们的<code>stream_reassembler</code>，其中<code>push_substring</code>需要<code>string data/ size_t index/ bool eof</code>三个参数。而<code>segment</code>包括：<code>TCP header / data</code>。因此在接收到<code>segment</code>之后我们需要得到这些信息、然后调用<code>push_substring</code>函数。</p><p>那么现在逐渐变得清晰：</p><ul><li><p>得到<code>segment</code>的<code>SYN</code>字段，从而判断是否需要设置</p><ul><li>所以我们需要知道sponge 库里面TCP segment 提供的方法</li><li>另外，考虑到后续还需要用到<code>ISN</code>，所以有必要设置一个私有成员存储<code>ISN</code></li></ul></li><li><p>得到<code>FIN</code>字段，从而去结束<code>stream_reassembler</code></p></li><li><p>注意<code>push_substring</code>中<code>index</code>为<code>size_t</code>，我们需要将<code>int32_t</code>的sequence number转化成<code>int64_t</code>。这就需要调用<code>WrappingInt32</code>，并且我们需要知道<code>checkpoint</code>。提示：</p><blockquote><p>In your TCP implementation, you’ll use the index of the last reassembled byte as the checkpoint.</p></blockquote><p>这样也就是窗口左边的index——<code>_first_unreassembled</code>左边。</p></li><li><p>如何得到<code>data</code>？<code>tcp_segment</code>提供了接口：</p><div class="hljs"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">const</span> Buffer &amp;<span class="hljs-title">payload</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123; <span class="hljs-keyword">return</span> _payload; &#125;<span class="hljs-function">Buffer &amp;<span class="hljs-title">payload</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> _payload; &#125;</code></pre></div></li></ul><p>另外关于<code>optional</code>的使用，参考：</p><blockquote><p><a href="https://en.cppreference.com/w/cpp/utility/optional" target="_blank" rel="noopener">https://en.cppreference.com/w/cpp/utility/optional</a></p></blockquote><h5 id="segment-received的思路与细节"><a href="#segment-received的思路与细节" class="headerlink" title="segment_received的思路与细节"></a><code>segment_received</code>的思路与细节</h5><p>原本的思路过于简陋，存在很多bug。后续通过test修补了很多。</p><p><strong>debug：</strong></p><p>在<code>FIN = true</code>时，我们以为直接<code>push_substring</code>，由于<code>EOF = true</code>会使得重组器的<code>ByteTream _output</code>结束输入。但是事实上并没有——<code>_output</code>的输入结束必须是不存在unreassembled_segs。</p><p>回顾实验一中<code>push_substring</code>的定义：</p><blockquote><p><code>eof</code>: the last byte of this substring will be the last byte in the entire stream</p></blockquote><p>也就是说，<code>eof = true</code>仅仅说明当前的substring是最后的字符串。这是很符合实际的，由于网络延迟的存在，后续到来的substring可能是在该substring之前，我们当然应该将其reassembled而不是拒绝输入。</p><p>在<code>reassembled_bytes</code>中，我们的逻辑是这样的：</p><div class="hljs"><pre><code class="hljs c++"><span class="hljs-keyword">if</span>(eof)_eof = <span class="hljs-literal">true</span>;<span class="hljs-keyword">if</span>(_eof &amp;&amp; empty())_output.end_input();</code></pre></div><p>现在，我们在<code>FIN</code>之后到来的segment<strong>应该能够</strong>让<code>_output</code>结束输入。上面的逻辑是可以处理的。</p><p>排查发现<code>segment_received</code>里面多了第一行：</p><div class="hljs"><pre><code class="hljs c++"><span class="hljs-keyword">if</span>(_has_fin)<span class="hljs-keyword">return</span>;</code></pre></div><p>显然，并不能这样处理。删除之后即可。</p><h5 id="ackno-实现"><a href="#ackno-实现" class="headerlink" title="ackno()实现"></a><code>ackno()</code>实现</h5><blockquote><p>Returns anoptional<WrappingInt32>containing the sequence number of the first byte that the receiver doesn’t already know.  This is the windows’s left edge:  the first byte the receiveris interested in receiving.  If the ISN hasn’t been set yet, return an empty optional.</p></blockquote><p>初始版本：</p><div class="hljs"><pre><code class="hljs c++"><span class="hljs-function">optional&lt;WrappingInt32&gt; <span class="hljs-title">TCPReceiver::ackno</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;    <span class="hljs-keyword">if</span>(_has_syn)&#123;        <span class="hljs-keyword">size_t</span> tmp = <span class="hljs-number">1</span>;        <span class="hljs-comment">//firstly get the absolute sequence number </span>            <span class="hljs-comment">//normally just add 1 but if fin add 2 </span>        <span class="hljs-comment">//then using wrap -- translating the asn to sq</span>        <span class="hljs-keyword">if</span>(_has_fin &amp;&amp; _reassembler.unassembled_bytes() == <span class="hljs-number">0</span>)tmp = <span class="hljs-number">2</span>;        <span class="hljs-keyword">return</span> wrap(_reassembler.stream_out().bytes_written() + tmp, _ISN_peer);    &#125;    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-built_in">std</span>::nullopt;&#125;</code></pre></div><p>注释：</p><p>因为我们需要返回的是absolute seqno，因此是在stream index基础上增加一。而且需要考虑，如果<code>FIN</code>已经到达并且没有unassembled bytes，那么我们需要对<code>FIN</code>进行确认。当然，如果还存在unassembled bytes，那么ackno并不需要特别处理。</p><p><strong>报错：</strong></p><blockquote><p>Failure message:<br>        The TCPReceiver reported ackno <code>6</code>, but it was expected to be <code>7</code></p><p>List of steps that executed successfully:<br>        Initialized with (capacity=4000)<br>        Action:      segment arrives Header(flags=SF,seqno=5,ack=0,win=0)<br>        Expectation: in state <code>input to stream has ended</code></p></blockquote><p>test case如下：</p><p><img src="https://i.loli.net/2021/03/09/Cy3UPoYOX1i5eSu.png" srcset="/img/loading.gif" alt="image-20210309105109752"></p><p>结合<code>segment_received</code>代码可以确定，由于没有设置<code>_has_fin = true</code>导致<code>ackno</code>错误。</p><p><strong>报错：</strong></p><blockquote><p>Failure message:<br>        The TCPReceiver reported ackno <code>3836842352</code>, but it was expected to be <code>3836842365</code></p><p>List of steps that executed successfully:<br>        Initialized with (capacity=4000)<br>        Expectation: in state <code>waiting for SYN: ackno is empty</code><br>        Action:      segment arrives Header(flags=S,seqno=3836842351,ack=0,win=0) with data “Hello, CS144!”<br>        Expectation: in state <code>SYN received (ackno exists), and input to stream hasn&#39;t ended</code></p></blockquote><p>返回的<code>ackno</code>错误。可能的原因包括：</p><ul><li><code>bytes_written</code>错误，导致返回了错误的结果</li><li><code>segment_received</code>错误，即插入时设置的index错误，或者其他逻辑错误，导致<code>bytes_written</code>错误</li><li><code>wrap</code>用法错误</li></ul><p>通过在<code>ackno</code>函数中打印<code>bytes_written</code>得知其错误，输出值一直是0。</p><p>通过对比special case：SYN with data 和<code>segment_receive</code>，可以确认逻辑错误：此时得到的<code>abs_seqno</code>错误。增加对包含数据时SYN的特判即可。</p>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
      <category>CS144</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
      <tag>CS144</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CS144-02-Lab1</title>
    <link href="/2021/02/06/CS144-02-Lab1/"/>
    <url>/2021/02/06/CS144-02-Lab1/</url>
    
    <content type="html"><![CDATA[<hr><p>这次实验我们需要完成一个子串重组的类。因为我们的数据包被TCP Sender分割成很多的segments。我们需要在receiver处将其重组成完整的byte-stream。</p><p>首先，我们需要考虑大体上数据结构以及算法：</p><ul><li>substring到来随机，我们需要将其插入合适的位置。因此需要插入性能较好的结构。考虑到可能与前后的子串重合，因此需要方便地得到前后子串。</li><li>考虑到插入，那么树形结构比较合适。我们知道每个substring的index，因此可以据此进行排序。</li><li>考虑使用set。我们需要构建一个structure并且自定义如何比较以及排序方式。set支持双向迭代器，因此插入之后可以得到前后的元素进行操作。</li></ul><p>其次，如何去重？这里我们不需要考虑什么字符串匹配算法，因为我们知道index信息，根据前面元素的index以及长度结合当前元素的index就可以知道是否重合及其相应的处理方式。</p><p>另外，对于capacity的理解：</p><ul><li><p>我们有一个byte-stream——<code>_output</code>用于存储接收到并且组装好的segments。另外还有部分容量用于存储不与<code>_output</code>连续的子串。一旦连续自然也需要写入<code>_output</code></p></li><li><p>指导书上面的示意图：</p><p><img src="https://i.loli.net/2021/03/02/YLDScgfaBIdWiAw.png" srcset="/img/loading.gif" alt="image-20210302194203433"></p></li></ul><p>我们考虑一下index各种可能的情况：</p><ul><li>处于first unacceptable之后 那么直接丢弃</li><li>处于first unread之前 有可能其延申一直到first unassembled之后 仍然需要处理</li><li>处于first unread和first unassembled之间 同上 需要处理</li><li>处于first unassembled和first unacceptable之间 自然需要处理</li></ul><p>其中2/3两种情况本质是一样的，因为绿色部分已经完成，所以我们只需要截取first unassembled及其之后的部分即可。 继续这样的思路，我们应该先进行预处理、得到红色部分需要插入的substring再进行插入。当然，超出first unacceptable之后的就直接截断。</p><p>如何实现？</p><ul><li>我们必须记录<code>first_unread--_first_unread</code>。根据<code>_output.buffer_size()</code>便可以得到<code>first_unassembled</code>。</li></ul><p>现在，我们已经得到的需要插入的结构体了。</p><p>我们首先需要找到插入的位置——<code>lower_bound</code>返回第一个大于等于index的元素，之后不断尝试合并即可——这里我们考虑构建一个函数用于合并两个结构体。而且并不仅仅考虑后面的元素，<code>lower_bound</code>返回结果之前的可能也会产生重叠，需要判断。</p><p>更具体来说，如何设计这个函数？有很多种可能的方式：</p><ul><li>传入<code>set&lt;node&gt;::iterator</code>，根据迭代器得到元素进而进行比较，如果重叠那么修改待插入的结构体，删除<code>iterator</code>指向的结构体；<ul><li>我们是在函数内部删除还是在调用处删除？</li><li><a href="https://stackoverflow.com/questions/9726375/stdset-iterator-automatically-const" target="_blank" rel="noopener">https://stackoverflow.com/questions/9726375/stdset-iterator-automatically-const</a></li></ul></li><li>我们首先插入，然后直接修改<code>set&lt;node&gt;</code>。这样有一个弊端就是，我们并不能直接插入，因为可能存在相同的<code>index</code>——我们需要额外处理，但是如果只是处理这个相同<code>index</code>的元素那么在插入之后仍然需要与后续元素进行比较、处理，代码比较冗余；</li><li>注意如果能够合并，那么显然会影响<code>_unassembled_bytes</code>，如何实现？直接在内部修改还是传回返回值然后修改？</li></ul><p>现在我们已经完成了讲个基本的数据结构——<code>byte_stream</code>和<code>stream_assembler</code>。</p>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
      <category>CS144</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
      <tag>CS144</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CS144-01-Lab0</title>
    <link href="/2021/01/30/CS144-01-Lab0/"/>
    <url>/2021/01/30/CS144-01-Lab0/</url>
    
    <content type="html"><![CDATA[<h4 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h4><h5 id="VSCode-Remote-Development"><a href="#VSCode-Remote-Development" class="headerlink" title="VSCode Remote Development"></a>VSCode Remote Development</h5><ul><li><p>随便搜了一些教程，按步骤操作即可。</p><p><img src="C:\Users\28425\AppData\Roaming\Typora\typora-user-images\image-20210131143446968.png" srcset="/img/loading.gif" alt="image-20210131143446968" style="zoom: 50%;" /></p></li><li><p>中间自动推荐了C++相关插件，安装即可。</p></li></ul><h5 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h5><ul><li><p>安装</p><div class="hljs"><pre><code class="hljs html">git config --global user.name "xxx" // user.email "xxx"</code></pre></div></li><li><p>关联远程仓库并推送</p><div class="hljs"><pre><code class="hljs xml">git remote -v可以看到已经存在的仓库 因为是从CS144的官方clone下来的git remote add qscs144 URL git add .git commit -mgit push qscs144 master</code></pre></div></li><li><p>配置SSH相关。注意ubuntu启动ssh agent: <code>exec ssh-agent bash</code></p></li></ul><h4 id="正式实验"><a href="#正式实验" class="headerlink" title="正式实验"></a>正式实验</h4><h5 id="webget-cc"><a href="#webget-cc" class="headerlink" title="webget.cc"></a>webget.cc</h5><p>我们的目标是实现<code>void get_URL(const string &amp;host, const string &amp;path)</code>函数。</p><p>具体来说：</p><ul><li><p>理解基本的socket编程</p></li><li><p>阅读sponge库 知道对应的接口</p></li></ul><div class="hljs"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">get_URL</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span> &amp;host, <span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span> &amp;path)</span> </span>&#123;    TCPSocket soct;    soct.<span class="hljs-built_in">connect</span>(Address(host, <span class="hljs-string">"http"</span>));    <span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span> httpDatagram = <span class="hljs-string">"GET "</span> + path + <span class="hljs-string">" HTTP/1.1\r\n"</span> +                                 <span class="hljs-string">"Host: "</span> + host + <span class="hljs-string">"\r\n\r\n"</span>;    soct.<span class="hljs-built_in">write</span>(httpDatagram);    soct.<span class="hljs-built_in">shutdown</span>(SHUT_WR);    <span class="hljs-keyword">while</span>(!soct.eof())        <span class="hljs-built_in">cout</span>&lt;&lt;soct.<span class="hljs-built_in">read</span>();    soct.<span class="hljs-built_in">close</span>();    <span class="hljs-keyword">return</span>;&#125;</code></pre></div><p><img src="https://i.loli.net/2021/02/01/jRvxaIM3UEVYmbc.png" srcset="/img/loading.gif" alt="image-20210201182035652" style="zoom:67%;" /></p><p><img src="https://i.loli.net/2021/02/01/ihq8ZB2t4op5dcu.png" srcset="/img/loading.gif" alt="image-20210201182059748" style="zoom:67%;" /></p><h5 id="an-in-memory-reliable-byte-stream"><a href="#an-in-memory-reliable-byte-stream" class="headerlink" title="an in-memory reliable byte stream"></a>an in-memory reliable byte stream</h5><p>在上面的实验中我们可以看到socket提供给用户的感觉就是能够将字节可靠地通过网络在主机之间进行交互。这里我们需要实现一个单线程的、位于内存的byte stream。</p><p>要求：</p><ul><li>有序 FIFO</li><li>初始化时固定容量</li><li>控制输入操作</li></ul><p>如何实现？思路：</p><ul><li>最初根据FIFO第一反应是直接使用<code>queue</code>。但是我们<code>read/write</code>的对象都是<code>string</code>，而且有时需要根据字节长度去读取，因此使用<code>queue</code>比较麻烦——需要不断地去遍历得到指定长度的<code>string</code></li><li>直接使用一个<code>string</code>对象？所有的操作直接在这个对象上进行。感觉比较方便。</li></ul><blockquote><p><code>string</code>与字符、字节之间的关系</p></blockquote><p>具体代码比较简单。</p><h4 id="关于构建"><a href="#关于构建" class="headerlink" title="关于构建"></a>关于构建</h4><ul><li><p>注意，这里我们必须列表初始化成员：</p><blockquote><p>‘ByteStream::_BStream’ should be initialized in the member initialization list [-Werror=effc++]</p></blockquote></li></ul><hr><p>不同版本g++/gcc的切换：</p><p><a href="https://www.jianshu.com/p/f66eed3a3a25" target="_blank" rel="noopener">https://www.jianshu.com/p/f66eed3a3a25</a></p><p><a href="https://zhuanlan.zhihu.com/p/20797436" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/20797436</a></p><p><a href="https://blog.csdn.net/L_Y_Fei/article/details/103405260" target="_blank" rel="noopener">https://blog.csdn.net/L_Y_Fei/article/details/103405260</a></p>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
      <category>CS144</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
      <tag>CS144</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MIT6.828-02-Lab1</title>
    <link href="/2021/01/27/MIT6-828-02-Lab1/"/>
    <url>/2021/01/27/MIT6-828-02-Lab1/</url>
    
    <content type="html"><![CDATA[<h4 id="Part1-PC-Bootstrap"><a href="#Part1-PC-Bootstrap" class="headerlink" title="Part1: PC Bootstrap"></a>Part1: PC Bootstrap</h4><h5 id="熟悉x86汇编"><a href="#熟悉x86汇编" class="headerlink" title="熟悉x86汇编"></a>熟悉x86汇编</h5><ul><li><p><a href="https://www.ibm.com/developerworks/cn/linux/l-assembly/" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/linux/l-assembly/</a> 介绍了Linux环境下基本的AT&amp;T风格的汇编</p><p>在编写<code>hello.s</code>之后<code>as -o hello.o hello.s</code>提示：</p><blockquote><p>hello.s: Assembler messages:<br>hello.s: Warning: end of file not at end of a line; newline inserted</p></blockquote><p>在<code>hello.s</code>末尾添加新行即可。<strong>WHY</strong></p><p>另外介绍了inline assembly的基本用法，有点好玩，GCC的支持使得我们可以直接在C语言中直接写汇编。</p></li><li><p><a href="https://pdos.csail.mit.edu/6.828/2018/readings/i386/toc.htm" target="_blank" rel="noopener">80386 Programmer’s Reference Manual</a> 包括从基本的计算机组成到x86 assembly，1.2介绍了历史发展，可以与操作系统的知识结合在一起：从段式分配到页式分配。另外appendix里面包括了80x86 instructions，比较方便。</p></li></ul><h5 id="启动过程"><a href="#启动过程" class="headerlink" title="启动过程"></a>启动过程</h5><ul><li><p><strong>Exercise 2</strong>： Use GDB’s si (Step Instruction) command to trace into the ROM BIOS for a few more instructions, and try to guess what it might be doing.</p><p>首先我们想知道电脑启动的整体过程。<a href="https://medium.com/an-idea/the-not-so-magic-of-how-your-computer-boots-up-2f5e8289451d" target="_blank" rel="noopener">这篇文章介绍了大致过程</a> </p><p>其次使用<code>si</code>去看具体执行了那些命令。</p></li></ul><h4 id="Part2-The-Boot-Loader"><a href="#Part2-The-Boot-Loader" class="headerlink" title="Part2: The Boot Loader"></a>Part2: The Boot Loader</h4><ul><li><p><img src="https://i.loli.net/2021/01/30/vEmgqHpltSQM5CA.png" srcset="/img/loading.gif" alt="image-20210130160415527"></p><p>上图中，左边是使用GDB单步执行的过程，右边是boot.S。</p></li></ul><h5 id="理解boot-loader-source-code"><a href="#理解boot-loader-source-code" class="headerlink" title="理解boot loader source code"></a>理解boot loader source code</h5>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
      <category>MIT6.828</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
      <tag>MIT6.828</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MIT6.828-01-环境配置与工具使用</title>
    <link href="/2021/01/27/MIT6.828-01-%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    <url>/2021/01/27/MIT6.828-01-%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h4 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h4><blockquote><p>Ubuntu 18.04</p></blockquote><p>这门课实验的最终目标是实现一个微内核操作系统JOS，它是在xv6的基础上改写的。xv6是运行在x86架构上的用于教学的类UNIX操作系统。因此，一方面我们需要利用QEMU来运行xv6，另一方面需要编译工具链来对内核进行编译。官方给的指导：<a href="https://pdos.csail.mit.edu/6.828/2018/tools.html" target="_blank" rel="noopener">https://pdos.csail.mit.edu/6.828/2018/tools.html</a></p><p>事实上这中间可能会遇到一些问题，例如：</p><p><code>make &amp;&amp; make install</code>之后报错：</p><div class="hljs"><pre><code class="hljs html">qga/commands-posix.c: In function ‘dev_major_minor’:qga/commands-posix.c:633:13: error: In the GNU C Library, "major" is defined by <span class="hljs-tag">&lt;<span class="hljs-name">sys</span>/<span class="hljs-attr">sysmacros.h</span>&gt;</span>. For historical compatibility, it is currently defined by <span class="hljs-tag">&lt;<span class="hljs-name">sys</span>/<span class="hljs-attr">types.h</span>&gt;</span> as well, but we plan to remove this soon. To use "major", include <span class="hljs-tag">&lt;<span class="hljs-name">sys</span>/<span class="hljs-attr">sysmacros.h</span>&gt;</span> directly. If you did not intend to use a system-defined macro "major", you should undefine it after including <span class="hljs-tag">&lt;<span class="hljs-name">sys</span>/<span class="hljs-attr">types.h</span>&gt;</span>. [-Werror]         *devmajor = major(st.st_rdev);             ^~~~~~~~~~~~~~~~~~~~~~~~~~  qga/commands-posix.c:634:13: error: In the GNU C Library, "minor" is defined by <span class="hljs-tag">&lt;<span class="hljs-name">sys</span>/<span class="hljs-attr">sysmacros.h</span>&gt;</span>. For historical compatibility, it is currently defined by <span class="hljs-tag">&lt;<span class="hljs-name">sys</span>/<span class="hljs-attr">types.h</span>&gt;</span> as well, but we plan to remove this soon. To use "minor", include <span class="hljs-tag">&lt;<span class="hljs-name">sys</span>/<span class="hljs-attr">sysmacros.h</span>&gt;</span> directly. If you did not intend to use a system-defined macro "minor", you should undefine it after including <span class="hljs-tag">&lt;<span class="hljs-name">sys</span>/<span class="hljs-attr">types.h</span>&gt;</span>. [-Werror]         *devminor = minor(st.st_rdev);             ^~~~~~~~~~~~~~~~~~~~~~~~~~</code></pre></div><p>好在一般前人都踩过坑，Google一下直接照葫芦画瓢即可。</p><p>注：官方QEMU安装教程里面给出的提示，看到网上一些教程貌似没有注意到这里踩了挺多坑。</p><blockquote><p>On Linux, you may need to install several libraries. We have successfully built 6.828 QEMU on Debian/Ubuntu 16.04 after installing the following packages: libsdl1.2-dev, libtool-bin, libglib2.0-dev, libz-dev, and libpixman-1-dev</p></blockquote><h4 id="工具使用"><a href="#工具使用" class="headerlink" title="工具使用"></a>工具使用</h4><h5 id="QEMU"><a href="#QEMU" class="headerlink" title="QEMU"></a>QEMU</h5><ul><li>之前做CS:APP MIPS版本的bomb lab时使用过。主要是模拟硬件，这门课程中模拟了一个32位x86平台。</li></ul><h5 id="GDB"><a href="#GDB" class="headerlink" title="GDB"></a>GDB</h5><ul><li>用得不多，没有系统学过。</li></ul>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
      <category>MIT6.828</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
      <tag>6.828</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
