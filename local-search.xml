<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Go-06-sort源码分析</title>
    <link href="/2021/03/20/Go-06-sort%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <url>/2021/03/20/Go-06-sort%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h4 id="基本排序算法总结"><a href="#基本排序算法总结" class="headerlink" title="基本排序算法总结"></a>基本排序算法总结</h4><h5 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h5><h5 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h5><ul><li><p>首先找到一个基准数据，根据基准数据将所有数据分成大于它的和小于它的两个分区，再对两个分区进行同样的处理。</p></li><li><p>简单示例：</p><div class="hljs"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">quickSort</span><span class="hljs-params">(s []<span class="hljs-keyword">int</span>, l, r <span class="hljs-keyword">int</span>)</span></span> &#123;<span class="hljs-keyword">if</span> l &lt; r &#123;<span class="hljs-comment">//we need index of s[l] after partition -- i</span>i := lj := rtmp := s[l]<span class="hljs-keyword">for</span> i &lt; j &#123;<span class="hljs-keyword">for</span> i &lt; j &amp;&amp; s[j] &gt;= tmp &#123;j--&#125;<span class="hljs-keyword">if</span> i &lt; j &#123;s[i] = s[j]i++&#125;<span class="hljs-keyword">for</span> i &lt; j &amp;&amp; s[i] &lt; tmp &#123;i++&#125;<span class="hljs-keyword">if</span> i &lt; j &#123;s[j] = s[i]j--&#125;&#125;s[i] = tmpquickSort(s, i+<span class="hljs-number">1</span>, r)quickSort(s, l, i<span class="hljs-number">-1</span>)&#125;&#125;</code></pre></div></li><li><p>显然，快排是不稳定的。例如连续的两个小于基准的数据，由于发现的大于基准数据的位置是由小到大变化的，会导致顺序发生翻转。</p><ul><li>具体实现可能有不同的方法。解释也就不一样了。</li></ul></li></ul><h5 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h5><ul><li><p>主要是利用建堆、重构堆从而不断得到区间内的最大元素，然后交换使其到达数组末端。</p></li><li><p>简单实现：</p><div class="hljs"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">heapModify</span><span class="hljs-params">(s []<span class="hljs-keyword">int</span>, start, end <span class="hljs-keyword">int</span>)</span></span> &#123;<span class="hljs-comment">//start为非叶子节点 意味着其至少存在孩子</span><span class="hljs-comment">//2*start+1得到左孩子</span><span class="hljs-comment">//不断往下重构</span>son := <span class="hljs-number">2</span>*start + <span class="hljs-number">1</span><span class="hljs-keyword">for</span> son &lt;= end &#123;<span class="hljs-keyword">if</span> son+<span class="hljs-number">1</span> &lt;= end &amp;&amp; s[son] &lt; s[son+<span class="hljs-number">1</span>] &#123;son++&#125;<span class="hljs-keyword">if</span> s[start] &gt; s[son] &#123;<span class="hljs-keyword">return</span>&#125;s[start], s[son] = s[son], s[start]start = sonson = start*<span class="hljs-number">2</span> + <span class="hljs-number">1</span>&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">buildHeap</span><span class="hljs-params">(s []<span class="hljs-keyword">int</span>, end <span class="hljs-keyword">int</span>)</span></span> &#123;<span class="hljs-comment">//建堆 s[0--end)</span><span class="hljs-keyword">for</span> start := (<span class="hljs-built_in">len</span>(s) / <span class="hljs-number">2</span>) - <span class="hljs-number">1</span>; start &gt;= <span class="hljs-number">0</span>; start-- &#123;heapModify(s, start, end<span class="hljs-number">-1</span>)&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">heapSort</span><span class="hljs-params">(s []<span class="hljs-keyword">int</span>)</span></span> &#123;buildHeap(s, <span class="hljs-built_in">len</span>(s))<span class="hljs-keyword">for</span> i := <span class="hljs-built_in">len</span>(s) - <span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span>; i-- &#123;s[<span class="hljs-number">0</span>], s[i] = s[i], s[<span class="hljs-number">0</span>]heapModify(s, <span class="hljs-number">0</span>, i<span class="hljs-number">-1</span>)&#125;&#125;</code></pre></div></li><li><p>堆排也是不稳定的。考虑很简单的三个元素的情况：<code>1 1 1</code>。建堆之后不需要调整（即使调整也不影响结论），那么第一个元素会变成最后一个元素。</p></li></ul><h5 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h5><ul><li><p>常见排序算法：</p><p>| Algorithm                                                  | Best-case     | Worst-case    | Average-case  | Space Complexity        | Stable?     |<br>| ————————————————————————————— | ——————- | ——————- | ——————- | ———————————- | —————- |<br>| <a href="https://brilliant.org/wiki/merge/" target="_blank" rel="noopener">Merge Sort</a>            | $O(n \log n)$ | $O(n \log n)$ | $O(n \log n)$ | $O(n)$                  | Yes         |<br>| <a href="https://brilliant.org/wiki/insertion/" target="_blank" rel="noopener">Insertion Sort</a>    | $O(n)$        | $O(n^2)$      | $O(n^2)$      | $O(1)$                  | Yes         |<br>| <a href="https://brilliant.org/wiki/bubble-sort/" target="_blank" rel="noopener">Bubble Sort</a>     | $O(n)$        | $O(n^2)$      | $o(n^2)$      | $O(1)$                  | Yes         |<br>| <a href="https://brilliant.org/wiki/quick-sort/" target="_blank" rel="noopener">Quicksort</a>        | $O(n \log n)$ | $O(n^2)$      | $O(n \log n)$ | $\log n$  best, $n$ avg | Usually not |<br>| <a href="https://brilliant.org/wiki/heap-sort/" target="_blank" rel="noopener">Heapsort</a>          | $O(n \log n)$ | $O(n\log n)$  | $O(n \log n)$ | $O(1)$                  | No          |<br>| <a href="https://brilliant.org/wiki/counting-sort/" target="_blank" rel="noopener">Counting Sort</a> | $O(k+n)$      | $O(k+n)$      | $O(k+n)$      | $O(k+n)$                | Yes         |</p></li><li><p>基于比较的排序方法的上限是$O(\log n)$</p></li><li><p>实际选择排序算法需要综合多个角度考虑：</p><ul><li>数据规模</li><li>是否近似有序</li><li>稳定性要求</li><li>空间要求</li><li>cache友好</li></ul><p>……</p><p>所以尽管快排的平均时间复杂度最好，但是并非所有情况下直接上快排。</p></li></ul><h4 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h4><h5 id="整体结构"><a href="#整体结构" class="headerlink" title="整体结构"></a>整体结构</h5><ul><li><p>对于待排序的数据必须实现三种方法：<code>Len/Less/Swap</code></p><ul><li>目前主流的方法都是基于比较的，可以通过对<code>Less</code>进行封装从而得到大于、等于、小于等于……</li><li>根据索引进行交换也是必须的。</li></ul></li><li><p>函数调用路径</p><p><code>sort</code></p><ul><li><code>maxDepth</code></li><li><code>quickSort</code><ul><li><code>heapSort</code><ul><li><code>siftDown</code></li></ul></li><li><code>doPivot</code><ul><li><code>medianOfThree</code></li></ul></li><li><code>insertionSort</code></li></ul></li></ul></li></ul><h5 id="qucikSort"><a href="#qucikSort" class="headerlink" title="qucikSort"></a><code>qucikSort</code></h5><div class="hljs"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">quickSort</span><span class="hljs-params">(data Interface, a, b, maxDepth <span class="hljs-keyword">int</span>)</span></span> &#123;<span class="hljs-keyword">for</span> b-a &gt; <span class="hljs-number">12</span> &#123; <span class="hljs-comment">// Use ShellSort for slices &lt;= 12 elements</span><span class="hljs-keyword">if</span> maxDepth == <span class="hljs-number">0</span> &#123;heapSort(data, a, b)<span class="hljs-keyword">return</span>&#125;maxDepth--mlo, mhi := doPivot(data, a, b)<span class="hljs-comment">// Avoiding recursion on the larger subproblem guarantees</span><span class="hljs-comment">// a stack depth of at most lg(b-a).</span><span class="hljs-keyword">if</span> mlo-a &lt; b-mhi &#123;quickSort(data, a, mlo, maxDepth)a = mhi <span class="hljs-comment">// i.e., quickSort(data, mhi, b)</span>&#125; <span class="hljs-keyword">else</span> &#123;quickSort(data, mhi, b, maxDepth)b = mlo <span class="hljs-comment">// i.e., quickSort(data, a, mlo)</span>&#125;&#125;<span class="hljs-keyword">if</span> b-a &gt; <span class="hljs-number">1</span> &#123;<span class="hljs-comment">// Do ShellSort pass with gap 6</span><span class="hljs-comment">// It could be written in this simplified form cause b-a &lt;= 12</span><span class="hljs-keyword">for</span> i := a + <span class="hljs-number">6</span>; i &lt; b; i++ &#123;<span class="hljs-keyword">if</span> data.Less(i, i<span class="hljs-number">-6</span>) &#123;data.Swap(i, i<span class="hljs-number">-6</span>)&#125;&#125;insertionSort(data, a, b)&#125;&#125;</code></pre></div><p>上面函数就是关键部分。可以看到根据数据规模和<code>maxDepth</code>选择不同的排序算法：在规模很小时选择希尔和插入；规模比较大时选择堆排序，并且递归调用了<code>quickSort</code></p><h6 id="第一个问题，maxDepth是什么？"><a href="#第一个问题，maxDepth是什么？" class="headerlink" title="第一个问题，maxDepth是什么？"></a>第一个问题，<code>maxDepth</code>是什么？</h6><div class="hljs"><pre><code class="hljs go"><span class="hljs-comment">// maxDepth returns a threshold at which quicksort should switch</span><span class="hljs-comment">// to heapsort. It returns 2*ceil(lg(n+1)).</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxDepth</span><span class="hljs-params">(n <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<span class="hljs-keyword">var</span> depth <span class="hljs-keyword">int</span><span class="hljs-keyword">for</span> i := n; i &gt; <span class="hljs-number">0</span>; i &gt;&gt;= <span class="hljs-number">1</span> &#123;depth++&#125;<span class="hljs-keyword">return</span> depth * <span class="hljs-number">2</span>&#125;</code></pre></div><p>可以知道计算的是$[\log(n+1)]$（向上取整）。所以为什么选择这种方式去衡量数据规模而不是直接根据<code>len(data)</code>？后续究竟是如何根据这一指标去选择算法的：为0时为何选择堆排？</p><h6 id="第二个问题，doPivot函数干了什么？"><a href="#第二个问题，doPivot函数干了什么？" class="headerlink" title="第二个问题，doPivot函数干了什么？"></a>第二个问题，<code>doPivot</code>函数干了什么？</h6><p>很容易让人想到快排里面选择pivot。具体仔细看：</p><div class="hljs"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">doPivot</span><span class="hljs-params">(data Interface, lo, hi <span class="hljs-keyword">int</span>)</span> <span class="hljs-params">(midlo, midhi <span class="hljs-keyword">int</span>)</span></span> &#123;m := <span class="hljs-keyword">int</span>(<span class="hljs-keyword">uint</span>(lo+hi) &gt;&gt; <span class="hljs-number">1</span>) <span class="hljs-comment">// Written like this to avoid integer overflow.</span><span class="hljs-keyword">if</span> hi-lo &gt; <span class="hljs-number">40</span> &#123;<span class="hljs-comment">// Tukey's ``Ninther,'' median of three medians of three.</span>s := (hi - lo) / <span class="hljs-number">8</span>medianOfThree(data, lo, lo+s, lo+<span class="hljs-number">2</span>*s)medianOfThree(data, m, m-s, m+s)medianOfThree(data, hi<span class="hljs-number">-1</span>, hi<span class="hljs-number">-1</span>-s, hi<span class="hljs-number">-1</span><span class="hljs-number">-2</span>*s)&#125;medianOfThree(data, lo, m, hi<span class="hljs-number">-1</span>)</code></pre></div><p>其中的<code>medianOfThree</code>：</p><div class="hljs"><pre><code class="hljs go"><span class="hljs-comment">// medianOfThree moves the median of the three values data[m0], data[m1], data[m2] into data[m1].</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">medianOfThree</span><span class="hljs-params">(data Interface, m1, m0, m2 <span class="hljs-keyword">int</span>)</span></span> &#123;<span class="hljs-comment">// sort 3 elements</span><span class="hljs-keyword">if</span> data.Less(m1, m0) &#123;data.Swap(m1, m0)&#125;<span class="hljs-comment">// data[m0] &lt;= data[m1]</span><span class="hljs-keyword">if</span> data.Less(m2, m1) &#123;data.Swap(m2, m1)<span class="hljs-comment">// data[m0] &lt;= data[m2] &amp;&amp; data[m1] &lt; data[m2]</span><span class="hljs-keyword">if</span> data.Less(m1, m0) &#123;data.Swap(m1, m0)&#125;&#125;<span class="hljs-comment">// now data[m0] &lt;= data[m1] &lt;= data[m2]</span>&#125;</code></pre></div><p>可以看出来，上面函数的作用就是将中间值移到<code>m1</code>，最小值放在<code>m0</code>。结合注释，我们知道了<code>doPivot</code>首先会尝试找到中间值。如果数据长度超过40，那么我们取出九个点：<code>lo lo+s······hi-1</code>，然后每三个找出中间值，最后再找出三者中的中间值，最后中间值位于<code>lo</code>处。如果长度比较小，那么直接根据<code>lo m hi</code>取中间值即可。</p><p>之后需要对数据划分。值得注意的是，这里的<code>Less</code>就是严格小于。细节看注释。</p><div class="hljs"><pre><code class="hljs go">pivot := loa, c := lo+<span class="hljs-number">1</span>, hi<span class="hljs-number">-1</span><span class="hljs-keyword">for</span> ; a &lt; c &amp;&amp; data.Less(a, pivot); a++ &#123;&#125; <span class="hljs-comment">//结束时 a == c 或者 data[lo &lt; i &lt; a] &lt; data[pivot] 这一段是小于基准的</span>b := a<span class="hljs-keyword">for</span> &#123;<span class="hljs-keyword">for</span> ; b &lt; c &amp;&amp; !data.Less(pivot, b); b++ &#123; <span class="hljs-comment">// data[b] &lt;= pivot 注意!Less 等价于 data[pivot] &gt;= data[b]</span>&#125;<span class="hljs-keyword">for</span> ; b &lt; c &amp;&amp; data.Less(pivot, c<span class="hljs-number">-1</span>); c-- &#123; <span class="hljs-comment">// data[c-1] &gt; pivot </span>            <span class="hljs-comment">//从hi-2开始是因为前面的划分中hi-1已经大于等于pivot了</span>&#125;        <span class="hljs-comment">//此时：</span>        <span class="hljs-comment">/*</span><span class="hljs-comment">        data[c &lt;= i &lt; hi-1] &gt; pivot</span><span class="hljs-comment">        data[lo] = pivot (set up by ChoosePivot)</span><span class="hljs-comment">data[lo &lt; i &lt; a] &lt; pivot</span><span class="hljs-comment">data[a &lt;= i &lt; b] &lt;= pivot</span><span class="hljs-comment">如果b == c说明已经划分完毕</span><span class="hljs-comment">        */</span><span class="hljs-keyword">if</span> b &gt;= c &#123;<span class="hljs-keyword">break</span>&#125;<span class="hljs-comment">// data[b] &gt; pivot; data[c-1] &lt;= pivot </span>        <span class="hljs-comment">//交换之后使得data[a &lt;= i &lt;= b] &lt;= pivot data[c-1 &lt;= i &lt; hi -1] 所以b++ c-- 维持不变式</span>data.Swap(b, c<span class="hljs-number">-1</span>)b++c--&#125;</code></pre></div><p>总之，上述过程结束之后，我们完成了对数据的分区。</p><p><strong>todo：关于重复数据的处理</strong></p><p>最后，<code>doPivot</code>返回了第一个分区最后一个数据的索引和第二个分区第一个索引。</p><h6 id="quickSort结构梳理"><a href="#quickSort结构梳理" class="headerlink" title="quickSort结构梳理"></a><code>quickSort</code>结构梳理</h6><p>在解决了上面两个问题之后，我们对这个函数有了初步的整体性的理解。在数据长度大于12、<code>maxDepth</code>不为0时，我们会分区、再递归排序。这里为了避免出现递归爆栈的问题，每次都是选择一个较小的分区进行快排，然后通过<code>a = mhi or b = mlo</code>，从而使得下次调用<code>doPivot</code>时对另外一个分区进行划分、快排。</p>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CS144-06-Debug与总结</title>
    <link href="/2021/03/20/CS144-06-Debug%E4%B8%8E%E6%80%BB%E7%BB%93/"/>
    <url>/2021/03/20/CS144-06-Debug%E4%B8%8E%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h4 id="DEBUG"><a href="#DEBUG" class="headerlink" title="DEBUG"></a>DEBUG</h4><p>目前的情况是<code>make check_lab4</code>有两到三个test会失败，还有几个会超时，说明仍然是存在bug的。而且失败的test并不是固定的，是在真实的通信过程中出现了问题。</p><p><img src="https://i.loli.net/2021/03/20/ZxgEwN4lkC2o3dz.png" srcset="/img/loading.gif" alt="image-20210320121930811" style="zoom:67%;" /></p><p>这个test是在<code>txrx.sh</code>中的，具体怎么测试的不是很理解，应该涉及到shell编程。在<code>spong/build/Testing/LastTest.log</code>中我们可以看到具体传的参数：</p><p><img src="https://i.loli.net/2021/03/20/xrMG1azc7ROIj9E.png" srcset="/img/loading.gif" alt="image-20210320122521015" style="zoom:80%;" /></p><p>我们尝试去调用，发现失败了，提示<code>apps/tcp_ipv4: No sunch file or directory</code>。没有明白怎么回事。</p><hr><p>我们再尝试从逻辑的角度去debug。</p><p>首先是可能存在bug的sender的<code>ack_received</code>，当时写完了并不确定、过了test也就没管了，再来重新梳理一遍。</p><p><del>通过仔细反思<code>fill_window</code>函数，</del></p><p><code>ack_received</code>中计时器的修改有点奇怪。指导书中提到，如果所有的seg都被确认了，那么计时器应该置为false。如果到来的ack确认了一些seg，那么重传时间应该置为初始的，如果还存在未确认的</p>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
      <category>CS144</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
      <tag>CS144</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go-05-关于channel/共享变量</title>
    <link href="/2021/03/19/Go-05-%E5%85%B3%E4%BA%8E%E5%B9%B6%E5%8F%91%E3%80%81%E9%80%9A%E4%BF%A1/"/>
    <url>/2021/03/19/Go-05-%E5%85%B3%E4%BA%8E%E5%B9%B6%E5%8F%91%E3%80%81%E9%80%9A%E4%BF%A1/</url>
    
    <content type="html"><![CDATA[<h5 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h5><p>之前在操作系统实验中，进程/线程之间的通信我们主要有三种方式：信号量；消息队列；共享内存。实现起来其实是比较麻烦的，因为我们一般需要对系统调用进行封装，方便我们后续调用；并且对于共享资源访问时需要实现各种锁的机制，比如信号量/互斥锁。</p><h4 id="channel"><a href="#channel" class="headerlink" title="channel"></a>channel</h4><h5 id="理解channel"><a href="#理解channel" class="headerlink" title="理解channel"></a>理解channel</h5><ul><li>悲观锁与乐观锁<ul><li>悲观：假定每次持有数据时别人都会尝试修改，所以会给数据加锁。因此共享资源每次都会只有一个线程持有。适合多写的场景</li><li>乐观：假定持有数据时别人不会修改，因此不会上锁。但是在更新时会判断别人是否修改了数据，具体实现可以使用版本号/CAS。</li></ul></li></ul><p>相比C/C++里面使用系统调用、手动上锁，channel显然方便了很多。</p><p>例如读写者问题，我们只需要申明一个共享的、容量固定的channel，那么读者不断读即可。同样可以利用容量为1的channel来控制goroutine的执行顺序。</p><div class="hljs"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">"fmt"</span><span class="hljs-string">"strconv"</span><span class="hljs-string">"sync"</span>)<span class="hljs-comment">//创建10个写者goroutine 5个读者goroutine</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">string</span>, <span class="hljs-number">10</span>)order := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>, <span class="hljs-number">10</span>)<span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> order &#123;order[i] = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>, <span class="hljs-number">1</span>)&#125;<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;<span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(a <span class="hljs-keyword">int</span>)</span></span> &#123;&lt;-order[a]cnt := <span class="hljs-number">1</span><span class="hljs-keyword">for</span> cnt &lt;= <span class="hljs-number">5</span> &#123;tmp := <span class="hljs-string">"writer goroutine"</span> + strconv.Itoa(a) + <span class="hljs-string">" "</span> + strconv.Itoa(cnt) + <span class="hljs-string">"\n"</span>ch &lt;- tmpcnt++&#125;<span class="hljs-keyword">if</span> a &lt; <span class="hljs-number">9</span> &#123;order[a+<span class="hljs-number">1</span>] &lt;- <span class="hljs-number">1</span>&#125;<span class="hljs-built_in">close</span>(order[a])&#125;(i)&#125;order[<span class="hljs-number">0</span>] &lt;- <span class="hljs-number">1</span><span class="hljs-keyword">var</span> wg sync.WaitGroupt := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>, <span class="hljs-number">5</span>)<span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> t &#123;t[i] = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>, <span class="hljs-number">1</span>)&#125;t[<span class="hljs-number">0</span>] &lt;- <span class="hljs-number">1</span><span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">5</span>; j++ &#123;wg.Add(<span class="hljs-number">1</span>)<span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(b <span class="hljs-keyword">int</span>)</span></span> &#123;&lt;-t[b]<span class="hljs-keyword">defer</span> wg.Done()cnt := <span class="hljs-number">10</span><span class="hljs-keyword">for</span> cnt &gt; <span class="hljs-number">0</span> &#123;tmp := &lt;-chfmt.Printf(tmp)cnt--&#125;<span class="hljs-keyword">if</span> b &lt; <span class="hljs-number">4</span> &#123;t[b+<span class="hljs-number">1</span>] &lt;- <span class="hljs-number">1</span>&#125;<span class="hljs-built_in">close</span>(t[b])&#125;(j)&#125;wg.Wait()<span class="hljs-built_in">close</span>(ch)&#125;</code></pre></div><h4 id="共享变量"><a href="#共享变量" class="headerlink" title="共享变量"></a>共享变量</h4><h5 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h5><p>类似于初值为1的信号量，只是用起来更加方便。看上去也非常的暴力。</p><div class="hljs"><pre><code class="hljs go"><span class="hljs-keyword">var</span> mu sync.Mutexmu.Lock()mu.Unlock()</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go-04-内存管理</title>
    <link href="/2021/03/18/Go-04-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <url>/2021/03/18/Go-04-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h5 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h5><p>常见的内存分配方式</p><ul><li>线性分配：无法直接重用已经释放的空闲内存，需要配合特定的GC算法</li><li>空闲链表分配：通过指针构成的链表，分配时需要遍历整个链表。联想起操作系统里面学过的给页分配内存。只不过这里是在堆上进行分配。自然有多种分配算法：First-Fit/Best-Fit……<ul><li>隔离适应策略：分级。每个链表内存块均相同，不同内存块不同。</li></ul></li></ul><p>Go采用多级缓存内存分配</p><ul><li><p>类似于TCmalloc</p></li><li><p>根据申请内存的大小分为三个级别，微对象、小对象、大对象。</p></li><li><p>线程内部有thread cache，上一级是central cache，最高级是page heap。大对象直接在page heap上面分配大内存。</p></li></ul><p>在1.10及其之前我们是堆区的内存是连续的：分为三个区域，分别是spans/bitmap/arena，其中arena分成了很多的页，每一页8KB。spans区域存储的是指针，指向内存管理单元msapn。arena是真正的堆区，bitmap用于标示哪些被使用了。</p><ul><li>bitmap中一个字节对应着arena中的32字节。<strong>4bits标记是否有指针，4bits标记扫描。与GC的关系？</strong></li></ul><p>在1.11开始将堆分成很多的页——稀疏内存。</p><p>注意所有的内存最终都是需要向操作系统申请的。<strong>怎么申请的？返回的是什么？mmap等系统调用？</strong></p><h4 id="内存管理组件"><a href="#内存管理组件" class="headerlink" title="内存管理组件"></a>内存管理组件</h4><p>小结：</p><p>每一个P都会持有一个mcache：指向一个mcache结构体的指针。这个结构体中有一个alloc成员，其是一个指针数组，每一个指针指向一个内存管理单元mspan。数组长度为numSpanClass。</p><ul><li>总共有67+1个跨度类，spanClass是uint8类型的整数，高7位为类别，低位是标记是否含有指针——GC会对标记了的进行扫描。</li></ul><h5 id="mspan："><a href="#mspan：" class="headerlink" title="mspan："></a>mspan：</h5><ul><li>拥有两个指针，分别指向前后的mspan，构成双向链表的结构。</li></ul><ul><li><code>startAddr</code> 和 <code>npages</code> — 确定该结构体管理的多个页所在的内存，每个页的大小都是 8KB；</li><li><code>freeindex</code> — 扫描页中空闲对象的初始索引；</li><li><code>allocBits</code> 和 <code>gcmarkBits</code> — 分别用于标记内存的占用和回收情况；</li><li><code>allocCache</code> — <code>allocBits</code> 的补码，可以用于快速查找内存中未被使用的内存</li></ul><p>mcache</p><p>初始化：</p><p>在初始化P的时候，会调用<code>runtime.allocmcache</code>初始化线程的缓存，其会调用<code>runtime.mheap</code>中的线程缓存分配器来初始化。</p>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go-03-多线程下载器</title>
    <link href="/2021/03/16/Go-03-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8B%E8%BD%BD%E5%99%A8/"/>
    <url>/2021/03/16/Go-03-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8B%E8%BD%BD%E5%99%A8/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go-02-实现B+树</title>
    <link href="/2021/03/16/Go-02-%E5%AE%9E%E7%8E%B0B-%E6%A0%91/"/>
    <url>/2021/03/16/Go-02-%E5%AE%9E%E7%8E%B0B-%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<hr><h5 id="B-树的基本原理"><a href="#B-树的基本原理" class="headerlink" title="B+树的基本原理"></a>B+树的基本原理</h5><ul><li><p>二叉查找树，可能变成链表，导致效率非常低。</p></li><li><p>平衡二叉树AVL，通过限制节点左右子树的层级差不大于1从而确保二叉树的搜索效率</p></li><li>B树：在平衡二叉树的基础上增加每个节点的key的数目<ul><li>对于m阶B树(m &gt;= 2)，非叶子节点的子节点数目[2, m]，枝节点的key数量在[ceil(m/2)-1, m-1]，叶子节点均位于同一层</li><li>查找：原理就是不断二分</li><li>插入：直接插入叶子节点；可能会导致叶子节点key数量超出限制，需要拆分。循环：将节点的中心key插入到父节点，原本节点的左右两段分别属于key的左右；直到没有节点超出限制。</li><li>删除：如果待删除key位于非叶子节点，通过后续节点替换的方式确保最终需要删除的节点位于叶子节点；删除之后可能数量不够<ul><li>如果兄弟节点数量大于ceil(m/2)-1，那么借用</li><li>否则将父节点的key与当前节点、兄弟节点进行合并</li></ul></li></ul></li><li>B+树<ul><li>定义：MySql当中非叶子节点的key数量等同于子节点数量。另外一种定义就是子节点数量要多1。注意根节点也可以是叶子节点。</li><li>与B树相比，重要的区别在于只有叶子节点才存储了data，而非叶子节点则只存储了索引。因此带来了插入删除的变化。</li></ul></li></ul><h5 id="B-树在工程中的应用"><a href="#B-树在工程中的应用" class="headerlink" title="B+树在工程中的应用"></a>B+树在工程中的应用</h5><p>Mysql的InnoDB存储引擎使用了B+树。</p><ul><li>对于聚集索引——将主键作为B+树的key，叶子节点存储真正的数据。每个节点大小刚好对应磁盘的一页，每次根据指向子节点的指针从磁盘中读取下一页。注意根节点所在的页常驻内存。同时节点之间双向连接，叶子节点中的数据单向连接。使得范围查询也很简单：在查找范围的左边界之后，沿着链表走即可。</li><li>对于非聚集索引，B+树的key是非主键的列值，数据则是主键。这样我们根据非主键的列进行查找时，首先找到对应的主键，再在聚集索引中寻找到真正的数据。</li></ul><p>为什么使用B+树而非B树？</p><ul><li>磁盘访问速度很慢，因此需要尽量减少磁盘的访问次数。同时磁盘的访问以块为单位。<ul><li>数据库中页的概念</li><li>为什么一个节点对应一个扇区？</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go-01-GMP模型</title>
    <link href="/2021/03/16/Go-01-GMP%E6%A8%A1%E5%9E%8B/"/>
    <url>/2021/03/16/Go-01-GMP%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h5 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h5><ul><li><p><a href="https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-goroutine/#651-%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86" target="_blank" rel="noopener">https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-goroutine/#651-%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86</a></p><p>《Go语言设计与实现》</p></li><li><p><a href="https://juejin.cn/post/6886321367604527112" target="_blank" rel="noopener">https://juejin.cn/post/6886321367604527112</a> </p></li></ul><h5 id="调度的整体流程"><a href="#调度的整体流程" class="headerlink" title="调度的整体流程"></a>调度的整体流程</h5><ul><li>P中存在着一个本地队列以及<code>runnext guintptr</code>，用于M获取runable的G。M首先要与P绑定，然后不断地获取G去执行。</li><li>获取过程：<ul><li>如果M绑定的P为空，那么前往全局队列尝试获取G<ul><li>如果全局队列仍然为空，那么work-stealing</li><li>如果一直没有G，那么进入idle状态</li></ul></li></ul></li><li>执行过程：<ul><li>如果G因为systemcall而阻塞，那么M被阻塞，P与M解绑，尝试重新绑定到一个idle的M或者新建一个M</li><li>如果G因为channel阻塞，那么G会被放到某个等待队列，M会尝试获取下一个G—G2。当原本的G被唤醒时，会被加入到P的<code>runnext</code>。如果M没有获取到G，那么解绑并sleep。</li><li>如果没有阻塞，那么M执行完毕之后不会被销毁，而是继续获取G再执行，这样就避免了线程创建销毁带来的开销。</li></ul></li></ul><h5 id="设计原理"><a href="#设计原理" class="headerlink" title="设计原理"></a>设计原理</h5><p>很早版本的单线程调度器已经有了G和M，下面是切换G时保存状态的代码：</p><div class="hljs"><pre><code class="hljs assembly">TEXT gosave(SB), 7, $0MOVQ8(SP), AX&#x2F;&#x2F; gobufMOVQSP, 0(AX)&#x2F;&#x2F; save SPMOVQ0(SP), BXMOVQBX, 8(AX)&#x2F;&#x2F; save PCMOVL$0, AX&#x2F;&#x2F; return 0RET</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Nachos-01-线程管理</title>
    <link href="/2021/03/15/Nachos-01-%E7%BA%BF%E7%A8%8B%E7%AE%A1%E7%90%86/"/>
    <url>/2021/03/15/Nachos-01-%E7%BA%BF%E7%A8%8B%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<hr><p>在学操作系统的时候就有很多疑惑：</p><ul><li>上下文切换细节是什么，硬件软件层面分别做了哪些具体的工作？</li><li>线程的映射模型到底是什么意思？什么是映射？为何需要映射？不同的映射模型到底是如何实现的？</li><li>共享内存是如何实现的？怎么映射到同一块内存——物理的？Linux里面<code>task_struct</code>结构体中拥有指向<code>mm_struct</code>的指针，对<code>mm_struct</code>的理解</li><li>第一个进程是如何创建的？</li></ul><p>……</p><p>产生疑惑的重要原因就在于没有看内核设计、没有看源码，导致都是在一些抽象概念上面游走。所以现在结合Nachos以及Linux内核设计与实现来真正理解OS。当然，并不会逐句分析源码，仅仅分析关键部分。</p><hr><h4 id="线程创建"><a href="#线程创建" class="headerlink" title="线程创建"></a>线程创建</h4><h5 id="main线程的创建"><a href="#main线程的创建" class="headerlink" title="main线程的创建"></a>main线程的创建</h5><p><code>main.cc--&gt;system.cc.Initialize--&gt;currentthread = new Thread(&quot;main&quot;)</code></p><p><code>thread.h</code>定义了线程类，我们创建线程的时候只需要提供一个<code>char * debugName</code>，感觉是用来debug的、并没有实际用处。真正执行时我们会用到<code>fork</code>函数：<code>void Fork(VoidFunctionPtr func, _int arg); // Make thread run (*func)(arg)</code>。</p><div class="hljs"><pre><code class="hljs c++"><span class="hljs-comment">// We didn't explicitly allocate the current thread we are running in.</span><span class="hljs-comment">// But if it ever tries to give up the CPU, we better have a Thread</span><span class="hljs-comment">// object to save its state. </span>currentThread = <span class="hljs-keyword">new</span> Thread(<span class="hljs-string">"main"</span>);currentThread-&gt;setStatus(RUNNING);</code></pre></div><p>线程内部定义了<code>status stack stack_top machineState</code>等变量。可以看到我们并没有分配栈等资源。</p><p>在分配栈资源的函数里面：</p><div class="hljs"><pre><code class="hljs c++"><span class="hljs-keyword">void</span>Thread::StackAllocate (VoidFunctionPtr func, _int arg)&#123;    <span class="hljs-built_in">stack</span> = (<span class="hljs-keyword">int</span> *) AllocBoundedArray(StackSize * <span class="hljs-keyword">sizeof</span>(_int));<span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> HOST_SNAKE</span>    <span class="hljs-comment">// HP stack works from low addresses to high addresses</span>    stackTop = <span class="hljs-built_in">stack</span> + <span class="hljs-number">16</span>;<span class="hljs-comment">// HP requires 64-byte frame marker</span>    <span class="hljs-built_in">stack</span>[StackSize - <span class="hljs-number">1</span>] = STACK_FENCEPOST;<span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span>    <span class="hljs-comment">// i386 &amp; MIPS &amp; SPARC &amp; ALPHA stack works from high addresses to low addresses</span><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> HOST_SPARC</span>    <span class="hljs-comment">// SPARC stack must contains at least 1 activation record to start with.</span>    stackTop = <span class="hljs-built_in">stack</span> + StackSize - <span class="hljs-number">96</span>;<span class="hljs-meta">#<span class="hljs-meta-keyword">else</span>  <span class="hljs-comment">// HOST_MIPS  || HOST_i386 || HOST_ALPHA</span></span>    stackTop = <span class="hljs-built_in">stack</span> + StackSize - <span class="hljs-number">4</span>;<span class="hljs-comment">// -4 to be on the safe side!</span><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> HOST_i386</span>......</code></pre></div><p>这里首先需要分配内存并返回指向栈底的指针给<code>stack</code>。</p><div class="hljs"><pre><code class="hljs c++"><span class="hljs-keyword">char</span> * AllocBoundedArray(<span class="hljs-keyword">int</span> <span class="hljs-built_in">size</span>)&#123;    <span class="hljs-keyword">int</span> pgSize = getpagesize();    <span class="hljs-keyword">char</span> *ptr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[pgSize * <span class="hljs-number">2</span> + <span class="hljs-built_in">size</span>];    mprotect(ptr, pgSize, <span class="hljs-number">0</span>);    mprotect(ptr + pgSize + <span class="hljs-built_in">size</span>, pgSize, <span class="hljs-number">0</span>);    <span class="hljs-keyword">return</span> ptr + pgSize;&#125;</code></pre></div><ul><li><p>这个<code>mprotect</code>很容易让人想到内存保护中，设置两个寄存器用于访存时比较目标地址判断是否越界。找到定义：</p><div class="hljs"><pre><code class="hljs c++"><span class="hljs-comment">//mman.h</span><span class="hljs-comment">/* Change the memory protection of the region starting at ADDR and</span><span class="hljs-comment">   extending LEN bytes to PROT.  Returns 0 if successful, -1 for errors</span><span class="hljs-comment">   (and sets errno).  */</span><span class="hljs-function"><span class="hljs-keyword">extern</span> <span class="hljs-keyword">int</span> <span class="hljs-title">mprotect</span> <span class="hljs-params">(<span class="hljs-keyword">void</span> *__addr, <span class="hljs-keyword">size_t</span> __len, <span class="hljs-keyword">int</span> __prot)</span> __THROW</span>;</code></pre></div></li><li><div class="hljs"><pre><code class="lang-c++"># if defined __USE_MISC || !defined __USE_XOPEN2K/* Return the number of bytes in a page.  This is the system&#39;s page size,   which is not necessarily the same as the hardware page size.  */extern int getpagesize (void)  __THROW __attribute__ ((__const__));</code></pre></div><p>Nachos页大小为128KB，<code>StackSize</code>定义为<code>sizeof(int) * 1024</code>。这里又乘了<code>sizeof(int)</code>。<strong>有点奇怪。</strong>    </p></li></ul><p>注意在线程类里面还有关键的定义：</p><p><img src="https://i.loli.net/2021/03/15/slownGLyqAaH7R8.png" srcset="/img/loading.gif" alt="image-20210315172229189" style="zoom:67%;" /></p><p>这里的<code>AddrSpace *space</code>指向进程的地址空间。暂时不是很明确。</p><h5 id="线程创建、调度、执行入口、终止"><a href="#线程创建、调度、执行入口、终止" class="headerlink" title="线程创建、调度、执行入口、终止"></a>线程创建、调度、执行入口、终止</h5><ul><li><p>首先线程在创建时的状态是<code>JUST_CREATED</code>。之后在调用<code>fork</code>之后分配栈资源，并且将其加入调度器的就绪队列。</p></li><li><p>在分配栈空间时，会设置一些<code>machineState</code>。</p><p><img src="https://i.loli.net/2021/03/15/Yzmw3CdqV4kIZNQ.png" srcset="/img/loading.gif" alt="image-20210315174215941"></p><p>这个<code>ThreadRoot</code>位于<code>switch.s</code>。</p></li><li></li></ul>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
      <category>Nachos</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
      <tag>Nachos</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CS144-05-Lab4</title>
    <link href="/2021/03/11/CS144-05-Lab4/"/>
    <url>/2021/03/11/CS144-05-Lab4/</url>
    
    <content type="html"><![CDATA[<blockquote><p>We’d discourage you from trying to read the test source code, unless it is as a last resort</p></blockquote><p>看来还是不要测试驱动开发了。</p><hr><h5 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h5><p>总结一下之前的实验二和三，我们已经实现了receiver/sender，里面的逻辑已经基本清晰：</p><ul><li>receiver<ul><li>接收segment，根据SYN/FIN/seqno等信息决定舍弃与否，如果接收那么放入reassembler的一个实例</li><li>返回期望接收的第一个byte的seqno</li></ul></li><li>sender<ul><li>根据接收到的window_size以及ackno来发送bytes</li><li>记录了连续重传的相关信息，可以用来判断是否应该断开连接</li><li>重要的逻辑是计时器相关，什么时候开/关/之后的行为</li></ul></li></ul><p>而在实验四，我们需要完成<code>tcp_connection</code>，即包括receiver and sender。因为TCP是全双工的，连接的一方既会接收也会发送。我们首先考虑一下两者之间的联系：</p><ul><li>receiver接收到的seg里面可能包括ackno/window_size，需要反馈给sender</li><li>receiver接收到SYN/FIN/reset信息</li></ul><hr><h5 id="FAQs"><a href="#FAQs" class="headerlink" title="FAQs"></a>FAQs</h5><p>完成了几个normal functions，接下来仔细阅读FAQs。</p><ul><li><p>为什么connection也有一个<code>_segments_out</code>。但是sender不是有一个<code>_segments_out</code>吗</p><ul><li>注意在sender中我们并没有真正的发送——只是将segments放入到了<code>_segment_out</code> 当中。那么connection的实现需要我们将  sender的<code>_segments_out</code>传到connection的<code>_segments_out</code>。</li><li>这里需要结合那张图：CS144TCPSocket来理解。connection封装了sender/receiver。对于接受来说，首先是connection接受了，然后再传送给receiver。</li></ul></li><li><p>关于RST</p><ul><li>收到了怎么办</li><li><p>什么情况应该发送</p></li><li><p>如何在不侵入sender的情况下完成发送？</p></li></ul></li><li><p>ACK</p><ul><li>发送时的设置</li><li>接收segment时判断</li></ul></li><li><p>结束connection</p><ul><li>unclean</li><li>clean</li></ul></li></ul><h5 id="clean-unclean-shutdown"><a href="#clean-unclean-shutdown" class="headerlink" title="clean/unclean shutdown"></a>clean/unclean shutdown</h5><blockquote><p> If the inbound stream ends before theTCPConnection has reached EOF on its outbound stream, this variable needs to be set to false</p></blockquote><p>不难理解，对于主动关闭，我们发送FIN、收到ACK，然后对方发送FIN，我们返回ACK，这时我们需要等待——即<strong>TIME_WAIT</strong>状态。因为我们返回的ACK可能丢失、对方可能重传，此时等待就有了意义。而对于被动关闭来说，我们收到了FIN，返回ACK，之后如果我们发送了FIN，那么在收到ACK之后便可以直接关闭了——无需等待。很显然，这里被动主动是相对的。</p><p>所以我们什么时候应该clean_shutdown？什么时候应该unclean_shutdown。对于后者应该容易回答：</p><ul><li>重传次数过多</li><li>收到RST</li><li>析构时仍然处于active状态</li></ul><p>注意，双方stream关闭之后延迟一段时间再转为close。</p><p>而对于clean_shutdown，我们必须弄清楚其条件，然后在可能满足条件的地方调用。</p><p>条件：</p><ul><li><p>receiver收到了FIN、关闭inbound stream</p><ul><li><p>如果此时outbount stream尚未关闭 那么说明是passive close，我们无需等待</p></li><li><p>如果outbound stream已经关闭、并且所有bytes均被确认，那么如果不需要等待就直接close，或者超时也close。</p></li></ul></li></ul><p>调用：</p><ul><li>其实很粗暴的方法是每个函数都加上一个，毕竟如果不满足条件也没啥关系。</li><li></li></ul><h5 id="write"><a href="#write" class="headerlink" title="write"></a>write</h5><ul><li>将data写入sender的ByteStream中</li><li>将sender的_segments_out pop掉</li></ul><h5 id="segment-received"><a href="#segment-received" class="headerlink" title="segment_received"></a>segment_received</h5><p>这里需要处理的逻辑比较多。如果处于关闭状态，那么自然不能接受。然后我们需要判断收到的seg的头部的标志位的情况：</p><ul><li>如果是正常的数据包，那么传给receiver同时把ack和window_size传给sender</li><li>如果收到了RST，那么调用<code>unclean_shutdown</code></li><li>如果是SYN，那么其可能并不携带ACK，所以不能直接传给sender<ul><li>如果收到SYN之后再次收到，虽然我们的receiver考虑到了这种逻辑，但是我们应该直接丢弃它</li></ul></li><li></li></ul><h5 id="DEBUG、状态转换"><a href="#DEBUG、状态转换" class="headerlink" title="DEBUG、状态转换"></a>DEBUG、状态转换</h5><p><strong>[01]</strong></p><p><img src="https://i.loli.net/2021/03/17/HJUZnEpyQ9qhkfO.png" srcset="/img/loading.gif" alt="image-20210317160039922" style="zoom:67%;" /></p><p>分析原因：我们在收到了之前发送的SYN的确认之后应该返回ACK，但是我们并没有这样做。通过分析实现中函数的调用过程，我们发现，初始时由于<code>_sender</code>的<code>_stream</code>为空，通过<code>_sender.ack_received</code>调用<code>fill_window</code>并不会真的发送seg。所以增加了这部分逻辑之后没有再出现这个错误。</p><p><strong>[02]</strong></p><p><img src="https://i.loli.net/2021/03/17/b3touBPvFWwhHkN.png" srcset="/img/loading.gif" alt="image-20210317203642020"></p><p>好家伙，重复了三句话，只是告诉我们状态不对、预期状态不是这样。</p><p>继续查看报错的信息，了解到：通过三次握手之后我们已经建立了连接，紧接着我们便主动关闭连接。经过9999ms，我们还没有超时——此时应该处于TIME_WAIT状态，再经过1ms我们便应该关闭了，但是事实上并没有。</p><p>所以还是去看函数的调用过程：在<code>tick</code>函数当中应该调用<code>clean_shutdown</code>。注：发现这点后修改了前面clean_shutdown相关内容。</p><p><strong>[03]</strong></p><p><img src="https://i.loli.net/2021/03/17/HzuNFoby7XYf94P.png" srcset="/img/loading.gif" alt="image-20210317214913957" style="zoom:67%;" /></p><p>上面的信息告诉我们处于<code>LISTEN</code>状态时应该直接拒绝所有的RST。</p><p>而我们的逻辑很粗暴：</p><div class="hljs"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">TCPConnection::segment_received</span><span class="hljs-params">(<span class="hljs-keyword">const</span> TCPSegment &amp;seg)</span> </span>&#123;     <span class="hljs-keyword">if</span>(!_active)<span class="hljs-keyword">return</span>;    <span class="hljs-keyword">if</span>(seg.header().rst)&#123;        unclean_shutdown();        <span class="hljs-keyword">return</span>;    &#125;</code></pre></div><p>所以需要在具体的状态中去修改。</p><p>这个测试位于<code>fsm_active_close</code>，测试状态机的状态转换。所以首先对照着TCP的11种状态，考虑一下能否正常运行而不是去看测试源码。注意在Lab2/3的指导书末尾分别给出了receiver/sender的状态转换图，并给出了相关变量的状态。</p><p>状态转换：</p><ul><li><p>首先sender处于<code>CLOSED</code>状态，receiver处于<code>LISTEN</code>状态。</p><ul><li><p>如果此时调用connect，那么意味着主动发起连接，调用sender的<code>fill_window</code>函数，并且调用<code>send_segs_in_sender()</code>。此时状态应该转换成<code>SYN_SENT</code>。</p><ul><li>如果一直没有收到ACK会怎样？超时重传——调用者调用<code>tick</code>函数。如果重传次数过多那么<code>unclean_shutdown</code></li></ul></li><li><p>如果此时收到了一个seg，我们期望它是SYN，并且<code>connect</code>之后状态变为<code>SYN_SENT</code>和<code>SYN_RECV</code></p><ul><li>不会携带ACK和window_size</li><li>如果不是SYN那么直接丢弃</li><li>我们需要发送自己的SYN，包含了ack——这里sen_segs_in_sender处理是没有问题的。</li></ul></li></ul></li><li><p>在sender处于<code>SYN_SENT</code>并且receiver尚处于<code>LISTEN</code>时，我们期望收到SYN</p><ul><li>如果有data，不符合SYN，丢弃；没有SYN丢弃；</li><li>如果有ACK，那么正常接收——receiver接收，sender调用<code>ack_received</code>。</li><li>如果没有ACK，有可能是因为双方同时尝试建立连接，receiver正常接收，并且sender发送一个空的seg，用于返回ACK。</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
      <category>CS144</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
      <tag>CS144</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>High Performance Mysql [Notes]</title>
    <link href="/2021/03/07/High%20Performance%20Mysql%20%5BNotes%5D/"/>
    <url>/2021/03/07/High%20Performance%20Mysql%20%5BNotes%5D/</url>
    
    <content type="html"><![CDATA[<h3 id="ch1-Mysql-Architecture-and-History"><a href="#ch1-Mysql-Architecture-and-History" class="headerlink" title="ch1 Mysql Architecture and History"></a>ch1 Mysql Architecture and History</h3><h4 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h4><h5 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h5><ul><li><p>ACID属性</p></li><li><p>隔离性的四个级别</p><ul><li><p>关于nonrepeatedable read</p><blockquote><p>…a transaction T2 could change the value of an object A that has been read by a transaction T1, while T1 is still in progress. If T1 tries to read the value of A again, it will get a different result, even though it has not modified A in the meantime… —<em>Database Management Systems</em></p></blockquote></li></ul></li></ul><h5 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h5>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>Mysql</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
      <tag>Mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CS144-04-Lab3</title>
    <link href="/2021/03/07/CS144-04-Lab3/"/>
    <url>/2021/03/07/CS144-04-Lab3/</url>
    
    <content type="html"><![CDATA[<h5 id="为什么需要随机的ISN"><a href="#为什么需要随机的ISN" class="headerlink" title="为什么需要随机的ISN"></a>为什么需要随机的ISN</h5><p><a href="https://www.quora.com/Why-in-a-TCP-sequence-is-a-number-taken-as-a-random-number-and-what-is-the-actual-number-at-the-start" target="_blank" rel="noopener">https://www.quora.com/Why-in-a-TCP-sequence-is-a-number-taken-as-a-random-number-and-what-is-the-actual-number-at-the-start</a></p><p><a href="https://www.techrepublic.com/article/tcp-hijacking/" target="_blank" rel="noopener">https://www.techrepublic.com/article/tcp-hijacking/</a></p><p><a href="https://pdos.csail.mit.edu/~rtm/papers/117.pdf" target="_blank" rel="noopener">https://pdos.csail.mit.edu/~rtm/papers/117.pdf</a></p><p>主要是与一些攻击方式有关系。具体的原理尚未明白。</p><h4 id="Implementing-the-TCP-Sender"><a href="#Implementing-the-TCP-Sender" class="headerlink" title="Implementing the TCP Sender"></a>Implementing the TCP Sender</h4><h5 id="fill-window"><a href="#fill-window" class="headerlink" title="fill_window"></a><code>fill_window</code></h5><h5 id="debug记录"><a href="#debug记录" class="headerlink" title="debug记录"></a>debug记录</h5><p><code>send_tmtx</code>失败。提示：</p><blockquote><p>Test Failure on expectation:<br>        Expectation: segment sent with (A=0,R=0,S=1,F=0,seqno=496550203,payload_size=0,…)</p><p>Failure message:<br>        The Sender should have produced a segment that existed, but it did not</p></blockquote><p>测试源码如下：</p><p><img src="https://i.loli.net/2021/03/10/hWICFAmzGwptkq1.png" srcset="/img/loading.gif" alt="image-20210310152456694" style="zoom:67%;" /></p><p>即其调用了两次<code>tick</code>，第一次刚好比<code>rt_timeout</code>小1，第二次又增加了1，因此第二次调用之后应该重传。但是本来的实现逻辑中，重传必须：<code>_ms_accumulated &gt; _current_retransmission</code>。改成大于等于即可。</p><p><strong>sender的窗口如何调整？</strong></p><p><code>send_extra</code>失败。在test<code>Don&#39;t add FIN if this would make the segment exceed the receiver&#39;s window</code>处发生错误。经过检查确认了sender窗口的调整是有问题的。本来我们直接使用每次接收到的<code>window_size</code>去更新<code>_sender_window_size</code>。显然这是不正确的。</p><p>我们必须明确<code>_sender_window_size</code>的含义是：从<code>_next_seqno</code>开始，在abs seqno表示的stream中，接收端会接收的bytes的abs seqno的范围。那么在receiver处，其希望接收的范围是[ackno, ackno + window_size)。对比一下，显然是[_next_seqno, ackno + window_size)。所以<code>_sender_window_size = ackno + window_size - _next_seqno</code>。（ackno如果比 _next_seqno大那么直接舍弃）</p><p><strong>为什么receiver 返回window_size = 0时应该将window_size视为1？</strong></p><p><img src="https://i.loli.net/2021/03/11/erLhKXyD6cFIosA.png" srcset="/img/loading.gif" alt="image-20210311132440348"></p><p>考虑这样一种情况：unassembled_bytes = 0，ByteStream.size() == _capacity。那么此时返回的窗口大小为0。但是一旦ByteStream被读走了字节，那么窗口大小会调整。如果sender发送了一个字节，那么receiver会返回新的window_size。</p>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
      <category>CS144</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
      <tag>CS144</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CS144-03-Lab2</title>
    <link href="/2021/03/03/CS144-03-Lab2/"/>
    <url>/2021/03/03/CS144-03-Lab2/</url>
    
    <content type="html"><![CDATA[<hr><p>读完《TCP/IP详解 卷一：协议》CH12之后对于指导书中的图有了大致的理解，包括TCP头部各个字段的含义。</p><p>TCP接收方需要告诉发送方两方面的信息：</p><ul><li><p>接收方期待的下一个字节在stream中的序号。回想Lab1，我们有first_unread/first_unassembled/first_unacceptable。其中<code>[first_unread, first_unassembled)</code>即为已经组装好的segments，接收方希望下一个字节是first_unassembled对应的字节，接收方已经接收了此前的字节。这里的first_unassembled即为<strong>ackno——acknowledgment number</strong>。</p></li><li><p><code>[first_unassembled, first_unacceptable)</code>即为<strong>滑动窗口</strong>——此时接收方希望接收的字节的序列号的范围。</p></li></ul><h4 id="Translating-between-64-bit-indexes-and-32-bit-seqnos"><a href="#Translating-between-64-bit-indexes-and-32-bit-seqnos" class="headerlink" title="Translating between 64-bit indexes and 32-bit seqnos"></a>Translating between 64-bit indexes and 32-bit seqnos</h4><p>我们有三种序列：</p><ul><li>在TCP传输中标志每个字节的序列号，从ISN开始，32位</li><li>absolute seqno 将上者变为从0开始</li><li>stream中每个字节的序列号，即真正传输的数据的序列号</li></ul><p><img src="https://i.loli.net/2021/03/04/d3xwi5Pqo87GaAE.png" srcset="/img/loading.gif" alt="image-20210304175138487" style="zoom: 67%;" /></p><p>我们首先需要完成<code>WrappingInt32</code>类——对uint32_t进行封装，从而使其与uint64_t转换更加方便。</p><h5 id="wrap"><a href="#wrap" class="headerlink" title="wrap"></a><code>wrap</code></h5><p>很显然，我们取出<code>uint64_t n</code>的低32位，然后与<code>ISN</code>相加即可。</p><div class="hljs"><pre><code class="hljs c++"><span class="hljs-function">WrappingInt32 <span class="hljs-title">wrap</span><span class="hljs-params">(<span class="hljs-keyword">uint64_t</span> n, WrappingInt32 isn)</span> </span>&#123;   <span class="hljs-keyword">return</span> WrappingInt32(<span class="hljs-keyword">uint32_t</span>(n &amp; <span class="hljs-number">0x00000000FFFFFFFF</span>) + isn.raw_value());&#125;</code></pre></div><h5 id="unwrap"><a href="#unwrap" class="headerlink" title="unwrap"></a><code>unwrap</code></h5><p>从seqence number 向absolute sequence number转换：</p><ul><li><p>很显然这种转换不是唯一的——seqno每次增加$2^{32}$值都不变，但是absolute seqno变化。为了确定唯一的结果，我们需要<code>checkpoint</code>，即将可能的结果中距离<code>checkpoint</code>最近的作为最终结果。</p></li><li><p><del>我们知道这里<code>checkpoint</code>实际上是last reassembled bytes，那么新来的segment对应的seqno转换成absolute seqno之后应当大于<code>checkpoint</code>。</del>我们知道这里<code>checkpoint</code>实际上是last reassembled bytes，那么新来的segment对应的seqno转换成absolute seqno之后应当大于<code>checkpoint</code>。所以如果我们知道<code>checkpoint</code>最少增加多少就变成答案即可。答案记作<code>ans</code>，那么如果我们将<code>checkpoint</code>转换成32位的seqno，记作<code>cp_seqno</code>，那么实际上从<code>cp_seqno</code>走到<code>n</code>与<code>checkpoint</code>走到<code>ans</code>距离应该是一样的。</p><p><del>如何得到这个距离？如果<code>n - cp_seqno &gt;= 0</code>，那么是正常的；如果<code>n - cp_seqno &lt; 0</code>，那么说明其实是从<code>cp_seqno</code>继续增长、溢出$2^{32}-1$从0开始，所以我们需要将<code>n</code>加上$2^{32}$。</del></p><p>写完发现报错了。马上想到，新来的segment的seqno在整个stream中未必是在<code>checkpoint</code>之后，也有可能在之前——会导致被抛弃，这是合理的。所以有可能比<code>checkpoint</code>小。</p><div class="hljs"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">uint64_t</span> <span class="hljs-title">unwrap</span><span class="hljs-params">(WrappingInt32 n, WrappingInt32 isn, <span class="hljs-keyword">uint64_t</span> checkpoint)</span> </span>&#123;  <span class="hljs-keyword">int32_t</span> tmp = n - wrap(checkpoint, isn);  <span class="hljs-keyword">int64_t</span> ans = checkpoint + tmp;  <span class="hljs-keyword">return</span> ans &gt;= <span class="hljs-number">0</span> ? ans : ans + (<span class="hljs-number">1u</span>l &lt;&lt; <span class="hljs-number">32</span>);&#125;</code></pre></div></li></ul><h4 id="Implementing-the-TCP-receiver"><a href="#Implementing-the-TCP-receiver" class="headerlink" title="Implementing the TCP receiver"></a>Implementing the TCP receiver</h4><h5 id="关于TCP"><a href="#关于TCP" class="headerlink" title="关于TCP"></a>关于TCP</h5><p>首先有一个问题，为什么SYN 也需要一个序列号？序列号存在的意义有两方面：</p><ul><li>为了重组segment。只有标示了segment的data在整个stream中的index，我们才能将乱序的data再重组成完成的stream，才能实现一种可靠的流模式</li><li>为了可靠性——连接中任意一方发送的数据能够被对方通过ack确认，否则需要重传。那么显然发送SYN的一方也需要知道自己的SYN是否被接收了，怎么办？给SYN一个sequence number，如果有ack = sequence number + 1，那么便OK了。自然这里的sequence number就是ISN。</li></ul><p>TCP连接建立的根本目的是交换双方的ISN，这是可靠性的基础。</p><h5 id="Enable-C-17-support-in-VSCode-C-C-extension"><a href="#Enable-C-17-support-in-VSCode-C-C-extension" class="headerlink" title="Enable C++17 support in VSCode C/C++ extension"></a>Enable C++17 support in VSCode C/C++ extension</h5><p>起因是<code>tcp_receiver.hh/cc</code>中，关于<code>std::optional&lt;WrappingInt32&gt; ackno() const</code>报错：</p><blockquote><p>不允许使用限定名</p></blockquote><p>有点奇怪，之前没遇到过。查了一下<code>optional</code>发现这是C++17才有的，而且代码本身应该是没问题的，那应该是vscode c++扩展没有支持C++17。找到设置里面，搜索<code>cppstandard</code>，然后改成<code>c++ 17</code>即可。</p><h5 id="整体结构"><a href="#整体结构" class="headerlink" title="整体结构"></a>整体结构</h5><p>我们需要完成三个函数，主要的是<code>segment_received</code>。回忆我们的<code>stream_reassembler</code>，其中<code>push_substring</code>需要<code>string data/ size_t index/ bool eof</code>三个参数。而<code>segment</code>包括：<code>TCP header / data</code>。因此在接收到<code>segment</code>之后我们需要得到这些信息、然后调用<code>push_substring</code>函数。</p><p>那么现在逐渐变得清晰：</p><ul><li><p>得到<code>segment</code>的<code>SYN</code>字段，从而判断是否需要设置</p><ul><li>所以我们需要知道sponge 库里面TCP segment 提供的方法</li><li>另外，考虑到后续还需要用到<code>ISN</code>，所以有必要设置一个私有成员存储<code>ISN</code></li></ul></li><li><p>得到<code>FIN</code>字段，从而去结束<code>stream_reassembler</code></p></li><li><p>注意<code>push_substring</code>中<code>index</code>为<code>size_t</code>，我们需要将<code>int32_t</code>的sequence number转化成<code>int64_t</code>。这就需要调用<code>WrappingInt32</code>，并且我们需要知道<code>checkpoint</code>。提示：</p><blockquote><p>In your TCP implementation, you’ll use the index of the last reassembled byte as the checkpoint.</p></blockquote><p>这样也就是窗口左边的index——<code>_first_unreassembled</code>左边。</p></li><li><p>如何得到<code>data</code>？<code>tcp_segment</code>提供了接口：</p><div class="hljs"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">const</span> Buffer &amp;<span class="hljs-title">payload</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123; <span class="hljs-keyword">return</span> _payload; &#125;<span class="hljs-function">Buffer &amp;<span class="hljs-title">payload</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> _payload; &#125;</code></pre></div></li></ul><p>另外关于<code>optional</code>的使用，参考：</p><blockquote><p><a href="https://en.cppreference.com/w/cpp/utility/optional" target="_blank" rel="noopener">https://en.cppreference.com/w/cpp/utility/optional</a></p></blockquote><h5 id="segment-received的思路与细节"><a href="#segment-received的思路与细节" class="headerlink" title="segment_received的思路与细节"></a><code>segment_received</code>的思路与细节</h5><p>原本的思路过于简陋，存在很多bug。后续通过test修补了很多。</p><p><strong>debug：</strong></p><p>在<code>FIN = true</code>时，我们以为直接<code>push_substring</code>，由于<code>EOF = true</code>会使得重组器的<code>ByteTream _output</code>结束输入。但是事实上并没有——<code>_output</code>的输入结束必须是不存在unreassembled_segs。</p><p>回顾实验一中<code>push_substring</code>的定义：</p><blockquote><p><code>eof</code>: the last byte of this substring will be the last byte in the entire stream</p></blockquote><p>也就是说，<code>eof = true</code>仅仅说明当前的substring是最后的字符串。这是很符合实际的，由于网络延迟的存在，后续到来的substring可能是在该substring之前，我们当然应该将其reassembled而不是拒绝输入。</p><p>在<code>reassembled_bytes</code>中，我们的逻辑是这样的：</p><div class="hljs"><pre><code class="hljs c++"><span class="hljs-keyword">if</span>(eof)_eof = <span class="hljs-literal">true</span>;<span class="hljs-keyword">if</span>(_eof &amp;&amp; empty())_output.end_input();</code></pre></div><p>现在，我们在<code>FIN</code>之后到来的segment<strong>应该能够</strong>让<code>_output</code>结束输入。上面的逻辑是可以处理的。</p><p>排查发现<code>segment_received</code>里面多了第一行：</p><div class="hljs"><pre><code class="hljs c++"><span class="hljs-keyword">if</span>(_has_fin)<span class="hljs-keyword">return</span>;</code></pre></div><p>显然，并不能这样处理。删除之后即可。</p><h5 id="ackno-实现"><a href="#ackno-实现" class="headerlink" title="ackno()实现"></a><code>ackno()</code>实现</h5><blockquote><p>Returns anoptional<WrappingInt32>containing the sequence number of the first byte that the receiver doesn’t already know.  This is the windows’s left edge:  the first byte the receiveris interested in receiving.  If the ISN hasn’t been set yet, return an empty optional.</p></blockquote><p>初始版本：</p><div class="hljs"><pre><code class="hljs c++"><span class="hljs-function">optional&lt;WrappingInt32&gt; <span class="hljs-title">TCPReceiver::ackno</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;    <span class="hljs-keyword">if</span>(_has_syn)&#123;        <span class="hljs-keyword">size_t</span> tmp = <span class="hljs-number">1</span>;        <span class="hljs-comment">//firstly get the absolute sequence number </span>            <span class="hljs-comment">//normally just add 1 but if fin add 2 </span>        <span class="hljs-comment">//then using wrap -- translating the asn to sq</span>        <span class="hljs-keyword">if</span>(_has_fin &amp;&amp; _reassembler.unassembled_bytes() == <span class="hljs-number">0</span>)tmp = <span class="hljs-number">2</span>;        <span class="hljs-keyword">return</span> wrap(_reassembler.stream_out().bytes_written() + tmp, _ISN_peer);    &#125;    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-built_in">std</span>::nullopt;&#125;</code></pre></div><p>注释：</p><p>因为我们需要返回的是absolute seqno，因此是在stream index基础上增加一。而且需要考虑，如果<code>FIN</code>已经到达并且没有unassembled bytes，那么我们需要对<code>FIN</code>进行确认。当然，如果还存在unassembled bytes，那么ackno并不需要特别处理。</p><p><strong>报错：</strong></p><blockquote><p>Failure message:<br>        The TCPReceiver reported ackno <code>6</code>, but it was expected to be <code>7</code></p><p>List of steps that executed successfully:<br>        Initialized with (capacity=4000)<br>        Action:      segment arrives Header(flags=SF,seqno=5,ack=0,win=0)<br>        Expectation: in state <code>input to stream has ended</code></p></blockquote><p>test case如下：</p><p><img src="https://i.loli.net/2021/03/09/Cy3UPoYOX1i5eSu.png" srcset="/img/loading.gif" alt="image-20210309105109752"></p><p>结合<code>segment_received</code>代码可以确定，由于没有设置<code>_has_fin = true</code>导致<code>ackno</code>错误。</p><p><strong>报错：</strong></p><blockquote><p>Failure message:<br>        The TCPReceiver reported ackno <code>3836842352</code>, but it was expected to be <code>3836842365</code></p><p>List of steps that executed successfully:<br>        Initialized with (capacity=4000)<br>        Expectation: in state <code>waiting for SYN: ackno is empty</code><br>        Action:      segment arrives Header(flags=S,seqno=3836842351,ack=0,win=0) with data “Hello, CS144!”<br>        Expectation: in state <code>SYN received (ackno exists), and input to stream hasn&#39;t ended</code></p></blockquote><p>返回的<code>ackno</code>错误。可能的原因包括：</p><ul><li><code>bytes_written</code>错误，导致返回了错误的结果</li><li><code>segment_received</code>错误，即插入时设置的index错误，或者其他逻辑错误，导致<code>bytes_written</code>错误</li><li><code>wrap</code>用法错误</li></ul><p>通过在<code>ackno</code>函数中打印<code>bytes_written</code>得知其错误，输出值一直是0。</p><p>通过对比special case：SYN with data 和<code>segment_receive</code>，可以确认逻辑错误：此时得到的<code>abs_seqno</code>错误。增加对包含数据时SYN的特判即可。</p>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
      <category>CS144</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
      <tag>CS144</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CS144-02-Lab1</title>
    <link href="/2021/02/06/CS144-02-Lab1/"/>
    <url>/2021/02/06/CS144-02-Lab1/</url>
    
    <content type="html"><![CDATA[<hr><p>这次实验我们需要完成一个子串重组的类。因为我们的数据包被TCP Sender分割成很多的segments。我们需要在receiver处将其重组成完整的byte-stream。</p><p>首先，我们需要考虑大体上数据结构以及算法：</p><ul><li>substring到来随机，我们需要将其插入合适的位置。因此需要插入性能较好的结构。考虑到可能与前后的子串重合，因此需要方便地得到前后子串。</li><li>考虑到插入，那么树形结构比较合适。我们知道每个substring的index，因此可以据此进行排序。</li><li>考虑使用set。我们需要构建一个structure并且自定义如何比较以及排序方式。set支持双向迭代器，因此插入之后可以得到前后的元素进行操作。</li></ul><p>其次，如何去重？这里我们不需要考虑什么字符串匹配算法，因为我们知道index信息，根据前面元素的index以及长度结合当前元素的index就可以知道是否重合及其相应的处理方式。</p><p>另外，对于capacity的理解：</p><ul><li><p>我们有一个byte-stream——<code>_output</code>用于存储接收到并且组装好的segments。另外还有部分容量用于存储不与<code>_output</code>连续的子串。一旦连续自然也需要写入<code>_output</code></p></li><li><p>指导书上面的示意图：</p><p><img src="https://i.loli.net/2021/03/02/YLDScgfaBIdWiAw.png" srcset="/img/loading.gif" alt="image-20210302194203433"></p></li></ul><p>我们考虑一下index各种可能的情况：</p><ul><li>处于first unacceptable之后 那么直接丢弃</li><li>处于first unread之前 有可能其延申一直到first unassembled之后 仍然需要处理</li><li>处于first unread和first unassembled之间 同上 需要处理</li><li>处于first unassembled和first unacceptable之间 自然需要处理</li></ul><p>其中2/3两种情况本质是一样的，因为绿色部分已经完成，所以我们只需要截取first unassembled及其之后的部分即可。 继续这样的思路，我们应该先进行预处理、得到红色部分需要插入的substring再进行插入。当然，超出first unacceptable之后的就直接截断。</p><p>如何实现？</p><ul><li>我们必须记录<code>first_unread--_first_unread</code>。根据<code>_output.buffer_size()</code>便可以得到<code>first_unassembled</code>。</li></ul><p>现在，我们已经得到的需要插入的结构体了。</p><p>我们首先需要找到插入的位置——<code>lower_bound</code>返回第一个大于等于index的元素，之后不断尝试合并即可——这里我们考虑构建一个函数用于合并两个结构体。而且并不仅仅考虑后面的元素，<code>lower_bound</code>返回结果之前的可能也会产生重叠，需要判断。</p><p>更具体来说，如何设计这个函数？有很多种可能的方式：</p><ul><li>传入<code>set&lt;node&gt;::iterator</code>，根据迭代器得到元素进而进行比较，如果重叠那么修改待插入的结构体，删除<code>iterator</code>指向的结构体；<ul><li>我们是在函数内部删除还是在调用处删除？</li><li><a href="https://stackoverflow.com/questions/9726375/stdset-iterator-automatically-const" target="_blank" rel="noopener">https://stackoverflow.com/questions/9726375/stdset-iterator-automatically-const</a></li></ul></li><li>我们首先插入，然后直接修改<code>set&lt;node&gt;</code>。这样有一个弊端就是，我们并不能直接插入，因为可能存在相同的<code>index</code>——我们需要额外处理，但是如果只是处理这个相同<code>index</code>的元素那么在插入之后仍然需要与后续元素进行比较、处理，代码比较冗余；</li><li>注意如果能够合并，那么显然会影响<code>_unassembled_bytes</code>，如何实现？直接在内部修改还是传回返回值然后修改？</li></ul><p>其实除了上述的<code>set</code>方法之外，可能直接使用一个<code>string</code>也是可以的。我们可能需要一个<code>vector&lt;bool&gt;</code>进行标记<code>string</code>每一位是否是由<code>substring</code>占据。这样的好处是我们不需要比较繁琐的判断重叠、合并的操作，我们直接去填充<code>string</code>然后将标记为置为<code>true</code>即可。当然一开始为了保险起见用了<code>set</code>，写的过程当中就觉得<code>string</code>应该方便很多。</p><p>现在我们已经完成了讲个基本的数据结构——<code>byte_stream</code>和<code>stream_assembler</code>。</p><blockquote><p>目前尚未真正涉及TCP协议本身的内容，感觉像是完成了两道CSP模拟题。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
      <category>CS144</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
      <tag>CS144</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CS144-01-Lab0</title>
    <link href="/2021/01/30/CS144-01-Lab0/"/>
    <url>/2021/01/30/CS144-01-Lab0/</url>
    
    <content type="html"><![CDATA[<h4 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h4><h5 id="VSCode-Remote-Development"><a href="#VSCode-Remote-Development" class="headerlink" title="VSCode Remote Development"></a>VSCode Remote Development</h5><ul><li><p>随便搜了一些教程，按步骤操作即可。</p><p><img src="C:\Users\28425\AppData\Roaming\Typora\typora-user-images\image-20210131143446968.png" srcset="/img/loading.gif" alt="image-20210131143446968" style="zoom: 50%;" /></p></li><li><p>中间自动推荐了C++相关插件，安装即可。</p></li></ul><h5 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h5><ul><li><p>安装</p><div class="hljs"><pre><code class="hljs html">git config --global user.name "xxx" // user.email "xxx"</code></pre></div></li><li><p>关联远程仓库并推送</p><div class="hljs"><pre><code class="hljs xml">git remote -v可以看到已经存在的仓库 因为是从CS144的官方clone下来的git remote add qscs144 URL git add .git commit -mgit push qscs144 master</code></pre></div></li><li><p>配置SSH相关。注意ubuntu启动ssh agent: <code>exec ssh-agent bash</code></p></li></ul><h4 id="正式实验"><a href="#正式实验" class="headerlink" title="正式实验"></a>正式实验</h4><h5 id="webget-cc"><a href="#webget-cc" class="headerlink" title="webget.cc"></a>webget.cc</h5><p>我们的目标是实现<code>void get_URL(const string &amp;host, const string &amp;path)</code>函数。</p><p>具体来说：</p><ul><li><p>理解基本的socket编程</p></li><li><p>阅读sponge库 知道对应的接口</p></li></ul><div class="hljs"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">get_URL</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span> &amp;host, <span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span> &amp;path)</span> </span>&#123;    TCPSocket soct;    soct.<span class="hljs-built_in">connect</span>(Address(host, <span class="hljs-string">"http"</span>));    <span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span> httpDatagram = <span class="hljs-string">"GET "</span> + path + <span class="hljs-string">" HTTP/1.1\r\n"</span> +                                 <span class="hljs-string">"Host: "</span> + host + <span class="hljs-string">"\r\n\r\n"</span>;    soct.<span class="hljs-built_in">write</span>(httpDatagram);    soct.<span class="hljs-built_in">shutdown</span>(SHUT_WR);    <span class="hljs-keyword">while</span>(!soct.eof())        <span class="hljs-built_in">cout</span>&lt;&lt;soct.<span class="hljs-built_in">read</span>();    soct.<span class="hljs-built_in">close</span>();    <span class="hljs-keyword">return</span>;&#125;</code></pre></div><p><img src="https://i.loli.net/2021/02/01/jRvxaIM3UEVYmbc.png" srcset="/img/loading.gif" alt="image-20210201182035652" style="zoom:67%;" /></p><p><img src="https://i.loli.net/2021/02/01/ihq8ZB2t4op5dcu.png" srcset="/img/loading.gif" alt="image-20210201182059748" style="zoom:67%;" /></p><h5 id="an-in-memory-reliable-byte-stream"><a href="#an-in-memory-reliable-byte-stream" class="headerlink" title="an in-memory reliable byte stream"></a>an in-memory reliable byte stream</h5><p>在上面的实验中我们可以看到socket提供给用户的感觉就是能够将字节可靠地通过网络在主机之间进行交互。这里我们需要实现一个单线程的、位于内存的byte stream。</p><p>要求：</p><ul><li>有序 FIFO</li><li>初始化时固定容量</li><li>控制输入操作</li></ul><p>如何实现？思路：</p><ul><li>最初根据FIFO第一反应是直接使用<code>queue</code>。但是我们<code>read/write</code>的对象都是<code>string</code>，而且有时需要根据字节长度去读取，因此使用<code>queue</code>比较麻烦——需要不断地去遍历得到指定长度的<code>string</code></li><li>直接使用一个<code>string</code>对象？所有的操作直接在这个对象上进行。感觉比较方便。</li></ul><blockquote><p><code>string</code>与字符、字节之间的关系</p></blockquote><p>具体代码比较简单。</p><h4 id="关于构建"><a href="#关于构建" class="headerlink" title="关于构建"></a>关于构建</h4><ul><li><p>注意，这里我们必须列表初始化成员：</p><blockquote><p>‘ByteStream::_BStream’ should be initialized in the member initialization list [-Werror=effc++]</p></blockquote></li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
      <category>CS144</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
      <tag>CS144</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MIT6.828-02-Lab1</title>
    <link href="/2021/01/27/MIT6-828-02-Lab1/"/>
    <url>/2021/01/27/MIT6-828-02-Lab1/</url>
    
    <content type="html"><![CDATA[<h4 id="Part1-PC-Bootstrap"><a href="#Part1-PC-Bootstrap" class="headerlink" title="Part1: PC Bootstrap"></a>Part1: PC Bootstrap</h4><h5 id="熟悉x86汇编"><a href="#熟悉x86汇编" class="headerlink" title="熟悉x86汇编"></a>熟悉x86汇编</h5><ul><li><p><a href="https://www.ibm.com/developerworks/cn/linux/l-assembly/" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/linux/l-assembly/</a> 介绍了Linux环境下基本的AT&amp;T风格的汇编</p><p>在编写<code>hello.s</code>之后<code>as -o hello.o hello.s</code>提示：</p><blockquote><p>hello.s: Assembler messages:<br>hello.s: Warning: end of file not at end of a line; newline inserted</p></blockquote><p>在<code>hello.s</code>末尾添加新行即可。<strong>WHY</strong></p><p>另外介绍了inline assembly的基本用法，有点好玩，GCC的支持使得我们可以直接在C语言中直接写汇编。</p></li><li><p><a href="https://pdos.csail.mit.edu/6.828/2018/readings/i386/toc.htm" target="_blank" rel="noopener">80386 Programmer’s Reference Manual</a> 包括从基本的计算机组成到x86 assembly，1.2介绍了历史发展，可以与操作系统的知识结合在一起：从段式分配到页式分配。另外appendix里面包括了80x86 instructions，比较方便。</p></li></ul><h5 id="启动过程"><a href="#启动过程" class="headerlink" title="启动过程"></a>启动过程</h5><ul><li><p><strong>Exercise 2</strong>： Use GDB’s si (Step Instruction) command to trace into the ROM BIOS for a few more instructions, and try to guess what it might be doing.</p><p>首先我们想知道电脑启动的整体过程。<a href="https://medium.com/an-idea/the-not-so-magic-of-how-your-computer-boots-up-2f5e8289451d" target="_blank" rel="noopener">这篇文章介绍了大致过程</a> </p><p>其次使用<code>si</code>去看具体执行了那些命令。</p></li></ul><h4 id="Part2-The-Boot-Loader"><a href="#Part2-The-Boot-Loader" class="headerlink" title="Part2: The Boot Loader"></a>Part2: The Boot Loader</h4><ul><li><p><img src="https://i.loli.net/2021/01/30/vEmgqHpltSQM5CA.png" srcset="/img/loading.gif" alt="image-20210130160415527"></p><p>上图中，左边是使用GDB单步执行的过程，右边是boot.S。</p></li></ul><h5 id="理解boot-loader-source-code"><a href="#理解boot-loader-source-code" class="headerlink" title="理解boot loader source code"></a>理解boot loader source code</h5>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
      <category>MIT6.828</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
      <tag>MIT6.828</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MIT6.828-01-环境配置与工具使用</title>
    <link href="/2021/01/27/MIT6.828-01-%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    <url>/2021/01/27/MIT6.828-01-%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h4 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h4><blockquote><p>Ubuntu 18.04</p></blockquote><p>这门课实验的最终目标是实现一个微内核操作系统JOS，它是在xv6的基础上改写的。xv6是运行在x86架构上的用于教学的类UNIX操作系统。因此，一方面我们需要利用QEMU来运行xv6，另一方面需要编译工具链来对内核进行编译。官方给的指导：<a href="https://pdos.csail.mit.edu/6.828/2018/tools.html" target="_blank" rel="noopener">https://pdos.csail.mit.edu/6.828/2018/tools.html</a></p><p>事实上这中间可能会遇到一些问题，例如：</p><p><code>make &amp;&amp; make install</code>之后报错：</p><div class="hljs"><pre><code class="hljs html">qga/commands-posix.c: In function ‘dev_major_minor’:qga/commands-posix.c:633:13: error: In the GNU C Library, "major" is defined by <span class="hljs-tag">&lt;<span class="hljs-name">sys</span>/<span class="hljs-attr">sysmacros.h</span>&gt;</span>. For historical compatibility, it is currently defined by <span class="hljs-tag">&lt;<span class="hljs-name">sys</span>/<span class="hljs-attr">types.h</span>&gt;</span> as well, but we plan to remove this soon. To use "major", include <span class="hljs-tag">&lt;<span class="hljs-name">sys</span>/<span class="hljs-attr">sysmacros.h</span>&gt;</span> directly. If you did not intend to use a system-defined macro "major", you should undefine it after including <span class="hljs-tag">&lt;<span class="hljs-name">sys</span>/<span class="hljs-attr">types.h</span>&gt;</span>. [-Werror]         *devmajor = major(st.st_rdev);             ^~~~~~~~~~~~~~~~~~~~~~~~~~  qga/commands-posix.c:634:13: error: In the GNU C Library, "minor" is defined by <span class="hljs-tag">&lt;<span class="hljs-name">sys</span>/<span class="hljs-attr">sysmacros.h</span>&gt;</span>. For historical compatibility, it is currently defined by <span class="hljs-tag">&lt;<span class="hljs-name">sys</span>/<span class="hljs-attr">types.h</span>&gt;</span> as well, but we plan to remove this soon. To use "minor", include <span class="hljs-tag">&lt;<span class="hljs-name">sys</span>/<span class="hljs-attr">sysmacros.h</span>&gt;</span> directly. If you did not intend to use a system-defined macro "minor", you should undefine it after including <span class="hljs-tag">&lt;<span class="hljs-name">sys</span>/<span class="hljs-attr">types.h</span>&gt;</span>. [-Werror]         *devminor = minor(st.st_rdev);             ^~~~~~~~~~~~~~~~~~~~~~~~~~</code></pre></div><p>好在一般前人都踩过坑，Google一下直接照葫芦画瓢即可。</p><p>注：官方QEMU安装教程里面给出的提示，看到网上一些教程貌似没有注意到这里踩了挺多坑。</p><blockquote><p>On Linux, you may need to install several libraries. We have successfully built 6.828 QEMU on Debian/Ubuntu 16.04 after installing the following packages: libsdl1.2-dev, libtool-bin, libglib2.0-dev, libz-dev, and libpixman-1-dev</p></blockquote><h4 id="工具使用"><a href="#工具使用" class="headerlink" title="工具使用"></a>工具使用</h4><h5 id="QEMU"><a href="#QEMU" class="headerlink" title="QEMU"></a>QEMU</h5><ul><li>之前做CS:APP MIPS版本的bomb lab时使用过。主要是模拟硬件，这门课程中模拟了一个32位x86平台。</li></ul><h5 id="GDB"><a href="#GDB" class="headerlink" title="GDB"></a>GDB</h5><ul><li>用得不多，没有系统学过。</li></ul>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
      <category>MIT6.828</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
      <tag>6.828</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
