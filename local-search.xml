<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>CS144-02-Lab1</title>
    <link href="/2021/02/06/CS144-02-Lab1/"/>
    <url>/2021/02/06/CS144-02-Lab1/</url>
    
    <content type="html"><![CDATA[<hr><p>这次实验我们需要完成一个子串重组的类。因为我们的数据包被TCP Sender分割成很多的segments。我们需要在receiver处将其重组成完整的byte stream。</p><p>首先，我们需要考虑大体上数据结构以及算法：</p><ul><li>substring到来随机，我们需要将其插入合适的位置。因此需要插入性能较好的结构。考虑到可能与前后的子串重合，因此需要方便地得到前后子串。</li><li>考虑到插入，那么树形结构比较合适。我们知道每个substring的index，因此可以据此进行排序。</li><li>考虑使用set。我们需要构建一个structure并且自定义如何比较以及排序方式。set支持双向迭代器，因此插入之后可以得到前后的元素进行操作。</li></ul><p>其次，如何去重？这里我们不需要考虑什么字符串匹配算法，因为我们知道index信息，根据前面元素的index以及长度结合当前元素的index就可以知道是否重合及其相应的处理方式。</p><p>另外，对于capacity的理解：</p><ul><li>我们有一个byte stream用于存储接收到并且组装好的segments。另外还有部分容量用于存储不与byte stream连续的子串。一旦连续自然也需要写入byte stream</li></ul><p>因此，push_substring的算法如下：</p><ul><li><p>首先判断substring能否被接收：</p><ul><li><p>是否处于当前可接收index range。为了记录当前byte stream中起始substring的index，参考指导书上的示意图，需要<strong>first_unread/first_unassembled/first_unacceptable</strong></p></li><li><p>如果在first_unassembled和first_unacceptable之间，那么考虑是否需要将其插入——因为可能已经有了其位置。因此使用set方法查找最后一个小于等于其index的substring，记为a，其后的元素记为b，当前待处理的记为c。根据c与a/b是否重合有四种情况，分别处理即可。</p></li></ul></li><li><p>如果first_unassembled恰好是byte stream之后的string，那么需要将连续的字节插入。我们考虑实现一个方法，就是将连续的字节全部写入byte stream。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
      <category>CS144</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
      <tag>CS144</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CS144-01-Lab0</title>
    <link href="/2021/01/30/CS144-01-Lab0/"/>
    <url>/2021/01/30/CS144-01-Lab0/</url>
    
    <content type="html"><![CDATA[<h4 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h4><h5 id="VSCode-Remote-Development"><a href="#VSCode-Remote-Development" class="headerlink" title="VSCode Remote Development"></a>VSCode Remote Development</h5><ul><li><p>随便搜了一些教程，按步骤操作即可。</p><p><img src="C:\Users\28425\AppData\Roaming\Typora\typora-user-images\image-20210131143446968.png" srcset="/img/loading.gif" alt="image-20210131143446968" style="zoom: 50%;" /></p></li><li><p>中间自动推荐了C++相关插件，安装即可。</p></li></ul><h5 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h5><ul><li><p>安装</p><div class="hljs"><pre><code class="hljs html">git config --global user.name "xxx" // user.email "xxx"</code></pre></div></li><li><p>关联远程仓库并推送</p><div class="hljs"><pre><code class="hljs xml">git remote -v可以看到已经存在的仓库 因为是从CS144的官方clone下来的git remote add qscs144 URL git add .git commit -mgit push qscs144 master</code></pre></div></li><li><p>配置SSH相关。注意ubuntu启动ssh agent: <code>exec ssh-agent bash</code></p></li></ul><h4 id="正式实验"><a href="#正式实验" class="headerlink" title="正式实验"></a>正式实验</h4><h5 id="webget-cc"><a href="#webget-cc" class="headerlink" title="webget.cc"></a>webget.cc</h5><p>我们的目标是实现<code>void get_URL(const string &amp;host, const string &amp;path)</code>函数。</p><p>具体来说：</p><ul><li><p>理解基本的socket编程</p></li><li><p>阅读sponge库 知道对应的接口</p></li></ul><div class="hljs"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">get_URL</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span> &amp;host, <span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span> &amp;path)</span> </span>&#123;    TCPSocket soct;    soct.<span class="hljs-built_in">connect</span>(Address(host, <span class="hljs-string">"http"</span>));    <span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span> httpDatagram = <span class="hljs-string">"GET "</span> + path + <span class="hljs-string">" HTTP/1.1\r\n"</span> +                                 <span class="hljs-string">"Host: "</span> + host + <span class="hljs-string">"\r\n\r\n"</span>;    soct.<span class="hljs-built_in">write</span>(httpDatagram);    soct.<span class="hljs-built_in">shutdown</span>(SHUT_WR);    <span class="hljs-keyword">while</span>(!soct.eof())        <span class="hljs-built_in">cout</span>&lt;&lt;soct.<span class="hljs-built_in">read</span>();    soct.<span class="hljs-built_in">close</span>();    <span class="hljs-keyword">return</span>;&#125;</code></pre></div><p><img src="https://i.loli.net/2021/02/01/jRvxaIM3UEVYmbc.png" srcset="/img/loading.gif" alt="image-20210201182035652" style="zoom:67%;" /></p><p><img src="https://i.loli.net/2021/02/01/ihq8ZB2t4op5dcu.png" srcset="/img/loading.gif" alt="image-20210201182059748" style="zoom:67%;" /></p><h5 id="an-in-memory-reliable-byte-stream"><a href="#an-in-memory-reliable-byte-stream" class="headerlink" title="an in-memory reliable byte stream"></a>an in-memory reliable byte stream</h5><p>在上面的实验中我们可以看到socket提供给用户的感觉就是能够将字节可靠地通过网络在主机之间进行交互。这里我们需要实现一个单线程的、位于内存的byte stream。</p><p>要求：</p><ul><li>有序 FIFO</li><li>初始化时固定容量</li><li>控制输入操作</li></ul><p>如何实现？思路：</p><ul><li>最初根据FIFO第一反应是直接使用<code>queue</code>。但是我们<code>read/write</code>的对象都是<code>string</code>，而且有时需要根据字节长度去读取，因此使用<code>queue</code>比较麻烦——需要不断地去遍历得到指定长度的<code>string</code></li><li>直接使用一个<code>string</code>对象？所有的操作直接在这个对象上进行。感觉比较方便。</li></ul><blockquote><p><code>string</code>与字符、字节之间的关系</p></blockquote><p>具体代码比较简单。</p><h4 id="关于构建"><a href="#关于构建" class="headerlink" title="关于构建"></a>关于构建</h4><ul><li><p>注意，这里我们必须列表初始化成员：</p><blockquote><p>‘ByteStream::_BStream’ should be initialized in the member initialization list [-Werror=effc++]</p></blockquote></li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
      <category>CS144</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
      <tag>CS144</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MIT6.828-02-Lab1</title>
    <link href="/2021/01/27/MIT6-828-02-Lab1/"/>
    <url>/2021/01/27/MIT6-828-02-Lab1/</url>
    
    <content type="html"><![CDATA[<h4 id="Part1-PC-Bootstrap"><a href="#Part1-PC-Bootstrap" class="headerlink" title="Part1: PC Bootstrap"></a>Part1: PC Bootstrap</h4><h5 id="熟悉x86汇编"><a href="#熟悉x86汇编" class="headerlink" title="熟悉x86汇编"></a>熟悉x86汇编</h5><ul><li><p><a href="https://www.ibm.com/developerworks/cn/linux/l-assembly/" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/linux/l-assembly/</a> 介绍了Linux环境下基本的AT&amp;T风格的汇编</p><p>在编写<code>hello.s</code>之后<code>as -o hello.o hello.s</code>提示：</p><blockquote><p>hello.s: Assembler messages:<br>hello.s: Warning: end of file not at end of a line; newline inserted</p></blockquote><p>在<code>hello.s</code>末尾添加新行即可。<strong>WHY</strong></p><p>另外介绍了inline assembly的基本用法，有点好玩，GCC的支持使得我们可以直接在C语言中直接写汇编。</p></li><li><p><a href="https://pdos.csail.mit.edu/6.828/2018/readings/i386/toc.htm" target="_blank" rel="noopener">80386 Programmer’s Reference Manual</a> 包括从基本的计算机组成到x86 assembly，1.2介绍了历史发展，可以与操作系统的知识结合在一起：从段式分配到页式分配。另外appendix里面包括了80x86 instructions，比较方便。</p></li></ul><h5 id="启动过程"><a href="#启动过程" class="headerlink" title="启动过程"></a>启动过程</h5><ul><li><p><strong>Exercise 2</strong>： Use GDB’s si (Step Instruction) command to trace into the ROM BIOS for a few more instructions, and try to guess what it might be doing.</p><p>首先我们想知道电脑启动的整体过程。<a href="https://medium.com/an-idea/the-not-so-magic-of-how-your-computer-boots-up-2f5e8289451d" target="_blank" rel="noopener">这篇文章介绍了大致过程</a> </p><p>其次使用<code>si</code>去看具体执行了那些命令。</p></li></ul><h4 id="Part2-The-Boot-Loader"><a href="#Part2-The-Boot-Loader" class="headerlink" title="Part2: The Boot Loader"></a>Part2: The Boot Loader</h4><ul><li><p><img src="https://i.loli.net/2021/01/30/vEmgqHpltSQM5CA.png" srcset="/img/loading.gif" alt="image-20210130160415527"></p><p>上图中，左边是使用GDB单步执行的过程，右边是boot.S。</p></li></ul><h5 id="理解boot-loader-source-code"><a href="#理解boot-loader-source-code" class="headerlink" title="理解boot loader source code"></a>理解boot loader source code</h5>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
      <category>MIT6.828</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
      <tag>MIT6.828</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MIT6.828-01-环境配置与工具使用</title>
    <link href="/2021/01/27/MIT6.828-01-%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    <url>/2021/01/27/MIT6.828-01-%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h4 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h4><blockquote><p>Ubuntu 18.04</p></blockquote><p>这门课实验的最终目标是实现一个微内核操作系统JOS，它是在xv6的基础上改写的。xv6是运行在x86架构上的用于教学的类UNIX操作系统。因此，一方面我们需要利用QEMU来运行xv6，另一方面需要编译工具链来对内核进行编译。官方给的指导：<a href="https://pdos.csail.mit.edu/6.828/2018/tools.html" target="_blank" rel="noopener">https://pdos.csail.mit.edu/6.828/2018/tools.html</a></p><p>事实上这中间可能会遇到一些问题，例如：</p><p><code>make &amp;&amp; make install</code>之后报错：</p><div class="hljs"><pre><code class="hljs html">qga/commands-posix.c: In function ‘dev_major_minor’:qga/commands-posix.c:633:13: error: In the GNU C Library, "major" is defined by <span class="hljs-tag">&lt;<span class="hljs-name">sys</span>/<span class="hljs-attr">sysmacros.h</span>&gt;</span>. For historical compatibility, it is currently defined by <span class="hljs-tag">&lt;<span class="hljs-name">sys</span>/<span class="hljs-attr">types.h</span>&gt;</span> as well, but we plan to remove this soon. To use "major", include <span class="hljs-tag">&lt;<span class="hljs-name">sys</span>/<span class="hljs-attr">sysmacros.h</span>&gt;</span> directly. If you did not intend to use a system-defined macro "major", you should undefine it after including <span class="hljs-tag">&lt;<span class="hljs-name">sys</span>/<span class="hljs-attr">types.h</span>&gt;</span>. [-Werror]         *devmajor = major(st.st_rdev);             ^~~~~~~~~~~~~~~~~~~~~~~~~~  qga/commands-posix.c:634:13: error: In the GNU C Library, "minor" is defined by <span class="hljs-tag">&lt;<span class="hljs-name">sys</span>/<span class="hljs-attr">sysmacros.h</span>&gt;</span>. For historical compatibility, it is currently defined by <span class="hljs-tag">&lt;<span class="hljs-name">sys</span>/<span class="hljs-attr">types.h</span>&gt;</span> as well, but we plan to remove this soon. To use "minor", include <span class="hljs-tag">&lt;<span class="hljs-name">sys</span>/<span class="hljs-attr">sysmacros.h</span>&gt;</span> directly. If you did not intend to use a system-defined macro "minor", you should undefine it after including <span class="hljs-tag">&lt;<span class="hljs-name">sys</span>/<span class="hljs-attr">types.h</span>&gt;</span>. [-Werror]         *devminor = minor(st.st_rdev);             ^~~~~~~~~~~~~~~~~~~~~~~~~~</code></pre></div><p>好在一般前人都踩过坑，Google一下直接照葫芦画瓢即可。</p><p>注：官方QEMU安装教程里面给出的提示，看到网上一些教程貌似没有注意到这里踩了挺多坑。</p><blockquote><p>On Linux, you may need to install several libraries. We have successfully built 6.828 QEMU on Debian/Ubuntu 16.04 after installing the following packages: libsdl1.2-dev, libtool-bin, libglib2.0-dev, libz-dev, and libpixman-1-dev</p></blockquote><h4 id="工具使用"><a href="#工具使用" class="headerlink" title="工具使用"></a>工具使用</h4><h5 id="QEMU"><a href="#QEMU" class="headerlink" title="QEMU"></a>QEMU</h5><ul><li>之前做CS:APP MIPS版本的bomb lab时使用过。主要是模拟硬件，这门课程中模拟了一个32位x86平台。</li></ul><h5 id="GDB"><a href="#GDB" class="headerlink" title="GDB"></a>GDB</h5><ul><li>用得不多，没有系统学过。</li></ul>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
      <category>MIT6.828</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
      <tag>6.828</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
